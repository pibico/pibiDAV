{
  "version": 3,
  "sources": ["../../../../../apps/frappe/node_modules/@vue/shared/dist/shared.cjs.prod.js", "../../../../../apps/frappe/node_modules/@vue/shared/index.js", "../../../../../apps/frappe/node_modules/@babel/parser/src/util/location.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parse-error/module-errors.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parse-error/to-node-description.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parse-error/standard-errors.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parse-error/strict-mode-errors.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parse-error/pipeline-operator-errors.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parse-error.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/estree.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/tokenizer/context.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/tokenizer/types.ts", "../../../../../apps/frappe/node_modules/@babel/babel-helper-validator-identifier/src/identifier.ts", "../../../../../apps/frappe/node_modules/@babel/babel-helper-validator-identifier/src/keyword.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/util/identifier.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/util/scope.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/flow/scope.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parser/base.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parser/comments.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/util/whitespace.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/tokenizer/state.ts", "../../../../../apps/frappe/node_modules/@babel/babel-helper-string-parser/src/index.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/tokenizer/index.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/util/class-scope.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/util/expression-scope.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/util/production-parameter.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parser/util.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parser/node.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/flow/index.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/jsx/xhtml.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/jsx/index.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/typescript/scope.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parser/lval.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/typescript/index.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/placeholders.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugins/v8intrinsic.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/plugin-utils.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/options.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parser/expression.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parser/statement.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/parser/index.ts", "../../../../../apps/frappe/node_modules/@babel/parser/src/index.ts", "../../../../../apps/frappe/node_modules/source-map-js/lib/base64.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/base64-vlq.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/util.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/array-set.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/mapping-list.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/source-map-generator.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/binary-search.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/quick-sort.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/source-map-consumer.js", "../../../../../apps/frappe/node_modules/source-map-js/lib/source-node.js", "../../../../../apps/frappe/node_modules/source-map-js/source-map.js", "../../../../../apps/frappe/node_modules/estree-walker/dist/umd/estree-walker.js", "../../../../../apps/frappe/node_modules/@vue/compiler-core/dist/compiler-core.cjs.prod.js", "../../../../../apps/frappe/node_modules/@vue/compiler-core/index.js", "../../../../../apps/frappe/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.prod.js", "../../../../../apps/frappe/node_modules/@vue/compiler-dom/index.js", "../../../../../apps/frappe/node_modules/@vue/reactivity/dist/reactivity.cjs.prod.js", "../../../../../apps/frappe/node_modules/@vue/reactivity/index.js", "../../../../../apps/frappe/node_modules/@vue/runtime-core/dist/runtime-core.cjs.prod.js", "../../../../../apps/frappe/node_modules/@vue/runtime-core/index.js", "../../../../../apps/frappe/node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.prod.js", "../../../../../apps/frappe/node_modules/@vue/runtime-dom/index.js", "../../../../../apps/frappe/node_modules/vue/dist/vue.cjs.prod.js", "../../../../../apps/frappe/node_modules/vue/index.js", "../../../../../apps/pibidav/pibidav/public/js/dist/nc_browser/nc_browser.bundle.js", "../pibidav/pibidav/public/js/dist/nc_browser/TreeNode.vue", "sfc-template:/home/erpnext/erpnext-dev/apps/pibidav/pibidav/public/js/dist/nc_browser/TreeNode.vue?type=template", "../../../../../apps/pibidav/pibidav/public/js/dist/nc_browser/TreeNode.vue", "../pibidav/pibidav/public/js/dist/nc_browser/NcBrowser.vue", "sfc-template:/home/erpnext/erpnext-dev/apps/pibidav/pibidav/public/js/dist/nc_browser/NcBrowser.vue?type=template", "../../../../../apps/pibidav/pibidav/public/js/dist/nc_browser/NcBrowser.vue"],
  "sourcesContent": ["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction makeMap(str, expectsLowerCase) {\n  const map = /* @__PURE__ */ Object.create(null);\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\n}\n\nconst EMPTY_OBJ = {};\nconst EMPTY_ARR = [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction((str) => {\n  const s = str ? `on${capitalize(str)}` : ``;\n  return s;\n});\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg);\n  }\n};\nconst def = (obj, key, value) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\n\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\n\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length)\n          continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  let ret = \"\";\n  if (!styles || isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n    if (isString(value) || typeof value === \"number\") {\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props)\n    return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length)\n    return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b)\n    return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {\n        entries[`${key} =>`] = val2;\n        return entries;\n      }, {})\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()]\n    };\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\n\nexports.EMPTY_ARR = EMPTY_ARR;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.NO = NO;\nexports.NOOP = NOOP;\nexports.PatchFlagNames = PatchFlagNames;\nexports.camelize = camelize;\nexports.capitalize = capitalize;\nexports.def = def;\nexports.escapeHtml = escapeHtml;\nexports.escapeHtmlComment = escapeHtmlComment;\nexports.extend = extend;\nexports.genPropsAccessExp = genPropsAccessExp;\nexports.generateCodeFrame = generateCodeFrame;\nexports.getGlobalThis = getGlobalThis;\nexports.hasChanged = hasChanged;\nexports.hasOwn = hasOwn;\nexports.hyphenate = hyphenate;\nexports.includeBooleanAttr = includeBooleanAttr;\nexports.invokeArrayFns = invokeArrayFns;\nexports.isArray = isArray;\nexports.isBooleanAttr = isBooleanAttr;\nexports.isBuiltInDirective = isBuiltInDirective;\nexports.isDate = isDate;\nexports.isFunction = isFunction;\nexports.isGloballyAllowed = isGloballyAllowed;\nexports.isGloballyWhitelisted = isGloballyWhitelisted;\nexports.isHTMLTag = isHTMLTag;\nexports.isIntegerKey = isIntegerKey;\nexports.isKnownHtmlAttr = isKnownHtmlAttr;\nexports.isKnownSvgAttr = isKnownSvgAttr;\nexports.isMap = isMap;\nexports.isModelListener = isModelListener;\nexports.isObject = isObject;\nexports.isOn = isOn;\nexports.isPlainObject = isPlainObject;\nexports.isPromise = isPromise;\nexports.isRegExp = isRegExp;\nexports.isReservedProp = isReservedProp;\nexports.isSSRSafeAttrName = isSSRSafeAttrName;\nexports.isSVGTag = isSVGTag;\nexports.isSet = isSet;\nexports.isSpecialBooleanAttr = isSpecialBooleanAttr;\nexports.isString = isString;\nexports.isSymbol = isSymbol;\nexports.isVoidTag = isVoidTag;\nexports.looseEqual = looseEqual;\nexports.looseIndexOf = looseIndexOf;\nexports.looseToNumber = looseToNumber;\nexports.makeMap = makeMap;\nexports.normalizeClass = normalizeClass;\nexports.normalizeProps = normalizeProps;\nexports.normalizeStyle = normalizeStyle;\nexports.objectToString = objectToString;\nexports.parseStringStyle = parseStringStyle;\nexports.propsToAttrMap = propsToAttrMap;\nexports.remove = remove;\nexports.slotFlagsText = slotFlagsText;\nexports.stringifyStyle = stringifyStyle;\nexports.toDisplayString = toDisplayString;\nexports.toHandlerKey = toHandlerKey;\nexports.toNumber = toNumber;\nexports.toRawType = toRawType;\nexports.toTypeString = toTypeString;\n", "'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/shared.cjs.prod.js')\n} else {\n  module.exports = require('./dist/shared.cjs.js')\n}\n", "export type Pos = {\n  start: number;\n};\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nexport class Position {\n  line: number;\n  column: number;\n  index: number;\n\n  constructor(line: number, col: number, index: number) {\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\n\nexport class SourceLocation {\n  start: Position;\n  end: Position;\n  filename: string;\n  identifierName: string | undefined | null;\n\n  constructor(start: Position, end?: Position) {\n    this.start = start;\n    // (may start as null, but initialized later)\n    this.end = end;\n  }\n}\n\n/**\n * creates a new position with a non-zero column offset from the given position.\n * This function should be only be used when we create AST node out of the token\n * boundaries, such as TemplateElement ends before tt.templateNonTail. This\n * function does not skip whitespaces.\n */\nexport function createPositionWithColumnOffset(\n  position: Position,\n  columnOffset: number,\n) {\n  const { line, column, index } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\n", "import type { ParseErrorTemplates } from \"../parse-error.ts\";\n\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\n\nexport default {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code,\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code,\n  },\n} satisfies ParseErrorTemplates;\n", "const NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\",\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\",\n};\n\ntype NodeTypesWithDescriptions = keyof Omit<\n  typeof NodeDescriptions,\n  \"UpdateExpression\"\n>;\n\ntype NodeWithDescription =\n  | {\n      type: \"UpdateExpression\";\n      prefix: boolean;\n    }\n  | {\n      type: NodeTypesWithDescriptions;\n    };\n\n// @ts-expect-error prefix is specified only when type is UpdateExpression\n// eslint-disable-next-line no-confusing-arrow\nconst toNodeDescription = ({ type, prefix }: NodeWithDescription) =>\n  type === \"UpdateExpression\"\n    ? NodeDescriptions.UpdateExpression[String(prefix) as \"true\" | \"false\"]\n    : NodeDescriptions[type];\n\nexport default toNodeDescription;\n", "import type { ParseErrorTemplates } from \"../parse-error.ts\";\nimport toNodeDescription from \"./to-node-description.ts\";\n\nexport type LValAncestor =\n  | { type: \"UpdateExpression\"; prefix: boolean }\n  | {\n      type:\n        | \"ArrayPattern\"\n        | \"AssignmentExpression\"\n        | \"CatchClause\"\n        | \"ForOfStatement\"\n        | \"FormalParameters\"\n        | \"ForInStatement\"\n        | \"ForStatement\"\n        | \"ImportSpecifier\"\n        | \"ImportNamespaceSpecifier\"\n        | \"ImportDefaultSpecifier\"\n        | \"ParenthesizedExpression\"\n        | \"ObjectPattern\"\n        | \"RestElement\"\n        | \"VariableDeclarator\";\n    };\n\nexport default {\n  AccessorIsGenerator: ({ kind }: { kind: \"get\" | \"set\" }) =>\n    `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass:\n    \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext:\n    \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier:\n    \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock:\n    \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter:\n    \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext:\n    \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext:\n    \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter:\n    \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField:\n    \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind,\n  }: {\n    kind: \"const\" | \"destructuring\";\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses:\n    \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport:\n    \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport:\n    \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor:\n    \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass:\n    \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace:\n    'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport:\n    \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({ exportName }: { exportName: string }) =>\n    `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  DynamicImportPhaseRequiresImportExpressions: ({ phase }: { phase: string }) =>\n    `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName,\n  }: {\n    localName: string;\n    exportName: string;\n  }) =>\n    `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier:\n    \"'from' is not allowed as an identifier after 'export default'.\",\n\n  ForInOfLoopInitializer: ({\n    type,\n  }: {\n    type: \"ForInStatement\" | \"ForOfStatement\";\n  }) =>\n    `'${\n      type === \"ForInStatement\" ? \"for-in\" : \"for-of\"\n    }' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext:\n    \"Generators can only be declared at the top level or inside a block.\",\n\n  IllegalBreakContinue: ({\n    type,\n  }: {\n    type: \"BreakStatement\" | \"ContinueStatement\";\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n\n  IllegalLanguageModeDirective:\n    \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert:\n    \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.\",\n  ImportBindingIsString: ({ importName }: { importName: string }) =>\n    `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArgumentTrailingComma:\n    \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: ({ maxArgumentCount }: { maxArgumentCount: 1 | 2 }) =>\n    `\\`import()\\` requires exactly ${\n      maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"\n    }.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault:\n    \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding:\n    'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags:\n    \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({ radix }: { radix: number }) =>\n    `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({ reservedWord }: { reservedWord: string }) =>\n    `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({ identifierName }: { identifierName: string }) =>\n    `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({ ancestor }: { ancestor: LValAncestor }) =>\n    `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({ ancestor }: { ancestor: LValAncestor }) =>\n    `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({ ancestor }: { ancestor: LValAncestor }) =>\n    `Invalid optional chaining in the left-hand side of ${toNodeDescription(\n      ancestor,\n    )}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent:\n    \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({ unexpected }: { unexpected: string }) =>\n    `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName,\n  }: {\n    identifierName: string;\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty:\n    \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({ labelName }: { labelName: string }) =>\n    `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment:\n    \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({ missingPlugin }: { missingPlugin: [string] }) =>\n    `This experimental syntax requires enabling the parser plugin: ${missingPlugin\n      .map(name => JSON.stringify(name))\n      .join(\", \")}.`,\n  // FIXME: Would be nice to make this \"missingPlugins\" instead.\n  // Also, seems like we can drop the \"(s)\" from the message and just make it \"s\".\n  MissingOneOfPlugins: ({ missingPlugin }: { missingPlugin: string[] }) =>\n    `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin\n      .map(name => JSON.stringify(name))\n      .join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical:\n    \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType:\n    \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue:\n    \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({ key }: { key: string }) =>\n    `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode,\n  }: {\n    surrogateCharCode: number;\n  }) =>\n    `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(\n      16,\n    )}'.`,\n  ModuleExportUndefined: ({ localName }: { localName: string }) =>\n    `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence:\n    \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar:\n    \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew:\n    \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate:\n    \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor:\n    \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({ identifierName }: { identifierName: string }) =>\n    `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({ identifierName }: { identifierName: string }) =>\n    `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType:\n    \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType:\n    \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType:\n    \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction:\n    \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB:\n    \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault:\n    'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed:\n    \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType:\n    \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType:\n    \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType:\n    \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody:\n    'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport:\n    \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({ keyword }: { keyword: string }) =>\n    `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator:\n    \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration:\n    \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget:\n    \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator:\n    \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({ reservedWord }: { reservedWord: string }) =>\n    `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected,\n  }: {\n    expected?: string | null;\n    unexpected?: string | null;\n  }) =>\n    `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${\n      expected ? `, expected \"${expected}\"` : \"\"\n    }`,\n  UnexpectedTokenUnaryExponentiation:\n    \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration:\n    \"Using declaration cannot appear in the top level when source type is `script`.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport:\n    \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport:\n    \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport:\n    \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName,\n  }: {\n    target: string;\n    onlyValidPropertyName: string;\n  }) =>\n    `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator:\n    \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator:\n    \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper:\n    \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationHasBindingPattern:\n    \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({ identifierName }: { identifierName: string }) =>\n    `Identifier '${identifierName}' has already been declared.`,\n  YieldBindingIdentifier:\n    \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator:\n    \"Numeric separator can not be used after leading 0.\",\n} satisfies ParseErrorTemplates;\n", "import type { ParseErrorTemplates } from \"../parse-error\";\n\nexport default {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n\n  // `referenceName` is the StringValue[1] of an IdentifierReference[2], which\n  // is represented as just an `Identifier`[3] in the Babel AST.\n  // 1. https://tc39.es/ecma262/#sec-static-semantics-stringvalue\n  // 2. https://tc39.es/ecma262/#prod-IdentifierReference\n  // 3. https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md#identifier\n  StrictEvalArguments: ({ referenceName }: { referenceName: string }) =>\n    `Assigning to '${referenceName}' in strict mode.`,\n\n  // `bindingName` is the StringValue[1] of a BindingIdentifier[2], which is\n  // represented as just an `Identifier`[3] in the Babel AST.\n  // 1. https://tc39.es/ecma262/#sec-static-semantics-stringvalue\n  // 2. https://tc39.es/ecma262/#prod-BindingIdentifier\n  // 3. https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md#identifier\n  StrictEvalArgumentsBinding: ({ bindingName }: { bindingName: string }) =>\n    `Binding '${bindingName}' in strict mode.`,\n\n  StrictFunction:\n    \"In strict mode code, functions can only be declared at top level or inside a block.\",\n\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n\n  StrictWith: \"'with' in strict mode.\",\n} satisfies ParseErrorTemplates;\n", "import type { ParseErrorTemplates } from \"../parse-error.ts\";\nimport toNodeDescription from \"./to-node-description.ts\";\n\nexport const UnparenthesizedPipeBodyDescriptions = new Set([\n  \"ArrowFunctionExpression\",\n  \"AssignmentExpression\",\n  \"ConditionalExpression\",\n  \"YieldExpression\",\n] as const);\n\ntype GetSetMemberType<T extends Set<any>> = T extends Set<infer M>\n  ? M\n  : unknown;\n\ntype UnparenthesizedPipeBodyTypes = GetSetMemberType<\n  typeof UnparenthesizedPipeBodyDescriptions\n>;\n\nexport default {\n  // This error is only used by the smart-mix proposal\n  PipeBodyIsTighter:\n    \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes:\n    'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound:\n    \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({ token }: { token: string }) =>\n    `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused:\n    \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({ type }: { type: UnparenthesizedPipeBodyTypes }) =>\n    `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n      type,\n    })}; please wrap it in parentheses.`,\n\n  // Messages whose codes start with \u201CPipeline\u201D or \u201CPrimaryTopic\u201D\n  // are retained for backwards compatibility\n  // with the deprecated smart-mix pipe operator proposal plugin.\n  // They are subject to removal in a future major version.\n  PipelineBodyNoArrow:\n    'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression:\n    \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression:\n    \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused:\n    \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed:\n    \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline:\n    'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n} satisfies ParseErrorTemplates;\n", "import { Position } from \"./util/location.ts\";\nimport type { Undone } from \"./parser/node.ts\";\nimport type { Node } from \"./types.ts\";\n\ntype SyntaxPlugin =\n  | \"flow\"\n  | \"typescript\"\n  | \"jsx\"\n  | \"pipelineOperator\"\n  | \"placeholders\";\n\ntype ParseErrorCode =\n  | \"BABEL_PARSER_SYNTAX_ERROR\"\n  | \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\n\n// Babel uses \"normal\" SyntaxErrors for it's errors, but adds some extra\n// functionality. This functionality is defined in the\n// `ParseErrorSpecification` interface below. We may choose to change to someday\n// give our errors their own full-blown class, but until then this allow us to\n// keep all the desirable properties of SyntaxErrors (like their name in stack\n// traces, etc.), and also allows us to punt on any publicly facing\n// class-hierarchy decisions until Babel 8.\ninterface ParseErrorSpecification<ErrorDetails> {\n  // Look, these *could* be readonly, but then Flow complains when we initially\n  // set them. We could do a whole dance and make a special interface that's not\n  // readonly for when we create the error, then cast it to the readonly\n  // interface for public use, but the previous implementation didn't have them\n  // as readonly, so let's just not worry about it for now.\n  code: ParseErrorCode;\n  reasonCode: string;\n  syntaxPlugin?: SyntaxPlugin;\n  missingPlugin?: string | string[];\n  loc: Position;\n  details: ErrorDetails;\n\n  // We should consider removing this as it now just contains the same\n  // information as `loc.index`.\n  // pos: number;\n}\n\nexport type ParseError<ErrorDetails> = SyntaxError &\n  ParseErrorSpecification<ErrorDetails>;\n\n// By `ParseErrorConstructor`, we mean something like the new-less style\n// `ErrorConstructor`[1], since `ParseError`'s are not themselves actually\n// separate classes from `SyntaxError`'s.\n//\n// 1. https://github.com/microsoft/TypeScript/blob/v4.5.5/lib/lib.es5.d.ts#L1027\nexport type ParseErrorConstructor<ErrorDetails> = (a: {\n  loc: Position;\n  details: ErrorDetails;\n}) => ParseError<ErrorDetails>;\n\ntype ToMessage<ErrorDetails> = (self: ErrorDetails) => string;\n\ntype ParseErrorCredentials<ErrorDetails> = {\n  code: string;\n  reasonCode: string;\n  syntaxPlugin?: SyntaxPlugin;\n  toMessage: ToMessage<ErrorDetails>;\n};\n\nfunction defineHidden(obj: object, key: string, value: unknown) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value,\n  });\n}\n\nfunction toParseErrorConstructor<ErrorDetails extends object>({\n  toMessage,\n  ...properties\n}: ParseErrorCredentials<ErrorDetails>): ParseErrorConstructor<ErrorDetails> {\n  type ConstructorArgument = {\n    loc: Position;\n    details: ErrorDetails;\n  };\n\n  return function constructor({ loc, details }: ConstructorArgument) {\n    const error = new SyntaxError();\n    Object.assign(error, properties, { loc, pos: loc.index });\n    if (\"missingPlugin\" in details) {\n      Object.assign(error, { missingPlugin: details.missingPlugin });\n    }\n\n    type Overrides = {\n      loc?: Position;\n      details?: ErrorDetails;\n    };\n    defineHidden(error, \"clone\", function clone(overrides: Overrides = {}) {\n      const { line, column, index } = overrides.loc ?? loc;\n      return constructor({\n        loc: new Position(line, column, index),\n        details: { ...details, ...overrides.details },\n      });\n    });\n\n    defineHidden(error, \"details\", details);\n\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get(this: ParseError<ErrorDetails>): string {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value: string) {\n        Object.defineProperty(this, \"message\", { value, writable: true });\n      },\n    });\n\n    return error as ParseError<ErrorDetails>;\n  };\n}\n\ntype ParseErrorTemplate =\n  | string\n  | ToMessage<any>\n  | { message: string | ToMessage<any>; code?: ParseErrorCode };\n\nexport type ParseErrorTemplates = { [reasonCode: string]: ParseErrorTemplate };\n\n// This is the templated form of `ParseErrorEnum`.\n//\n// Note: We could factor out the return type calculation into something like\n// `ParseErrorConstructor<T extends ParseErrorTemplates>`, and then we could\n// reuse it in the non-templated form of `ParseErrorEnum`, but TypeScript\n// doesn't seem to drill down that far when showing you the computed type of\n// an object in an editor, so we'll leave it inlined for now.\nexport function ParseErrorEnum(a: TemplateStringsArray): <\n  T extends ParseErrorTemplates,\n>(\n  parseErrorTemplates: T,\n) => {\n  [K in keyof T]: ParseErrorConstructor<\n    T[K] extends { message: string | ToMessage<any> }\n      ? T[K][\"message\"] extends ToMessage<any>\n        ? Parameters<T[K][\"message\"]>[0]\n        : {}\n      : T[K] extends ToMessage<any>\n        ? Parameters<T[K]>[0]\n        : {}\n  >;\n};\n\nexport function ParseErrorEnum<T extends ParseErrorTemplates>(\n  parseErrorTemplates: T,\n  syntaxPlugin?: SyntaxPlugin,\n): {\n  [K in keyof T]: ParseErrorConstructor<\n    T[K] extends { message: string | ToMessage<any> }\n      ? T[K][\"message\"] extends ToMessage<any>\n        ? Parameters<T[K][\"message\"]>[0]\n        : {}\n      : T[K] extends ToMessage<any>\n        ? Parameters<T[K]>[0]\n        : {}\n  >;\n};\n\n// You call `ParseErrorEnum` with a mapping from `ReasonCode`'s to either:\n//\n// 1. a static error message,\n// 2. `toMessage` functions that define additional necessary `details` needed by\n//    the `ParseError`, or\n// 3. Objects that contain a `message` of one of the above and overridden `code`\n//    and/or `reasonCode`:\n//\n// ParseErrorEnum `optionalSyntaxPlugin` ({\n//   ErrorWithStaticMessage: \"message\",\n//   ErrorWithDynamicMessage: ({ type } : { type: string }) => `${type}`),\n//   ErrorWithOverriddenCodeAndOrReasonCode: {\n//     message: ({ type }: { type: string }) => `${type}`),\n//     code: \"AN_ERROR_CODE\",\n//     ...(BABEL_8_BREAKING ? { } : { reasonCode: \"CustomErrorReasonCode\" })\n//   }\n// });\n//\nexport function ParseErrorEnum(\n  argument: TemplateStringsArray | ParseErrorTemplates,\n  syntaxPlugin?: SyntaxPlugin,\n) {\n  // If the first parameter is an array, that means we were called with a tagged\n  // template literal. Extract the syntaxPlugin from this, and call again in\n  // the \"normalized\" form.\n  if (Array.isArray(argument)) {\n    return (parseErrorTemplates: ParseErrorTemplates) =>\n      ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n\n  const ParseErrorConstructors = {} as Record<\n    string,\n    ParseErrorConstructor<unknown>\n  >;\n\n  for (const reasonCode of Object.keys(argument)) {\n    const template = (argument as ParseErrorTemplates)[reasonCode];\n    const { message, ...rest } =\n      typeof template === \"string\"\n        ? { message: () => template }\n        : typeof template === \"function\"\n          ? { message: template }\n          : template;\n    const toMessage = typeof message === \"string\" ? () => message : message;\n\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage,\n      ...(syntaxPlugin ? { syntaxPlugin } : {}),\n      ...rest,\n    });\n  }\n\n  return ParseErrorConstructors;\n}\n\nexport type RaiseProperties<ErrorDetails> = {\n  at: Position | Undone<Node>;\n} & ErrorDetails;\n\nimport ModuleErrors from \"./parse-error/module-errors.ts\";\nimport StandardErrors from \"./parse-error/standard-errors.ts\";\nimport StrictModeErrors from \"./parse-error/strict-mode-errors.ts\";\nimport PipelineOperatorErrors from \"./parse-error/pipeline-operator-errors.ts\";\n\nexport const Errors = {\n  ...ParseErrorEnum(ModuleErrors),\n  ...ParseErrorEnum(StandardErrors),\n  ...ParseErrorEnum(StrictModeErrors),\n  ...ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors),\n};\n\nexport type { LValAncestor } from \"./parse-error/standard-errors.ts\";\n", "import type { TokenType } from \"../tokenizer/types.ts\";\nimport type Parser from \"../parser/index.ts\";\nimport type { ExpressionErrors } from \"../parser/util.ts\";\nimport type * as N from \"../types.ts\";\nimport type { Node as NodeType, NodeBase, File } from \"../types.ts\";\nimport type { Position } from \"../util/location.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport type { Undone } from \"../parser/node.ts\";\nimport type { BindingTypes } from \"../util/scopeflags.ts\";\n\nconst { defineProperty } = Object;\nconst toUnenumerable = (object: any, key: string) =>\n  defineProperty(object, key, { enumerable: false, value: object[key] });\n\nfunction toESTreeLocation(node: any) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n\n  return node;\n}\n\nexport default (superClass: typeof Parser) =>\n  class ESTreeParserMixin extends superClass implements Parser {\n    parse(): File {\n      const file = toESTreeLocation(super.parse());\n\n      if (this.options.tokens) {\n        file.tokens = file.tokens.map(toESTreeLocation);\n      }\n\n      return file;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseRegExpLiteral({ pattern, flags }): N.EstreeRegExpLiteral {\n      let regex: RegExp | null = null;\n      try {\n        regex = new RegExp(pattern, flags);\n      } catch (e) {\n        // In environments that don't support these flags value will\n        // be null as the regex can't be represented natively.\n      }\n      const node = this.estreeParseLiteral<N.EstreeRegExpLiteral>(regex);\n      node.regex = { pattern, flags };\n\n      return node;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseBigIntLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n      let bigInt: BigInt | null;\n      try {\n        bigInt = BigInt(value);\n      } catch {\n        bigInt = null;\n      }\n      const node = this.estreeParseLiteral<N.EstreeBigIntLiteral>(bigInt);\n      node.bigint = String(node.value || value);\n\n      return node;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseDecimalLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/experimental/decimal.md\n      // todo: use BigDecimal when node supports it.\n      const decimal: null = null;\n      const node = this.estreeParseLiteral(decimal);\n      node.decimal = String(node.value || value);\n\n      return node;\n    }\n\n    estreeParseLiteral<T extends N.Node>(value: any) {\n      // @ts-expect-error ESTree plugin changes node types\n      return this.parseLiteral<T>(value, \"Literal\");\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseStringLiteral(value: any): N.Node {\n      return this.estreeParseLiteral(value);\n    }\n\n    parseNumericLiteral(value: any): any {\n      return this.estreeParseLiteral(value);\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseNullLiteral(): N.Node {\n      return this.estreeParseLiteral(null);\n    }\n\n    parseBooleanLiteral(value: boolean): N.BooleanLiteral {\n      return this.estreeParseLiteral(value);\n    }\n\n    // Cast a Directive to an ExpressionStatement. Mutates the input Directive.\n    directiveToStmt(directive: N.Directive): N.ExpressionStatement {\n      const expression = directive.value as any as N.EstreeLiteral;\n      delete directive.value;\n\n      expression.type = \"Literal\";\n      // @ts-expect-error N.EstreeLiteral.raw is not defined.\n      expression.raw = expression.extra.raw;\n      expression.value = expression.extra.expressionValue;\n\n      const stmt = directive as any as N.ExpressionStatement;\n      stmt.type = \"ExpressionStatement\";\n      stmt.expression = expression;\n      // @ts-expect-error N.ExpressionStatement.directive is not defined\n      stmt.directive = expression.extra.rawValue;\n\n      delete expression.extra;\n\n      return stmt;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {\n      super.initFunction(node, isAsync);\n      node.expression = false;\n    }\n\n    checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n      if (node != null && this.isObjectProperty(node)) {\n        // @ts-expect-error plugin typings\n        this.checkDeclaration((node as unknown as N.EstreeProperty).value);\n      } else {\n        super.checkDeclaration(node);\n      }\n    }\n\n    getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n      return (method as any as N.EstreeProperty | N.EstreeMethodDefinition)\n        .value.params;\n    }\n\n    isValidDirective(stmt: N.Statement): boolean {\n      return (\n        stmt.type === \"ExpressionStatement\" &&\n        stmt.expression.type === \"Literal\" &&\n        typeof stmt.expression.value === \"string\" &&\n        !stmt.expression.extra?.parenthesized\n      );\n    }\n\n    parseBlockBody(\n      node: N.BlockStatementLike,\n      allowDirectives: boolean | undefined | null,\n      topLevel: boolean,\n      end: TokenType,\n      afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n    ): void {\n      super.parseBlockBody(\n        node,\n        allowDirectives,\n        topLevel,\n        end,\n        afterBlockParse,\n      );\n\n      const directiveStatements = node.directives.map(d =>\n        this.directiveToStmt(d),\n      );\n      // @ts-expect-error estree plugin typings\n      node.body = directiveStatements.concat(node.body);\n      delete node.directives;\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      );\n      if (method.typeParameters) {\n        // @ts-expect-error mutate AST types\n        method.value.typeParameters = method.typeParameters;\n        delete method.typeParameters;\n      }\n      classBody.body.push(method);\n    }\n\n    parsePrivateName(): any {\n      const node = super.parsePrivateName();\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return node;\n        }\n      }\n      return this.convertPrivateNameToPrivateIdentifier(node);\n    }\n\n    convertPrivateNameToPrivateIdentifier(\n      node: N.PrivateName,\n    ): N.EstreePrivateIdentifier {\n      const name = super.getPrivateNameSV(node);\n      node = node as any;\n      delete node.id;\n      // @ts-expect-error mutate AST types\n      node.name = name;\n      // @ts-expect-error mutate AST types\n      node.type = \"PrivateIdentifier\";\n      return node as unknown as N.EstreePrivateIdentifier;\n    }\n\n    isPrivateName(node: N.Node): boolean {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.isPrivateName(node);\n        }\n      }\n      return node.type === \"PrivateIdentifier\";\n    }\n\n    getPrivateNameSV(node: N.Node): string {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.getPrivateNameSV(node);\n        }\n      }\n      return node.name;\n    }\n\n    // @ts-expect-error plugin may override interfaces\n    parseLiteral<T extends N.Literal>(value: any, type: T[\"type\"]): T {\n      const node = super.parseLiteral<T>(value, type);\n      // @ts-expect-error mutating AST types\n      node.raw = node.extra.raw;\n      delete node.extra;\n\n      return node;\n    }\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpression?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      super.parseFunctionBody(node, allowExpression, isMethod);\n      node.expression = node.body.type !== \"BlockStatement\";\n    }\n\n    // @ts-expect-error plugin may override interfaces\n    parseMethod<\n      T extends N.ClassPrivateMethod | N.ObjectMethod | N.ClassMethod,\n    >(\n      node: Undone<T>,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: T[\"type\"],\n      inClassScope: boolean = false,\n    ): N.EstreeMethodDefinition {\n      let funcNode = this.startNode<N.MethodLike>();\n      funcNode.kind = node.kind; // provide kind, so super method correctly sets state\n      funcNode = super.parseMethod(\n        // @ts-expect-error todo(flow->ts)\n        funcNode,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      // @ts-expect-error mutate AST types\n      funcNode.type = \"FunctionExpression\";\n      delete funcNode.kind;\n      // @ts-expect-error mutate AST types\n      node.value = funcNode;\n      if (type === \"ClassPrivateMethod\") {\n        node.computed = false;\n      }\n      return this.finishNode(\n        // @ts-expect-error cast methods to estree types\n        node as Undone<N.EstreeMethodDefinition>,\n        \"MethodDefinition\",\n      );\n    }\n\n    parseClassProperty(...args: [N.ClassProperty]): any {\n      const propertyNode = super.parseClassProperty(...args) as any;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return propertyNode as N.EstreePropertyDefinition;\n        }\n      }\n      propertyNode.type = \"PropertyDefinition\";\n      return propertyNode as N.EstreePropertyDefinition;\n    }\n\n    parseClassPrivateProperty(...args: [N.ClassPrivateProperty]): any {\n      const propertyNode = super.parseClassPrivateProperty(...args) as any;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return propertyNode as N.EstreePropertyDefinition;\n        }\n      }\n      propertyNode.type = \"PropertyDefinition\";\n      propertyNode.computed = false;\n      return propertyNode as N.EstreePropertyDefinition;\n    }\n\n    parseObjectMethod(\n      prop: N.ObjectMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n    ): N.ObjectMethod | undefined | null {\n      const node: N.EstreeProperty = super.parseObjectMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) as any;\n\n      if (node) {\n        node.type = \"Property\";\n        if ((node as any as N.ClassMethod).kind === \"method\") {\n          node.kind = \"init\";\n        }\n        node.shorthand = false;\n      }\n\n      return node as any;\n    }\n\n    parseObjectProperty(\n      prop: N.ObjectProperty,\n      startLoc: Position | undefined | null,\n      isPattern: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ObjectProperty | undefined | null {\n      const node: N.EstreeProperty = super.parseObjectProperty(\n        prop,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      ) as any;\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node as any;\n    }\n\n    isValidLVal(\n      type: string,\n      isUnparenthesizedInAssign: boolean,\n      binding: BindingTypes,\n    ) {\n      return type === \"Property\"\n        ? \"value\"\n        : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node != null && this.isObjectProperty(node)) {\n        return this.isAssignable(node.value, isBinding);\n      }\n      return super.isAssignable(node, isBinding);\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (node != null && this.isObjectProperty(node)) {\n        const { key, value } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(\n            this.getPrivateNameSV(key),\n            key.loc.start,\n          );\n        }\n        this.toAssignable(value, isLHS);\n      } else {\n        super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableObjectExpressionProp(\n      prop: N.Node,\n      isLast: boolean,\n      isLHS: boolean,\n    ) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        this.raise(Errors.PatternHasAccessor, { at: prop.key });\n      } else if (prop.method) {\n        this.raise(Errors.PatternHasMethod, { at: prop.key });\n      } else {\n        super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n      }\n    }\n\n    finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n      unfinished: Undone<T>,\n      optional: boolean,\n    ): T {\n      const node = super.finishCallExpression(unfinished, optional);\n\n      if (node.callee.type === \"Import\") {\n        (node as N.Node as N.EstreeImportExpression).type = \"ImportExpression\";\n        (node as N.Node as N.EstreeImportExpression).source = node.arguments[0];\n        if (\n          this.hasPlugin(\"importAttributes\") ||\n          this.hasPlugin(\"importAssertions\")\n        ) {\n          (node as N.Node as N.EstreeImportExpression).options =\n            node.arguments[1] ?? null;\n          // compatibility with previous ESTree AST\n          (node as N.Node as N.EstreeImportExpression).attributes =\n            node.arguments[1] ?? null;\n        }\n        // arguments isn't optional in the type definition\n        delete node.arguments;\n        // callee isn't optional in the type definition\n        delete node.callee;\n      }\n\n      return node;\n    }\n\n    toReferencedArguments(\n      node:\n        | N.CallExpression\n        | N.OptionalCallExpression\n        | N.EstreeImportExpression,\n      /* isParenthesizedExpr?: boolean, */\n    ) {\n      // ImportExpressions do not have an arguments array.\n      if (node.type === \"ImportExpression\") {\n        return;\n      }\n\n      super.toReferencedArguments(node);\n    }\n\n    parseExport(\n      unfinished: Undone<N.AnyExport>,\n      decorators: N.Decorator[] | null,\n    ) {\n      const exportStartLoc = this.state.lastTokStartLoc;\n      const node = super.parseExport(unfinished, decorators);\n\n      switch (node.type) {\n        case \"ExportAllDeclaration\":\n          // @ts-expect-error mutating AST types\n          node.exported = null;\n          break;\n\n        case \"ExportNamedDeclaration\":\n          if (\n            node.specifiers.length === 1 &&\n            // @ts-expect-error mutating AST types\n            node.specifiers[0].type === \"ExportNamespaceSpecifier\"\n          ) {\n            // @ts-expect-error mutating AST types\n            node.type = \"ExportAllDeclaration\";\n            // @ts-expect-error mutating AST types\n            node.exported = node.specifiers[0].exported;\n            delete node.specifiers;\n          }\n\n        // fallthrough\n        case \"ExportDefaultDeclaration\":\n          {\n            const { declaration } = node;\n            if (\n              declaration?.type === \"ClassDeclaration\" &&\n              declaration.decorators?.length > 0 &&\n              // decorator comes before export\n              declaration.start === node.start\n            ) {\n              this.resetStartLocation(\n                node,\n                // For compatibility with ESLint's keyword-spacing rule, which assumes that an\n                // export declaration must start with export.\n                // https://github.com/babel/babel/issues/15085\n                // Here we reset export declaration's start to be the start of the export token\n                exportStartLoc,\n              );\n            }\n          }\n\n          break;\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      state: N.ParseSubscriptState,\n    ) {\n      const node = super.parseSubscript(base, startLoc, noCalls, state);\n\n      if (state.optionalChainMember) {\n        // https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n        if (\n          node.type === \"OptionalMemberExpression\" ||\n          node.type === \"OptionalCallExpression\"\n        ) {\n          node.type = node.type.substring(8); // strip Optional prefix\n        }\n        if (state.stop) {\n          const chain = this.startNodeAtNode(node);\n          chain.expression = node;\n          return this.finishNode(chain, \"ChainExpression\");\n        }\n      } else if (\n        node.type === \"MemberExpression\" ||\n        node.type === \"CallExpression\"\n      ) {\n        node.optional = false;\n      }\n\n      return node;\n    }\n\n    isOptionalMemberExpression(node: N.Node) {\n      if (node.type === \"ChainExpression\") {\n        return node.expression.type === \"MemberExpression\";\n      }\n      return super.isOptionalMemberExpression(node);\n    }\n\n    hasPropertyAsPrivateName(node: N.Node): boolean {\n      if (node.type === \"ChainExpression\") {\n        node = node.expression;\n      }\n      return super.hasPropertyAsPrivateName(node);\n    }\n\n    // @ts-expect-error override interfaces\n    isObjectProperty(node: N.Node): boolean {\n      return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n    }\n\n    isObjectMethod(node: N.Node): boolean {\n      return node.method || node.kind === \"get\" || node.kind === \"set\";\n    }\n\n    finishNodeAt<T extends NodeType>(\n      node: Undone<T>,\n      type: T[\"type\"],\n      endLoc: Position,\n    ): T {\n      return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n    }\n\n    resetStartLocation(node: N.Node, startLoc: Position) {\n      super.resetStartLocation(node, startLoc);\n      toESTreeLocation(node);\n    }\n\n    resetEndLocation(\n      node: NodeBase,\n      endLoc: Position = this.state.lastTokEndLoc,\n    ): void {\n      super.resetEndLocation(node, endLoc);\n      toESTreeLocation(node);\n    }\n  };\n", "// The token context is used in JSX plugin to track\n// jsx tag / jsx text / normal JavaScript expression\n\nexport class TokContext {\n  constructor(token: string, preserveSpace?: boolean) {\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n\n  token: string;\n  preserveSpace: boolean;\n}\n\nconst types: {\n  [key: string]: TokContext;\n} = {\n  brace: new TokContext(\"{\"), // normal JavaScript expression\n  j_oTag: new TokContext(\"<tag\"), // JSX opening tag\n  j_cTag: new TokContext(\"</tag\"), // JSX closing tag\n  j_expr: new TokContext(\"<tag>...</tag>\", true), // JSX expressions\n};\n\nif (!process.env.BABEL_8_BREAKING) {\n  types.template = new TokContext(\"`\", true);\n}\n\nexport { types };\n", "import { types as tc, type TokContext } from \"./context.ts\";\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between 1) binary\n// expression (<) and JSX Tag start (<name>); 2) object literal and JSX\n// texts. It is set on the `updateContext` function in the JSX plugin.\n\n// The `startsExpr` property is used to determine whether an expression\n// may be the \u201Cargument\u201D subexpression of a `yield` expression or\n// `yield` statement. It is set on all token types that may be at the\n// start of a subexpression.\n\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\n\ntype TokenOptions = {\n  keyword?: string;\n  beforeExpr?: boolean;\n  startsExpr?: boolean;\n  rightAssociative?: boolean;\n  isLoop?: boolean;\n  isAssign?: boolean;\n  prefix?: boolean;\n  postfix?: boolean;\n  binop?: number | null;\n};\n\n// Internally the tokenizer stores token as a number\nexport type TokenType = number;\n\n// The `ExportedTokenType` is exported via `tokTypes` and accessible\n// when `tokens: true` is enabled. Unlike internal token type, it provides\n// metadata of the tokens.\nexport class ExportedTokenType {\n  label: string;\n  keyword: string | undefined | null;\n  beforeExpr: boolean;\n  startsExpr: boolean;\n  rightAssociative: boolean;\n  isLoop: boolean;\n  isAssign: boolean;\n  prefix: boolean;\n  postfix: boolean;\n  binop: number | undefined | null;\n  // todo(Babel 8): remove updateContext from exposed token layout\n  declare updateContext:\n    | ((context: Array<TokContext>) => void)\n    | undefined\n    | null;\n\n  constructor(label: string, conf: TokenOptions = {}) {\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    if (!process.env.BABEL_8_BREAKING) {\n      this.updateContext = null;\n    }\n  }\n}\n\n// A map from keyword/keyword-like string value to the token type\nexport const keywords = new Map<string, TokenType>();\n\nfunction createKeyword(name: string, options: TokenOptions = {}): TokenType {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name: string, binop: number) {\n  return createToken(name, { beforeExpr, binop });\n}\n\nlet tokenTypeCounter = -1;\nexport const tokenTypes: ExportedTokenType[] = [];\nconst tokenLabels: string[] = [];\nconst tokenBinops: number[] = [];\nconst tokenBeforeExprs: boolean[] = [];\nconst tokenStartsExprs: boolean[] = [];\nconst tokenPrefixes: boolean[] = [];\n\nfunction createToken(name: string, options: TokenOptions = {}): TokenType {\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push(options.binop ?? -1);\n  tokenBeforeExprs.push(options.beforeExpr ?? false);\n  tokenStartsExprs.push(options.startsExpr ?? false);\n  tokenPrefixes.push(options.prefix ?? false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n\n  return tokenTypeCounter;\n}\n\nfunction createKeywordLike(\n  name: string,\n  options: TokenOptions = {},\n): TokenType {\n  ++tokenTypeCounter;\n  keywords.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push(options.binop ?? -1);\n  tokenBeforeExprs.push(options.beforeExpr ?? false);\n  tokenStartsExprs.push(options.startsExpr ?? false);\n  tokenPrefixes.push(options.prefix ?? false);\n  // In the exported token type, we set the label as \"name\" for backward compatibility with Babel 7\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n\n  return tokenTypeCounter;\n}\n\n// For performance the token type helpers depend on the following declarations order.\n// When adding new token types, please also check if the token helpers need update.\n\nexport type InternalTokenTypes = typeof tt;\n\nexport const tt = {\n  // Punctuation token types.\n  bracketL: createToken(\"[\", { beforeExpr, startsExpr }),\n  bracketHashL: createToken(\"#[\", { beforeExpr, startsExpr }),\n  bracketBarL: createToken(\"[|\", { beforeExpr, startsExpr }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", { beforeExpr, startsExpr }),\n  braceBarL: createToken(\"{|\", { beforeExpr, startsExpr }),\n  braceHashL: createToken(\"#{\", { beforeExpr, startsExpr }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", { beforeExpr, startsExpr }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", { beforeExpr }),\n  semi: createToken(\";\", { beforeExpr }),\n  colon: createToken(\":\", { beforeExpr }),\n  doubleColon: createToken(\"::\", { beforeExpr }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", { beforeExpr }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", { beforeExpr }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", { beforeExpr }),\n  backQuote: createToken(\"`\", { startsExpr }),\n  dollarBraceL: createToken(\"${\", { beforeExpr, startsExpr }),\n  // start: isTemplate\n  templateTail: createToken(\"...`\", { startsExpr }),\n  templateNonTail: createToken(\"...${\", { beforeExpr, startsExpr }),\n  // end: isTemplate\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", { startsExpr }),\n\n  // Special hashbang token.\n  interpreterDirective: createToken(\"#!...\"),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  // start: isAssign\n  eq: createToken(\"=\", { beforeExpr, isAssign }),\n  assign: createToken(\"_=\", { beforeExpr, isAssign }),\n  slashAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  // These are only needed to support % and ^ as a Hack-pipe topic token.\n  // When the proposal settles on a token, the others can be merged with\n  // tt.assign.\n  xorAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  moduloAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  // end: isAssign\n\n  incDec: createToken(\"++/--\", { prefix, postfix, startsExpr }),\n  bang: createToken(\"!\", { beforeExpr, prefix, startsExpr }),\n  tilde: createToken(\"~\", { beforeExpr, prefix, startsExpr }),\n\n  // More possible topic tokens.\n  // When the proposal settles on a token, at least one of these may be removed.\n  doubleCaret: createToken(\"^^\", { startsExpr }),\n  doubleAt: createToken(\"@@\", { startsExpr }),\n\n  // start: isBinop\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", { beforeExpr, binop: 9, prefix, startsExpr }),\n  // startsExpr: required by v8intrinsic plugin\n  modulo: createToken(\"%\", { binop: 10, startsExpr }),\n  // unset `beforeExpr` as it can be `function *`\n  star: createToken(\"*\", { binop: 10 }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true,\n  }),\n\n  // Keywords\n  // Don't forget to update packages/babel-helper-validator-identifier/src/keyword.js\n  // when new keywords are added\n  // start: isLiteralPropertyName\n  // start: isKeyword\n  _in: createKeyword(\"in\", { beforeExpr, binop: 7 }),\n  _instanceof: createKeyword(\"instanceof\", { beforeExpr, binop: 7 }),\n  // end: isBinop\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", { beforeExpr }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", { beforeExpr }),\n  _else: createKeyword(\"else\", { beforeExpr }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", { startsExpr }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", { beforeExpr }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", { beforeExpr, prefix, startsExpr }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", { beforeExpr, startsExpr }),\n  _this: createKeyword(\"this\", { startsExpr }),\n  _super: createKeyword(\"super\", { startsExpr }),\n  _class: createKeyword(\"class\", { startsExpr }),\n  _extends: createKeyword(\"extends\", { beforeExpr }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", { startsExpr }),\n  _null: createKeyword(\"null\", { startsExpr }),\n  _true: createKeyword(\"true\", { startsExpr }),\n  _false: createKeyword(\"false\", { startsExpr }),\n  _typeof: createKeyword(\"typeof\", { beforeExpr, prefix, startsExpr }),\n  _void: createKeyword(\"void\", { beforeExpr, prefix, startsExpr }),\n  _delete: createKeyword(\"delete\", { beforeExpr, prefix, startsExpr }),\n  // start: isLoop\n  _do: createKeyword(\"do\", { isLoop, beforeExpr }),\n  _for: createKeyword(\"for\", { isLoop }),\n  _while: createKeyword(\"while\", { isLoop }),\n  // end: isLoop\n  // end: isKeyword\n\n  // Primary literals\n  // start: isIdentifier\n  _as: createKeywordLike(\"as\", { startsExpr }),\n  _assert: createKeywordLike(\"assert\", { startsExpr }),\n  _async: createKeywordLike(\"async\", { startsExpr }),\n  _await: createKeywordLike(\"await\", { startsExpr }),\n  _defer: createKeywordLike(\"defer\", { startsExpr }),\n  _from: createKeywordLike(\"from\", { startsExpr }),\n  _get: createKeywordLike(\"get\", { startsExpr }),\n  _let: createKeywordLike(\"let\", { startsExpr }),\n  _meta: createKeywordLike(\"meta\", { startsExpr }),\n  _of: createKeywordLike(\"of\", { startsExpr }),\n  _sent: createKeywordLike(\"sent\", { startsExpr }),\n  _set: createKeywordLike(\"set\", { startsExpr }),\n  _source: createKeywordLike(\"source\", { startsExpr }),\n  _static: createKeywordLike(\"static\", { startsExpr }),\n  _using: createKeywordLike(\"using\", { startsExpr }),\n  _yield: createKeywordLike(\"yield\", { startsExpr }),\n\n  // Flow and TypeScript Keywordlike\n  _asserts: createKeywordLike(\"asserts\", { startsExpr }),\n  _checks: createKeywordLike(\"checks\", { startsExpr }),\n  _exports: createKeywordLike(\"exports\", { startsExpr }),\n  _global: createKeywordLike(\"global\", { startsExpr }),\n  _implements: createKeywordLike(\"implements\", { startsExpr }),\n  _intrinsic: createKeywordLike(\"intrinsic\", { startsExpr }),\n  _infer: createKeywordLike(\"infer\", { startsExpr }),\n  _is: createKeywordLike(\"is\", { startsExpr }),\n  _mixins: createKeywordLike(\"mixins\", { startsExpr }),\n  _proto: createKeywordLike(\"proto\", { startsExpr }),\n  _require: createKeywordLike(\"require\", { startsExpr }),\n  _satisfies: createKeywordLike(\"satisfies\", { startsExpr }),\n  // start: isTSTypeOperator\n  _keyof: createKeywordLike(\"keyof\", { startsExpr }),\n  _readonly: createKeywordLike(\"readonly\", { startsExpr }),\n  _unique: createKeywordLike(\"unique\", { startsExpr }),\n  // end: isTSTypeOperator\n  // start: isTSDeclarationStart\n  _abstract: createKeywordLike(\"abstract\", { startsExpr }),\n  _declare: createKeywordLike(\"declare\", { startsExpr }),\n  _enum: createKeywordLike(\"enum\", { startsExpr }),\n  _module: createKeywordLike(\"module\", { startsExpr }),\n  _namespace: createKeywordLike(\"namespace\", { startsExpr }),\n  // start: isFlowInterfaceOrTypeOrOpaque\n  _interface: createKeywordLike(\"interface\", { startsExpr }),\n  _type: createKeywordLike(\"type\", { startsExpr }),\n  // end: isTSDeclarationStart\n  _opaque: createKeywordLike(\"opaque\", { startsExpr }),\n  // end: isFlowInterfaceOrTypeOrOpaque\n  name: createToken(\"name\", { startsExpr }),\n  // end: isIdentifier\n\n  string: createToken(\"string\", { startsExpr }),\n  num: createToken(\"num\", { startsExpr }),\n  bigint: createToken(\"bigint\", { startsExpr }),\n  decimal: createToken(\"decimal\", { startsExpr }),\n  // end: isLiteralPropertyName\n  regexp: createToken(\"regexp\", { startsExpr }),\n  privateName: createToken(\"#name\", { startsExpr }),\n  eof: createToken(\"eof\"),\n\n  // jsx plugin\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", { beforeExpr: true }),\n  jsxTagStart: createToken(\"jsxTagStart\", { startsExpr: true }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n\n  // placeholder plugin\n  placeholder: createToken(\"%%\", { startsExpr: true }),\n} as const;\n\nexport function tokenIsIdentifier(token: TokenType): boolean {\n  return token >= tt._as && token <= tt.name;\n}\n\nexport function tokenKeywordOrIdentifierIsKeyword(token: TokenType): boolean {\n  // we can remove the token >= tt._in check when we\n  // know a token is either keyword or identifier\n  return token <= tt._while;\n}\n\nexport function tokenIsKeywordOrIdentifier(token: TokenType): boolean {\n  return token >= tt._in && token <= tt.name;\n}\n\nexport function tokenIsLiteralPropertyName(token: TokenType): boolean {\n  return token >= tt._in && token <= tt.decimal;\n}\n\nexport function tokenComesBeforeExpression(token: TokenType): boolean {\n  return tokenBeforeExprs[token];\n}\n\nexport function tokenCanStartExpression(token: TokenType): boolean {\n  return tokenStartsExprs[token];\n}\n\nexport function tokenIsAssignment(token: TokenType): boolean {\n  return token >= tt.eq && token <= tt.moduloAssign;\n}\n\nexport function tokenIsFlowInterfaceOrTypeOrOpaque(token: TokenType): boolean {\n  return token >= tt._interface && token <= tt._opaque;\n}\n\nexport function tokenIsLoop(token: TokenType): boolean {\n  return token >= tt._do && token <= tt._while;\n}\n\nexport function tokenIsKeyword(token: TokenType): boolean {\n  return token >= tt._in && token <= tt._while;\n}\n\nexport function tokenIsOperator(token: TokenType): boolean {\n  return token >= tt.pipeline && token <= tt._instanceof;\n}\n\nexport function tokenIsPostfix(token: TokenType): boolean {\n  return token === tt.incDec;\n}\n\nexport function tokenIsPrefix(token: TokenType): boolean {\n  return tokenPrefixes[token];\n}\n\nexport function tokenIsTSTypeOperator(token: TokenType): boolean {\n  return token >= tt._keyof && token <= tt._unique;\n}\n\nexport function tokenIsTSDeclarationStart(token: TokenType): boolean {\n  return token >= tt._abstract && token <= tt._type;\n}\n\nexport function tokenLabelName(token: TokenType): string {\n  return tokenLabels[token];\n}\n\nexport function tokenOperatorPrecedence(token: TokenType): number {\n  return tokenBinops[token];\n}\n\nexport function tokenIsBinaryOperator(token: TokenType): boolean {\n  return tokenBinops[token] !== -1;\n}\n\nexport function tokenIsRightAssociative(token: TokenType): boolean {\n  return token === tt.exponent;\n}\n\nexport function tokenIsTemplate(token: TokenType): boolean {\n  return token >= tt.templateTail && token <= tt.templateNonTail;\n}\n\nexport function getExportedToken(token: TokenType): ExportedTokenType {\n  return tokenTypes[token];\n}\n\nexport function isTokenType(obj: any): boolean {\n  return typeof obj === \"number\";\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  tokenTypes[tt.braceR].updateContext = context => {\n    context.pop();\n  };\n\n  tokenTypes[tt.braceL].updateContext =\n    tokenTypes[tt.braceHashL].updateContext =\n    tokenTypes[tt.dollarBraceL].updateContext =\n      context => {\n        context.push(tc.brace);\n      };\n\n  tokenTypes[tt.backQuote].updateContext = context => {\n    if (context[context.length - 1] === tc.template) {\n      context.pop();\n    } else {\n      context.push(tc.template);\n    }\n  };\n\n  tokenTypes[tt.jsxTagStart].updateContext = context => {\n    context.push(tc.j_expr, tc.j_oTag);\n  };\n}\n", "import * as charCodes from \"charcodes\";\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point between 0x80 and 0xffff.\n// Generated by `scripts/generate-identifier-regex.js`.\n\n/* prettier-ignore */\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n/* prettier-ignore */\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\n\nconst nonASCIIidentifierStart = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + \"]\",\n);\nconst nonASCIIidentifier = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\",\n);\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset-encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `scripts/generate-identifier-regex.js`.\n/* prettier-ignore */\nconst astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,68,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,4026,582,8634,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,757,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191];\n/* prettier-ignore */\nconst astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,81,2,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,9,5351,0,7,14,13835,9,87,9,39,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,4706,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,983,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code: number, set: readonly number[]): boolean {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\n\n// Test whether a given character code starts an identifier.\n\nexport function isIdentifierStart(code: number): boolean {\n  if (code < charCodes.uppercaseA) return code === charCodes.dollarSign;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return (\n      code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n    );\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nexport function isIdentifierChar(code: number): boolean {\n  if (code < charCodes.digit0) return code === charCodes.dollarSign;\n  if (code < charCodes.colon) return true;\n  if (code < charCodes.uppercaseA) return false;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return (\n    isInAstralSet(code, astralIdentifierStartCodes) ||\n    isInAstralSet(code, astralIdentifierCodes)\n  );\n}\n\n// Test whether a given string is a valid identifier name\n\nexport function isIdentifierName(name: string): boolean {\n  let isFirst = true;\n  for (let i = 0; i < name.length; i++) {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `name` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = name.charCodeAt(i);\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    if (isFirst) {\n      isFirst = false;\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\n", "const reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\",\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\",\n  ],\n  strictBind: [\"eval\", \"arguments\"],\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\n/**\n * Checks if word is a reserved word in non-strict mode\n */\nexport function isReservedWord(word: string, inModule: boolean): boolean {\n  return (inModule && word === \"await\") || word === \"enum\";\n}\n\n/**\n * Checks if word is a reserved word in non-binding strict mode\n *\n * Includes non-strict reserved words\n */\nexport function isStrictReservedWord(word: string, inModule: boolean): boolean {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode, but it is allowed as\n * a normal identifier.\n */\nexport function isStrictBindOnlyReservedWord(word: string): boolean {\n  return reservedWordsStrictBindSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode\n *\n * Includes non-strict reserved words and non-binding strict reserved words\n */\nexport function isStrictBindReservedWord(\n  word: string,\n  inModule: boolean,\n): boolean {\n  return (\n    isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)\n  );\n}\n\nexport function isKeyword(word: string): boolean {\n  return keywords.has(word);\n}\n", "import * as charCodes from \"charcodes\";\nimport { isIdentifierStart } from \"@babel/helper-validator-identifier\";\n\nexport {\n  isIdentifierStart,\n  isIdentifierChar,\n  isReservedWord,\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nexport const keywordRelationalOperator = /^in(stanceof)?$/;\n\n// Test whether a current state character code and next character code is @\n\nexport function isIteratorStart(\n  current: number,\n  next: number,\n  next2: number,\n): boolean {\n  return (\n    current === charCodes.atSign &&\n    next === charCodes.atSign &&\n    isIdentifierStart(next2)\n  );\n}\n\n// This is the comprehensive set of JavaScript reserved words\n// If a word is in this set, it could be a reserved word,\n// depending on sourceType/strictMode/binding info. In other words\n// if a word is not in this set, it is not a reserved word under\n// any circumstance.\nconst reservedWordLikeSet = new Set([\n  \"break\",\n  \"case\",\n  \"catch\",\n  \"continue\",\n  \"debugger\",\n  \"default\",\n  \"do\",\n  \"else\",\n  \"finally\",\n  \"for\",\n  \"function\",\n  \"if\",\n  \"return\",\n  \"switch\",\n  \"throw\",\n  \"try\",\n  \"var\",\n  \"const\",\n  \"while\",\n  \"with\",\n  \"new\",\n  \"this\",\n  \"super\",\n  \"class\",\n  \"extends\",\n  \"export\",\n  \"import\",\n  \"null\",\n  \"true\",\n  \"false\",\n  \"in\",\n  \"instanceof\",\n  \"typeof\",\n  \"void\",\n  \"delete\",\n  // strict\n  \"implements\",\n  \"interface\",\n  \"let\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"static\",\n  \"yield\",\n  // strictBind\n  \"eval\",\n  \"arguments\",\n  // reservedWorkLike\n  \"enum\",\n  \"await\",\n]);\n\nexport function canBeReservedWord(word: string): boolean {\n  return reservedWordLikeSet.has(word);\n}\n", "import { ScopeFlag, BindingFlag, type BindingTypes } from \"./scopeflags.ts\";\nimport type { Position } from \"./location.ts\";\nimport type * as N from \"../types.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport type Tokenizer from \"../tokenizer/index.ts\";\n\n// Start an AST node, attaching a start offset.\nexport class Scope {\n  declare flags: ScopeFlag;\n  // A set of var-declared names in the current lexical scope\n  var: Set<string> = new Set();\n  // A set of lexically-declared names in the current lexical scope\n  lexical: Set<string> = new Set();\n  // A set of lexically-declared FunctionDeclaration names in the current lexical scope\n  functions: Set<string> = new Set();\n\n  constructor(flags: ScopeFlag) {\n    this.flags = flags;\n  }\n}\n\n// The functions in this module keep track of declared variables in the\n// current scope in order to detect duplicate variable names.\nexport default class ScopeHandler<IScope extends Scope = Scope> {\n  parser: Tokenizer;\n  scopeStack: Array<IScope> = [];\n  inModule: boolean;\n  undefinedExports: Map<string, Position> = new Map();\n\n  constructor(parser: Tokenizer, inModule: boolean) {\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n\n  get inTopLevel() {\n    return (this.currentScope().flags & ScopeFlag.PROGRAM) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & ScopeFlag.FUNCTION) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & ScopeFlag.SUPER) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & ScopeFlag.DIRECT_SUPER) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & ScopeFlag.CLASS) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & ScopeFlag.CLASS) > 0 && (flags & ScopeFlag.FUNCTION) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & ScopeFlag.STATIC_BLOCK) {\n        return true;\n      }\n      if (flags & (ScopeFlag.VAR | ScopeFlag.CLASS)) {\n        // function body, module body, class property initializers\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & ScopeFlag.FUNCTION) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags: ScopeFlag): Scope {\n    return new Scope(flags);\n  }\n\n  enter(flags: ScopeFlag) {\n    /*:: +createScope: (flags:ScopeFlag) => IScope; */\n    // @ts-expect-error This method will be overwritten by subclasses\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit(): ScopeFlag {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  treatFunctionsAsVarInScope(scope: IScope): boolean {\n    return !!(\n      scope.flags & (ScopeFlag.FUNCTION | ScopeFlag.STATIC_BLOCK) ||\n      (!this.parser.inModule && scope.flags & ScopeFlag.PROGRAM)\n    );\n  }\n\n  declareName(name: string, bindingType: BindingTypes, loc: Position) {\n    let scope = this.currentScope();\n    if (\n      bindingType & BindingFlag.SCOPE_LEXICAL ||\n      bindingType & BindingFlag.SCOPE_FUNCTION\n    ) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n\n      if (bindingType & BindingFlag.SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n\n      if (bindingType & BindingFlag.SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BindingFlag.SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n\n        if (scope.flags & ScopeFlag.VAR) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope: IScope, name: string) {\n    if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingTypes,\n    loc: Position,\n  ) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, {\n        at: loc,\n        identifierName: name,\n      });\n    }\n  }\n\n  isRedeclaredInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (!(bindingType & BindingFlag.KIND_VALUE)) return false;\n\n    if (bindingType & BindingFlag.SCOPE_LEXICAL) {\n      return (\n        scope.lexical.has(name) ||\n        scope.functions.has(name) ||\n        scope.var.has(name)\n      );\n    }\n\n    if (bindingType & BindingFlag.SCOPE_FUNCTION) {\n      return (\n        scope.lexical.has(name) ||\n        (!this.treatFunctionsAsVarInScope(scope) && scope.var.has(name))\n      );\n    }\n\n    return (\n      (scope.lexical.has(name) &&\n        // Annex B.3.4\n        // https://tc39.es/ecma262/#sec-variablestatements-in-catch-blocks\n        !(\n          scope.flags & ScopeFlag.SIMPLE_CATCH &&\n          scope.lexical.values().next().value === name\n        )) ||\n      (!this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name))\n    );\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    const { name } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (\n      !topLevelScope.lexical.has(name) &&\n      !topLevelScope.var.has(name) &&\n      // In strict mode, scope.functions will always be empty.\n      // Modules are strict by default, but the `scriptMode` option\n      // can overwrite this behavior.\n      !topLevelScope.functions.has(name)\n    ) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n\n  currentScope(): IScope {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScopeFlags(): ScopeFlag {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & ScopeFlag.VAR) {\n        return flags;\n      }\n    }\n  }\n\n  // Could be useful for `arguments`, `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  currentThisScopeFlags(): ScopeFlag {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (\n        flags & (ScopeFlag.VAR | ScopeFlag.CLASS) &&\n        !(flags & ScopeFlag.ARROW)\n      ) {\n        return flags;\n      }\n    }\n  }\n}\n", "import type { Position } from \"../../util/location.ts\";\nimport ScopeHandler, { Scope } from \"../../util/scope.ts\";\nimport {\n  BindingFlag,\n  type ScopeFlag,\n  type BindingTypes,\n} from \"../../util/scopeflags.ts\";\nimport type * as N from \"../../types.ts\";\n\n// Reference implementation: https://github.com/facebook/flow/blob/23aeb2a2ef6eb4241ce178fde5d8f17c5f747fb5/src/typing/env.ml#L536-L584\nclass FlowScope extends Scope {\n  // declare function foo(): type;\n  declareFunctions: Set<string> = new Set();\n}\n\nexport default class FlowScopeHandler extends ScopeHandler<FlowScope> {\n  createScope(flags: ScopeFlag): FlowScope {\n    return new FlowScope(flags);\n  }\n\n  declareName(name: string, bindingType: BindingTypes, loc: Position) {\n    const scope = this.currentScope();\n    if (bindingType & BindingFlag.FLAG_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n\n    super.declareName(name, bindingType, loc);\n  }\n\n  isRedeclaredInScope(\n    scope: FlowScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n\n    if (bindingType & BindingFlag.FLAG_FLOW_DECLARE_FN) {\n      return (\n        !scope.declareFunctions.has(name) &&\n        (scope.lexical.has(name) || scope.functions.has(name))\n      );\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\n", "import type { Options } from \"../options.ts\";\nimport type State from \"../tokenizer/state.ts\";\nimport type { PluginsMap } from \"./index.ts\";\nimport type ScopeHandler from \"../util/scope.ts\";\nimport type ExpressionScopeHandler from \"../util/expression-scope.ts\";\nimport type ClassScopeHandler from \"../util/class-scope.ts\";\nimport type ProductionParameterHandler from \"../util/production-parameter.ts\";\nimport type {\n  ParserPluginWithOptions,\n  PluginConfig,\n  PluginOptions,\n} from \"../typings.ts\";\n\nexport default class BaseParser {\n  // Properties set by constructor in index.js\n  declare options: Options;\n  declare inModule: boolean;\n  declare scope: ScopeHandler<any>;\n  declare classScope: ClassScopeHandler;\n  declare prodParam: ProductionParameterHandler;\n  declare expressionScope: ExpressionScopeHandler;\n  declare plugins: PluginsMap;\n  declare filename: string | undefined | null;\n  // Names of exports store. `default` is stored as a name for both\n  // `export default foo;` and `export { foo as default };`.\n  declare exportedIdentifiers: Set<string>;\n  sawUnambiguousESM: boolean = false;\n  ambiguousScriptDifferentAst: boolean = false;\n\n  // Initialized by Tokenizer\n  declare state: State;\n  // input and length are not in state as they are constant and we do\n  // not want to ever copy them, which happens if state gets cloned\n  declare input: string;\n  declare length: number;\n\n  // This method accepts either a string (plugin name) or an array pair\n  // (plugin name and options object). If an options object is given,\n  // then each value is non-recursively checked for identity with that\n  // plugin\u2019s actual option value.\n  hasPlugin(pluginConfig: PluginConfig): boolean {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(\n        pluginOptions,\n      ) as (keyof typeof pluginOptions)[]) {\n        if (actualOptions?.[key] !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n\n  getPluginOption<\n    PluginName extends ParserPluginWithOptions[0],\n    OptionName extends keyof PluginOptions<PluginName>,\n  >(plugin: PluginName, name: OptionName) {\n    return (this.plugins.get(plugin) as null | PluginOptions<PluginName>)?.[\n      name\n    ];\n  }\n}\n", "/*:: declare var invariant; */\n\nimport BaseParser from \"./base.ts\";\nimport type { Comment, Node, Identifier } from \"../types.ts\";\nimport * as charCodes from \"charcodes\";\nimport type { Undone } from \"./node.ts\";\n\n/**\n * A whitespace token containing comments\n */\nexport type CommentWhitespace = {\n  /**\n   * the start of the whitespace token.\n   */\n  start: number;\n  /**\n   * the end of the whitespace token.\n   */\n  end: number;\n  /**\n   * the containing comments\n   */\n  comments: Array<Comment>;\n  /**\n   * the immediately preceding AST node of the whitespace token\n   */\n  leadingNode: Node | null;\n  /**\n   * the immediately following AST node of the whitespace token\n   */\n  trailingNode: Node | null;\n  /**\n   * the innermost AST node containing the whitespace with minimal size (|end - start|)\n   */\n  containingNode: Node | null;\n};\n\n/**\n * Merge comments with node's trailingComments or assign comments to be\n * trailingComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n */\nfunction setTrailingComments(node: Undone<Node>, comments: Array<Comment>) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\n\n/**\n * Merge comments with node's leadingComments or assign comments to be\n * leadingComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n */\nfunction setLeadingComments(node: Undone<Node>, comments: Array<Comment>) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\n\n/**\n * Merge comments with node's innerComments or assign comments to be\n * innerComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n */\nexport function setInnerComments(\n  node: Undone<Node>,\n  comments?: Array<Comment>,\n) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\n\n/**\n * Given node and elements array, if elements has non-null element,\n * merge comments to its trailingComments, otherwise merge comments\n * to node's innerComments\n */\nfunction adjustInnerComments(\n  node: Undone<Node>,\n  elements: Array<Node>,\n  commentWS: CommentWhitespace,\n) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\n\nexport default class CommentsParser extends BaseParser {\n  addComment(comment: Comment): void {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n\n  /**\n   * Given a newly created AST node _n_, attach _n_ to a comment whitespace _w_ if applicable\n   * {@see {@link CommentWhitespace}}\n   */\n  processComment(node: Node): void {\n    const { commentStack } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n\n    const { start: nodeStart } = node;\n    // invariant: for all 0 <= j <= i, let c = commentStack[j], c must satisfy c.end < node.end\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        // by definition of commentWhiteSpace, this implies commentWS.start > nodeStart\n        // so node can be a containingNode candidate. At this time we can finalize the comment\n        // whitespace, because\n        // 1) its leadingNode or trailingNode, if exists, will not change\n        // 2) its containingNode have been assigned and will not change because it is the\n        //    innermost minimal-sized AST node\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        // stop the loop when commentEnd <= nodeStart\n        break;\n      }\n    }\n  }\n\n  /**\n   * Assign the comments of comment whitespaces to related AST nodes.\n   * Also adjust innerComments following trailing comma.\n   */\n  finalizeComment(commentWS: CommentWhitespace) {\n    const { comments } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      /*:: invariant(commentWS.containingNode !== null) */\n      const { containingNode: node, start: commentStart } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === charCodes.comma) {\n        // If a commentWhitespace follows a comma and the containingNode allows\n        // list structures with trailing comma, merge it to the trailingComment\n        // of the last non-null list element\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default: {\n            setInnerComments(node, comments);\n          }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n\n  /**\n   * Drains remaining commentStack and applies finalizeComment\n   * to each comment whitespace. Used only in parseExpression\n   * where the top level AST node is _not_ Program\n   * {@see {@link CommentsParser#finalizeComment}}\n   */\n  finalizeRemainingComments() {\n    const { commentStack } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n\n  /* eslint-disable no-irregular-whitespace */\n  /**\n   * Reset previous node trailing comments. Used in object / class\n   * property parsing. We parse `async`, `static`, `set` and `get`\n   * as an identifier but may reinterpret it into an async/static/accessor\n   * method later. In this case the identifier is not part of the AST and we\n   * should sync the knowledge to commentStacks\n   *\n   * For example, when parsing\n   * ```\n   * async /* 1 *\u200B/ function f() {}\n   * ```\n   * the comment whitespace `/* 1 *\u200B/` has leading node Identifier(async). When\n   * we see the function token, we create a Function node and mark `/* 1 *\u200B/` as\n   * inner comments. So `/* 1 *\u200B/` should be detached from the Identifier node.\n   *\n   * @param node the last finished AST node _before_ current token\n   */\n  /* eslint-enable no-irregular-whitespace */\n  resetPreviousNodeTrailingComments(node: Node) {\n    const { commentStack } = this.state;\n    const { length } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n\n  /* eslint-disable no-irregular-whitespace */\n  /**\n   * Reset previous node leading comments, assuming that `node` is a\n   * single-token node. Used in import phase modifiers parsing. We parse\n   * `module` in `import module foo from ...` as an identifier but may\n   * reinterpret it into a phase modifier later. In this case the identifier is\n   * not part of the AST and we should sync the knowledge to commentStacks\n   *\n   * For example, when parsing\n   * ```\n   * import /* 1 *\u200B/ module a from \"a\";\n   * ```\n   * the comment whitespace `/* 1 *\u200B/` has trailing node Identifier(module). When\n   * we see that `module` is not a default import binding, we mark `/* 1 *\u200B/` as\n   * inner comments of the ImportDeclaration. So `/* 1 *\u200B/` should be detached from\n   * the Identifier node.\n   *\n   * @param node the last finished AST node _before_ current token\n   */\n  /* eslint-enable no-irregular-whitespace */\n  resetPreviousIdentifierLeadingComments(node: Identifier) {\n    const { commentStack } = this.state;\n    const { length } = commentStack;\n    if (length === 0) return;\n\n    if (commentStack[length - 1].trailingNode === node) {\n      commentStack[length - 1].trailingNode = null;\n    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {\n      commentStack[length - 2].trailingNode = null;\n    }\n  }\n\n  /**\n   * Attach a node to the comment whitespaces right before/after\n   * the given range.\n   *\n   * This is used to properly attach comments around parenthesized\n   * expressions as leading/trailing comments of the inner expression.\n   */\n  takeSurroundingComments(node: Node, start: number, end: number) {\n    const { commentStack } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\n", "import * as charCodes from \"charcodes\";\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nexport const lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nexport const lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n// https://tc39.github.io/ecma262/#sec-line-terminators\nexport function isNewLine(code: number): boolean {\n  switch (code) {\n    case charCodes.lineFeed:\n    case charCodes.carriageReturn:\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport const skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nexport const skipWhiteSpaceInLine =\n  /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\n\n// Skip whitespace and single-line comments, including /* no newline here */.\n// After this RegExp matches, its lastIndex points to a line terminator, or\n// the start of multi-line comment (which is effectively a line terminator),\n// or the end of string.\nexport const skipWhiteSpaceToLineBreak = new RegExp(\n  // Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or\n  // possessive quantifiers, so we use a trick to prevent backtracking\n  // when the look-ahead for line terminator fails.\n  \"(?=(\" +\n    // Capture the whitespace and comments that should be skipped inside\n    // a look-ahead assertion, and then re-match the group as a unit.\n    skipWhiteSpaceInLine.source +\n    \"))\\\\1\" +\n    // Look-ahead for either line terminator, start of multi-line comment,\n    // or end of string.\n    /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source,\n  \"y\", // sticky\n);\n\n// https://tc39.github.io/ecma262/#sec-white-space\nexport function isWhitespace(code: number): boolean {\n  switch (code) {\n    case 0x0009: // CHARACTER TABULATION\n    case 0x000b: // LINE TABULATION\n    case 0x000c: // FORM FEED\n    case charCodes.space:\n    case charCodes.nonBreakingSpace:\n    case charCodes.oghamSpaceMark:\n    case 0x2000: // EN QUAD\n    case 0x2001: // EM QUAD\n    case 0x2002: // EN SPACE\n    case 0x2003: // EM SPACE\n    case 0x2004: // THREE-PER-EM SPACE\n    case 0x2005: // FOUR-PER-EM SPACE\n    case 0x2006: // SIX-PER-EM SPACE\n    case 0x2007: // FIGURE SPACE\n    case 0x2008: // PUNCTUATION SPACE\n    case 0x2009: // THIN SPACE\n    case 0x200a: // HAIR SPACE\n    case 0x202f: // NARROW NO-BREAK SPACE\n    case 0x205f: // MEDIUM MATHEMATICAL SPACE\n    case 0x3000: // IDEOGRAPHIC SPACE\n    case 0xfeff: // ZERO WIDTH NO-BREAK SPACE\n      return true;\n\n    default:\n      return false;\n  }\n}\n", "import type { Options } from \"../options.ts\";\nimport type * as N from \"../types.ts\";\nimport type { CommentWhitespace } from \"../parser/comments\";\nimport { Position } from \"../util/location.ts\";\n\nimport { types as ct, type TokContext } from \"./context.ts\";\nimport { tt, type TokenType } from \"./types.ts\";\nimport type { Errors } from \"../parse-error.ts\";\nimport type { ParseError } from \"../parse-error.ts\";\n\nexport type DeferredStrictError =\n  | typeof Errors.StrictNumericEscape\n  | typeof Errors.StrictOctalLiteral;\n\ntype TopicContextState = {\n  // When a topic binding has been currently established,\n  // then this is 1. Otherwise, it is 0. This is forwards compatible\n  // with a future plugin for multiple lexical topics.\n  maxNumOfResolvableTopics: number;\n  // When a topic binding has been currently established, and if that binding\n  // has been used as a topic reference `#`, then this is 0. Otherwise, it is\n  // `null`. This is forwards compatible with a future plugin for multiple\n  // lexical topics.\n  maxTopicIndex: null | 0;\n};\n\nexport default class State {\n  strict: boolean;\n  curLine: number;\n  lineStart: number;\n\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  startLoc: Position;\n  endLoc: Position;\n\n  init({ strictMode, sourceType, startLine, startColumn }: Options): void {\n    this.strict =\n      strictMode === false\n        ? false\n        : strictMode === true\n          ? true\n          : sourceType === \"module\";\n\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n\n  errors: ParseError<any>[] = [];\n\n  // Used to signify the start of a potential arrow function\n  potentialArrowAt: number = -1;\n\n  // Used to signify the start of an expression which looks like a\n  // typed arrow function, but it isn't\n  // e.g. a ? (b) : c => d\n  //          ^\n  noArrowAt: number[] = [];\n\n  // Used to signify the start of an expression whose params, if it looks like\n  // an arrow function, shouldn't be converted to assignable nodes.\n  // This is used to defer the validation of typed arrow functions inside\n  // conditional expressions.\n  // e.g. a ? (b) : c => d\n  //          ^\n  noArrowParamsConversionAt: number[] = [];\n\n  // Flags to track\n  maybeInArrowParameters: boolean = false;\n  inType: boolean = false;\n  noAnonFunctionType: boolean = false;\n  hasFlowComment: boolean = false;\n  isAmbientContext: boolean = false;\n  inAbstractClass: boolean = false;\n  inDisallowConditionalTypesContext: boolean = false;\n\n  // For the Hack-style pipelines plugin\n  topicContext: TopicContextState = {\n    maxNumOfResolvableTopics: 0,\n    maxTopicIndex: null,\n  };\n\n  // For the F#-style pipelines plugin\n  soloAwait: boolean = false;\n  inFSharpPipelineDirectBody: boolean = false;\n\n  // Labels in scope.\n  labels: Array<{\n    kind: \"loop\" | \"switch\" | undefined | null;\n    name?: string | null;\n    statementStart?: number;\n  }> = [];\n\n  // Comment store for Program.comments\n  comments: Array<N.Comment> = [];\n\n  // Comment attachment store\n  commentStack: Array<CommentWhitespace> = [];\n\n  // The current position of the tokenizer in the input.\n  pos: number = 0;\n\n  // Properties of the current token:\n  // Its type\n  type: TokenType = tt.eof;\n\n  // For tokens that include more information than their type, the value\n  value: any = null;\n\n  // Its start and end offset\n  start: number = 0;\n  end: number = 0;\n\n  // Position information for the previous token\n  // this is initialized when generating the second token.\n  lastTokEndLoc: Position = null;\n  // this is initialized when generating the second token.\n  lastTokStartLoc: Position = null;\n  lastTokStart: number = 0;\n\n  // The context stack is used to track whether the apostrophe \"`\" starts\n  // or ends a string template\n  context: Array<TokContext> = [ct.brace];\n  // Used to track whether a JSX element is allowed to form\n  canStartJSXElement: boolean = true;\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  containsEsc: boolean = false;\n\n  // Used to track invalid escape sequences in template literals,\n  // that must be reported if the template is not tagged.\n  firstInvalidTemplateEscapePos: null | Position = null;\n\n  // This property is used to track the following errors\n  // - StrictNumericEscape\n  // - StrictOctalLiteral\n  //\n  // in a literal that occurs prior to/immediately after a \"use strict\" directive.\n\n  // todo(JLHwung): set strictErrors to null and avoid recording string errors\n  // after a non-directive is parsed\n  strictErrors: Map<number, [DeferredStrictError, Position]> = new Map();\n\n  // Tokens length in token store\n  tokensLength: number = 0;\n\n  curPosition(): Position {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n\n  clone(skipArrays?: boolean): State {\n    const state = new State();\n    const keys = Object.keys(this) as (keyof State)[];\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      // @ts-expect-error val must conform to S[key]\n      state[key] = val;\n    }\n\n    return state;\n  }\n}\n\nexport type LookaheadState = {\n  pos: number;\n  value: any;\n  type: TokenType;\n  start: number;\n  end: number;\n  context: TokContext[];\n  startLoc: Position;\n  lastTokEndLoc: Position;\n  curLine: number;\n  lineStart: number;\n  curPosition: () => Position;\n  /* Used only in readToken_mult_modulo */\n  inType: boolean;\n  // These boolean properties are not initialized in createLookaheadState()\n  // instead they will only be set by the tokenizer\n  containsEsc?: boolean;\n};\n", "import * as charCodes from \"charcodes\";\n\n// The following character codes are forbidden from being\n// an immediate sibling of NumericLiteralSeparator _\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseB,\n    charCodes.uppercaseE,\n    charCodes.uppercaseO,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseB,\n    charCodes.lowercaseE,\n    charCodes.lowercaseO,\n  ]),\n  hex: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseX,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseX,\n  ]),\n};\n\nconst isAllowedNumericSeparatorSibling = {\n  // 0 - 1\n  bin: (ch: number) => ch === charCodes.digit0 || ch === charCodes.digit1,\n\n  // 0 - 7\n  oct: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit7,\n\n  // 0 - 9\n  dec: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit9,\n\n  // 0 - 9, A - F, a - f,\n  hex: (ch: number) =>\n    (ch >= charCodes.digit0 && ch <= charCodes.digit9) ||\n    (ch >= charCodes.uppercaseA && ch <= charCodes.uppercaseF) ||\n    (ch >= charCodes.lowercaseA && ch <= charCodes.lowercaseF),\n};\n\nexport type StringContentsErrorHandlers = EscapedCharErrorHandlers & {\n  unterminated(\n    initialPos: number,\n    initialLineStart: number,\n    initialCurLine: number,\n  ): void;\n};\n\nexport function readStringContents(\n  type: \"single\" | \"double\" | \"template\",\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  errors: StringContentsErrorHandlers,\n) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const { length } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === charCodes.backslash) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        type === \"template\",\n        errors,\n      );\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = { pos, lineStart, curLine };\n      } else {\n        out += res.ch;\n      }\n      ({ pos, lineStart, curLine } = res);\n      chunkStart = pos;\n    } else if (\n      ch === charCodes.lineSeparator ||\n      ch === charCodes.paragraphSeparator\n    ) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === charCodes.lineFeed || ch === charCodes.carriageReturn) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (\n          ch === charCodes.carriageReturn &&\n          input.charCodeAt(pos) === charCodes.lineFeed\n        ) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return process.env.BABEL_8_BREAKING\n    ? { pos, str: out, firstInvalidLoc, lineStart, curLine }\n    : {\n        pos,\n        str: out,\n        firstInvalidLoc,\n        lineStart,\n        curLine,\n        containsInvalid: !!firstInvalidLoc,\n      };\n}\n\nfunction isStringEnd(\n  type: \"single\" | \"double\" | \"template\",\n  ch: number,\n  input: string,\n  pos: number,\n) {\n  if (type === \"template\") {\n    return (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign &&\n        input.charCodeAt(pos + 1) === charCodes.leftCurlyBrace)\n    );\n  }\n  return (\n    ch === (type === \"double\" ? charCodes.quotationMark : charCodes.apostrophe)\n  );\n}\n\ntype EscapedCharErrorHandlers = HexCharErrorHandlers &\n  CodePointErrorHandlers & {\n    strictNumericEscape(pos: number, lineStart: number, curLine: number): void;\n  };\n\nfunction readEscapedChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  inTemplate: boolean,\n  errors: EscapedCharErrorHandlers,\n) {\n  const throwOnInvalid = !inTemplate;\n  pos++; // skip '\\'\n\n  const res = (ch: string | null) => ({ pos, ch, lineStart, curLine });\n\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case charCodes.lowercaseN:\n      return res(\"\\n\");\n    case charCodes.lowercaseR:\n      return res(\"\\r\");\n    case charCodes.lowercaseX: {\n      let code;\n      ({ code, pos } = readHexChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        2,\n        false,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCharCode(code));\n    }\n    case charCodes.lowercaseU: {\n      let code;\n      ({ code, pos } = readCodePoint(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCodePoint(code));\n    }\n    case charCodes.lowercaseT:\n      return res(\"\\t\");\n    case charCodes.lowercaseB:\n      return res(\"\\b\");\n    case charCodes.lowercaseV:\n      return res(\"\\u000b\");\n    case charCodes.lowercaseF:\n      return res(\"\\f\");\n    case charCodes.carriageReturn:\n      if (input.charCodeAt(pos) === charCodes.lineFeed) {\n        ++pos;\n      }\n    // fall through\n    case charCodes.lineFeed:\n      lineStart = pos;\n      ++curLine;\n    // fall through\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return res(\"\");\n    case charCodes.digit8:\n    case charCodes.digit9:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    // fall through\n    default:\n      if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/)!;\n\n        let octalStr = match[0];\n\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (\n          octalStr !== \"0\" ||\n          next === charCodes.digit8 ||\n          next === charCodes.digit9\n        ) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n\n        return res(String.fromCharCode(octal));\n      }\n\n      return res(String.fromCharCode(ch));\n  }\n}\n\ntype HexCharErrorHandlers = IntErrorHandlers & {\n  invalidEscapeSequence(pos: number, lineStart: number, curLine: number): void;\n};\n\n// Used to read character escape sequences ('\\x', '\\u').\nfunction readHexChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  len: number,\n  forceLen: boolean,\n  throwOnInvalid: boolean,\n  errors: HexCharErrorHandlers,\n) {\n  const initialPos = pos;\n  let n;\n  ({ n, pos } = readInt(\n    input,\n    pos,\n    lineStart,\n    curLine,\n    16,\n    len,\n    forceLen,\n    false,\n    errors,\n    /* bailOnError */ !throwOnInvalid,\n  ));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return { code: n, pos };\n}\n\nexport type IntErrorHandlers = {\n  numericSeparatorInEscapeSequence(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  unexpectedNumericSeparator(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  // It can return \"true\" to indicate that the error was handled\n  // and the int parsing should continue.\n  invalidDigit(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n    radix: number,\n  ): boolean;\n};\n\nexport function readInt(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  radix: number,\n  len: number | undefined,\n  forceLen: boolean,\n  allowNumSeparator: boolean | \"bail\",\n  errors: IntErrorHandlers,\n  bailOnError: boolean,\n) {\n  const start = pos;\n  const forbiddenSiblings =\n    radix === 16\n      ? forbiddenNumericSeparatorSiblings.hex\n      : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling =\n    radix === 16\n      ? isAllowedNumericSeparatorSibling.hex\n      : radix === 10\n        ? isAllowedNumericSeparatorSibling.dec\n        : radix === 8\n          ? isAllowedNumericSeparatorSibling.oct\n          : isAllowedNumericSeparatorSibling.bin;\n\n  let invalid = false;\n  let total = 0;\n\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n\n    if (code === charCodes.underscore && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n\n      if (!allowNumSeparator) {\n        if (bailOnError) return { n: null, pos };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (\n        Number.isNaN(next) ||\n        !isAllowedSibling(next) ||\n        forbiddenSiblings.has(prev) ||\n        forbiddenSiblings.has(next)\n      ) {\n        if (bailOnError) return { n: null, pos };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n\n      // Ignore this _ character\n      ++pos;\n      continue;\n    }\n\n    if (code >= charCodes.lowercaseA) {\n      val = code - charCodes.lowercaseA + charCodes.lineFeed;\n    } else if (code >= charCodes.uppercaseA) {\n      val = code - charCodes.uppercaseA + charCodes.lineFeed;\n    } else if (charCodes.isDigit(code)) {\n      val = code - charCodes.digit0; // 0-9\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      // If we found a digit which is too big, errors.invalidDigit can return true to avoid\n      // breaking the loop (this is used for error recovery).\n      if (val <= 9 && bailOnError) {\n        return { n: null, pos };\n      } else if (\n        val <= 9 &&\n        errors.invalidDigit(pos, lineStart, curLine, radix)\n      ) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || (len != null && pos - start !== len) || invalid) {\n    return { n: null, pos };\n  }\n\n  return { n: total, pos };\n}\n\nexport type CodePointErrorHandlers = HexCharErrorHandlers & {\n  invalidCodePoint(pos: number, lineStart: number, curLine: number): void;\n};\n\nexport function readCodePoint(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  throwOnInvalid: boolean,\n  errors: CodePointErrorHandlers,\n) {\n  const ch = input.charCodeAt(pos);\n  let code;\n\n  if (ch === charCodes.leftCurlyBrace) {\n    ++pos;\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      input.indexOf(\"}\", pos) - pos,\n      true,\n      throwOnInvalid,\n      errors,\n    ));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return { code: null, pos };\n      }\n    }\n  } else {\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      4,\n      false,\n      throwOnInvalid,\n      errors,\n    ));\n  }\n  return { code, pos };\n}\n", "/*:: declare var invariant; */\n\nimport type { Options } from \"../options.ts\";\nimport {\n  Position,\n  SourceLocation,\n  createPositionWithColumnOffset,\n} from \"../util/location.ts\";\nimport CommentsParser, { type CommentWhitespace } from \"../parser/comments.ts\";\nimport type * as N from \"../types.ts\";\nimport * as charCodes from \"charcodes\";\nimport { isIdentifierStart, isIdentifierChar } from \"../util/identifier.ts\";\nimport {\n  tokenIsKeyword,\n  tokenLabelName,\n  tt,\n  keywords as keywordTypes,\n  type TokenType,\n} from \"./types.ts\";\nimport type { TokContext } from \"./context.ts\";\nimport {\n  Errors,\n  type ParseError,\n  type ParseErrorConstructor,\n  type RaiseProperties,\n} from \"../parse-error.ts\";\nimport {\n  lineBreakG,\n  isNewLine,\n  isWhitespace,\n  skipWhiteSpace,\n  skipWhiteSpaceInLine,\n} from \"../util/whitespace.ts\";\nimport State from \"./state.ts\";\nimport type { LookaheadState, DeferredStrictError } from \"./state.ts\";\n\nimport {\n  readInt,\n  readCodePoint,\n  readStringContents,\n  type IntErrorHandlers,\n  type CodePointErrorHandlers,\n  type StringContentsErrorHandlers,\n} from \"@babel/helper-string-parser\";\n\nimport type { Plugin } from \"../typings.ts\";\n\nfunction buildPosition(pos: number, lineStart: number, curLine: number) {\n  return new Position(curLine, pos - lineStart, pos);\n}\n\nconst VALID_REGEX_FLAGS = new Set([\n  charCodes.lowercaseG,\n  charCodes.lowercaseM,\n  charCodes.lowercaseS,\n  charCodes.lowercaseI,\n  charCodes.lowercaseY,\n  charCodes.lowercaseU,\n  charCodes.lowercaseD,\n  charCodes.lowercaseV,\n]);\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nexport class Token {\n  constructor(state: State) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n  declare type: TokenType;\n  declare value: any;\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n}\n\n// ## Tokenizer\n\nexport default abstract class Tokenizer extends CommentsParser {\n  isLookahead: boolean;\n\n  // Token store.\n  tokens: Array<Token | N.Comment> = [];\n\n  constructor(options: Options, input: string) {\n    super();\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token: Token | N.Comment) {\n    // Pop out invalid tokens trapped by try-catch parsing.\n    // Those parsing branches are mainly created by typescript and flow plugins.\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  // Move to the next token\n\n  next(): void {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type: TokenType): boolean {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Whether current token matches given type\n   */\n  match(type: TokenType): boolean {\n    return this.state.type === type;\n  }\n\n  /**\n   * Create a LookaheadState from current parser state\n   */\n  createLookaheadState(state: State): LookaheadState {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition,\n    };\n  }\n\n  /**\n   * lookahead peeks the next token, skipping changes to token context and\n   * comment stack. For performance it returns a limited LookaheadState\n   * instead of full parser state.\n   *\n   * The { column, line } Loc info is not included in lookahead since such usage\n   * is rare. Although it may return other location properties e.g. `curLine` and\n   * `lineStart`, these properties are not listed in the LookaheadState interface\n   * and thus the returned value is _NOT_ reliable.\n   *\n   * The tokenizer should make best efforts to avoid using any parser state\n   * other than those defined in LookaheadState\n   */\n  lookahead(): LookaheadState {\n    const old = this.state;\n    // @ts-expect-error For performance we use a simplified tokenizer state structure\n    this.state = this.createLookaheadState(old);\n\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart(): number {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos: number): number {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n\n  lookaheadCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  /**\n   * Similar to nextToken, but it will stop at line break when it is seen before the next token\n   *\n   * @returns {number} position of the next token start or line break, whichever is seen first.\n   * @memberof Tokenizer\n   */\n  nextTokenInLineStart(): number {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n\n  nextTokenInLineStartSince(pos: number): number {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input)\n      ? skipWhiteSpaceInLine.lastIndex\n      : pos;\n  }\n\n  /**\n   * Similar to lookaheadCharCode, but it will return the char code of line break if it is\n   * seen before the next token\n   *\n   * @returns {number} char code of the next token start or line break, whichever is seen first.\n   * @memberof Tokenizer\n   */\n  lookaheadInLineCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n\n  codePointAtPos(pos: number): number {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `input` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  setStrict(strict: boolean): void {\n    this.state.strict = strict;\n    if (strict) {\n      // Throw an error for any string decimal escape found before/immediately\n      // after a \"use strict\" directive. Strict mode will be set at parse\n      // time for any literals that occur after the next node of the strict\n      // directive.\n      this.state.strictErrors.forEach(([toParseError, at]) =>\n        this.raise(toParseError, { at }),\n      );\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext(): TokContext {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  // Read a single token, updating the parser object's token-related properties.\n  nextToken(): void {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(tt.eof);\n      return;\n    }\n\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n\n  // Skips a block comment, whose end is marked by commentEnd.\n  // *-/ is used by the Flow plugin, when parsing block comments nested\n  // inside Flow comments.\n  skipBlockComment(commentEnd: \"*/\" | \"*-/\"): N.CommentBlock | undefined {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      // We have to call this again here because startLoc may not be set...\n      // This seems to be for performance reasons:\n      // https://github.com/babel/babel/commit/acf2a10899f696a8aaf34df78bf9725b5ea7f2da\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const comment: N.CommentBlock = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + commentEnd.length,\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipLineComment(startSkip: number): N.CommentLine | undefined {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt((this.state.pos += startSkip));\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n\n    const comment: N.CommentLine = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  skipSpace(): void {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case charCodes.space:\n        case charCodes.nonBreakingSpace:\n        case charCodes.tab:\n          ++this.state.pos;\n          break;\n        case charCodes.carriageReturn:\n          if (\n            this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed\n          ) {\n            ++this.state.pos;\n          }\n        // fall through\n        case charCodes.lineFeed:\n        case charCodes.lineSeparator:\n        case charCodes.paragraphSeparator:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case charCodes.slash:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case charCodes.asterisk: {\n              const comment = this.skipBlockComment(\"*/\");\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n              break;\n            }\n\n            case charCodes.slash: {\n              const comment = this.skipLineComment(2);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n              break;\n            }\n\n            default:\n              break loop;\n          }\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (\n            ch === charCodes.dash &&\n            !this.inModule &&\n            this.options.annexB\n          ) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.dash &&\n              this.input.charCodeAt(pos + 2) === charCodes.greaterThan &&\n              (spaceStart === 0 || this.state.lineStart > spaceStart)\n            ) {\n              // A `-->` line comment\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (\n            ch === charCodes.lessThan &&\n            !this.inModule &&\n            this.options.annexB\n          ) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.exclamationMark &&\n              this.input.charCodeAt(pos + 2) === charCodes.dash &&\n              this.input.charCodeAt(pos + 3) === charCodes.dash\n            ) {\n              // `<!--`, an XML-style comment that should be interpreted as a line comment\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace: CommentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null,\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `canStartJSXElement`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  finishToken(type: TokenType, val?: any): void {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n\n  replaceToken(type: TokenType): void {\n    this.state.type = type;\n    // @ts-expect-error the prevType of updateContext is required\n    // only when the new type is tt.slash/tt.jsxTagEnd\n    this.updateContext();\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n\n  // number sign is \"#\"\n  readToken_numberSign(): void {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    if (\n      next === charCodes.leftCurlyBrace ||\n      (next === charCodes.leftSquareBracket && this.hasPlugin(\"recordAndTuple\"))\n    ) {\n      // When we see `#{`, it is likely to be a hash record.\n      // However we don't yell at `#[` since users may intend to use \"computed private fields\",\n      // which is not allowed in the spec. Throwing expecting recordAndTuple is\n      // misleading\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(\n          next === charCodes.leftCurlyBrace\n            ? Errors.RecordExpressionHashIncorrectStartSyntaxType\n            : Errors.TupleExpressionHashIncorrectStartSyntaxType,\n          { at: this.state.curPosition() },\n        );\n      }\n\n      this.state.pos += 2;\n      if (next === charCodes.leftCurlyBrace) {\n        // #{\n        this.finishToken(tt.braceHashL);\n      } else {\n        // #[\n        this.finishToken(tt.bracketHashL);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1(next));\n    } else if (next === charCodes.backslash) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1());\n    } else {\n      this.finishOp(tt.hash, 1);\n    }\n  }\n\n  readToken_dot(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (\n      next === charCodes.dot &&\n      this.input.charCodeAt(this.state.pos + 2) === charCodes.dot\n    ) {\n      this.state.pos += 3;\n      this.finishToken(tt.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.dot);\n    }\n  }\n\n  readToken_slash(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.slashAssign, 2);\n    } else {\n      this.finishOp(tt.slash, 1);\n    }\n  }\n\n  readToken_interpreter(): boolean {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== charCodes.exclamationMark) return false;\n\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n\n    this.finishToken(tt.interpreterDirective, value);\n\n    return true;\n  }\n\n  readToken_mult_modulo(code: number): void {\n    // '%' or '*'\n    let type = code === charCodes.asterisk ? tt.star : tt.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    // Exponentiation operator '**'\n    if (code === charCodes.asterisk && next === charCodes.asterisk) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = tt.exponent;\n    }\n\n    // '%=' or '*='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      width++;\n      // `tt.moduloAssign` is only needed to support % as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      type = code === charCodes.percentSign ? tt.moduloAssign : tt.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code: number): void {\n    // '||' '&&' '||=' '&&='\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n      } else {\n        this.finishOp(\n          code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,\n          2,\n        );\n      }\n      return;\n    }\n\n    if (code === charCodes.verticalBar) {\n      // '|>'\n      if (next === charCodes.greaterThan) {\n        this.finishOp(tt.pipeline, 2);\n        return;\n      }\n      // '|}'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.braceBarR);\n        return;\n      }\n\n      // '|]'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightSquareBracket\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.bracketBarR);\n        return;\n      }\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n      return;\n    }\n\n    this.finishOp(\n      code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,\n      1,\n    );\n  }\n\n  readToken_caret(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '^='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      // `tt.xorAssign` is only needed to support ^ as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      this.finishOp(tt.xorAssign, 2);\n    }\n    // '^^'\n    else if (\n      next === charCodes.caret &&\n      // If the ^^ token is not enabled, we don't throw but parse two single ^s\n      // because it could be a ^ hack token followed by a ^ binary operator.\n      this.hasPlugin([\n        \"pipelineOperator\",\n        { proposal: \"hack\", topicToken: \"^^\" },\n      ])\n    ) {\n      this.finishOp(tt.doubleCaret, 2);\n\n      // `^^^` is forbidden and must be separated by a space.\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === charCodes.caret) {\n        this.unexpected();\n      }\n    }\n    // '^'\n    else {\n      this.finishOp(tt.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_atSign(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '@@'\n    if (\n      next === charCodes.atSign &&\n      this.hasPlugin([\n        \"pipelineOperator\",\n        { proposal: \"hack\", topicToken: \"@@\" },\n      ])\n    ) {\n      this.finishOp(tt.doubleAt, 2);\n    }\n    // '@'\n    else {\n      this.finishOp(tt.at, 1);\n    }\n  }\n\n  readToken_plus_min(code: number): void {\n    // '+-'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(tt.incDec, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n    } else {\n      this.finishOp(tt.plusMin, 1);\n    }\n  }\n\n  readToken_lt(): void {\n    // '<'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.lessThan) {\n      if (this.input.charCodeAt(pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n        return;\n      }\n      this.finishOp(tt.bitShiftL, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.lt, 1);\n  }\n\n  readToken_gt(): void {\n    // '>'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.greaterThan) {\n      const size =\n        this.input.charCodeAt(pos + 2) === charCodes.greaterThan ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, size + 1);\n        return;\n      }\n      this.finishOp(tt.bitShiftR, size);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <= | >=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.gt, 1);\n  }\n\n  readToken_eq_excl(code: number): void {\n    // '=!'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(\n        tt.equality,\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo\n          ? 3\n          : 2,\n      );\n      return;\n    }\n    if (code === charCodes.equalsTo && next === charCodes.greaterThan) {\n      // '=>'\n      this.state.pos += 2;\n      this.finishToken(tt.arrow);\n      return;\n    }\n    this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n  }\n\n  readToken_question(): void {\n    // '?'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === charCodes.questionMark) {\n      if (next2 === charCodes.equalsTo) {\n        // '??='\n        this.finishOp(tt.assign, 3);\n      } else {\n        // '??'\n        this.finishOp(tt.nullishCoalescing, 2);\n      }\n    } else if (\n      next === charCodes.dot &&\n      !(next2 >= charCodes.digit0 && next2 <= charCodes.digit9)\n    ) {\n      // '.' not followed by a number\n      this.state.pos += 2;\n      this.finishToken(tt.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.question);\n    }\n  }\n\n  getTokenFromCode(code: number): void {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n\n      case charCodes.dot:\n        this.readToken_dot();\n        return;\n      // Punctuation tokens.\n      case charCodes.leftParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenL);\n        return;\n      case charCodes.rightParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenR);\n        return;\n      case charCodes.semicolon:\n        ++this.state.pos;\n        this.finishToken(tt.semi);\n        return;\n      case charCodes.comma:\n        ++this.state.pos;\n        this.finishToken(tt.comma);\n        return;\n      case charCodes.leftSquareBracket:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              Errors.TupleExpressionBarIncorrectStartSyntaxType,\n              { at: this.state.curPosition() },\n            );\n          }\n\n          // [|\n          this.state.pos += 2;\n          this.finishToken(tt.bracketBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.bracketL);\n        }\n        return;\n      case charCodes.rightSquareBracket:\n        ++this.state.pos;\n        this.finishToken(tt.bracketR);\n        return;\n      case charCodes.leftCurlyBrace:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              Errors.RecordExpressionBarIncorrectStartSyntaxType,\n              { at: this.state.curPosition() },\n            );\n          }\n\n          // {|\n          this.state.pos += 2;\n          this.finishToken(tt.braceBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.braceL);\n        }\n        return;\n      case charCodes.rightCurlyBrace:\n        ++this.state.pos;\n        this.finishToken(tt.braceR);\n        return;\n\n      case charCodes.colon:\n        if (\n          this.hasPlugin(\"functionBind\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon\n        ) {\n          this.finishOp(tt.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.colon);\n        }\n        return;\n\n      case charCodes.questionMark:\n        this.readToken_question();\n        return;\n\n      case charCodes.graveAccent:\n        this.readTemplateToken();\n        return;\n\n      case charCodes.digit0: {\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        // '0x', '0X' - hex number\n        if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {\n          this.readRadixNumber(16);\n          return;\n        }\n        // '0o', '0O' - octal number\n        if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {\n          this.readRadixNumber(8);\n          return;\n        }\n        // '0b', '0B' - binary number\n        if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {\n          this.readRadixNumber(2);\n          return;\n        }\n      }\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float. (fall through)\n      case charCodes.digit1:\n      case charCodes.digit2:\n      case charCodes.digit3:\n      case charCodes.digit4:\n      case charCodes.digit5:\n      case charCodes.digit6:\n      case charCodes.digit7:\n      case charCodes.digit8:\n      case charCodes.digit9:\n        this.readNumber(false);\n        return;\n\n      // Quotes produce strings.\n      case charCodes.quotationMark:\n      case charCodes.apostrophe:\n        this.readString(code);\n        return;\n\n      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case charCodes.slash:\n        this.readToken_slash();\n        return;\n\n      case charCodes.percentSign:\n      case charCodes.asterisk:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case charCodes.verticalBar:\n      case charCodes.ampersand:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case charCodes.caret:\n        this.readToken_caret();\n        return;\n\n      case charCodes.plusSign:\n      case charCodes.dash:\n        this.readToken_plus_min(code);\n        return;\n\n      case charCodes.lessThan:\n        this.readToken_lt();\n        return;\n\n      case charCodes.greaterThan:\n        this.readToken_gt();\n        return;\n\n      case charCodes.equalsTo:\n      case charCodes.exclamationMark:\n        this.readToken_eq_excl(code);\n        return;\n\n      case charCodes.tilde:\n        this.finishOp(tt.tilde, 1);\n        return;\n\n      case charCodes.atSign:\n        this.readToken_atSign();\n        return;\n\n      case charCodes.numberSign:\n        this.readToken_numberSign();\n        return;\n\n      case charCodes.backslash:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n\n    throw this.raise(Errors.InvalidOrUnexpectedToken, {\n      at: this.state.curPosition(),\n      unexpected: String.fromCodePoint(code),\n    });\n  }\n\n  finishOp(type: TokenType, size: number): void {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp(): void {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let { pos } = this.state;\n    for (; ; ++pos) {\n      if (pos >= this.length) {\n        // FIXME: explain\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1),\n        });\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1),\n        });\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === charCodes.leftSquareBracket) {\n          inClass = true;\n        } else if (ch === charCodes.rightSquareBracket && inClass) {\n          inClass = false;\n        } else if (ch === charCodes.slash && !inClass) {\n          break;\n        }\n        escaped = ch === charCodes.backslash;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n\n    let mods = \"\";\n\n    const nextPos = () =>\n      // (pos + 1) + 1 - start\n      createPositionWithColumnOffset(startLoc, pos + 2 - start);\n\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      // It doesn't matter if cp > 0xffff, the loop will either throw or break because we check on cp\n      const char = String.fromCharCode(cp);\n\n      // @ts-expect-error VALID_REGEX_FLAGS.has should accept expanded type: number\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === charCodes.lowercaseV) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() });\n          }\n        } else if (cp === charCodes.lowercaseU) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() });\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, { at: nextPos() });\n        }\n      } else if (isIdentifierChar(cp) || cp === charCodes.backslash) {\n        this.raise(Errors.MalformedRegExpFlags, { at: nextPos() });\n      } else {\n        break;\n      }\n\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n\n    this.finishToken(tt.regexp, {\n      pattern: content,\n      flags: mods,\n    });\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n  // When `forceLen` is `true`, it means that we already know that in case\n  // of a malformed number we have to skip `len` characters anyway, instead\n  // of bailing out early. For example, in \"\\u{123Z}\" we want to read up to }\n  // anyway, while in \"\\u00Z\" we will stop at Z instead of consuming four\n  // characters (and thus the closing quote).\n\n  readInt(\n    radix: number,\n    len?: number,\n    forceLen: boolean = false,\n    allowNumSeparator: boolean | \"bail\" = true,\n  ): number | null {\n    const { n, pos } = readInt(\n      this.input,\n      this.state.pos,\n      this.state.lineStart,\n      this.state.curLine,\n      radix,\n      len,\n      forceLen,\n      allowNumSeparator,\n      this.errorHandlers_readInt,\n      /* bailOnError */ false,\n    );\n    this.state.pos = pos;\n    return n;\n  }\n\n  readRadixNumber(radix: number): void {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n\n    this.state.pos += 2; // 0x\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, {\n        // Numeric literals can't have newlines, so this is safe to do.\n        at: createPositionWithColumnOffset(startLoc, 2),\n        radix,\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === charCodes.lowercaseN) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === charCodes.lowercaseM) {\n      throw this.raise(Errors.InvalidDecimal, { at: startLoc });\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    if (isBigInt) {\n      const str = this.input\n        .slice(startLoc.index, this.state.pos)\n        .replace(/[_n]/g, \"\");\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    this.finishToken(tt.num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  readNumber(startsWithDot: boolean): void {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, { at: this.state.curPosition() });\n    }\n    const hasLeadingZero =\n      this.state.pos - start >= 2 &&\n      this.input.charCodeAt(start) === charCodes.digit0;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, { at: startLoc });\n      if (!this.state.strict) {\n        // disallow numeric separators in non octal decimals and legacy octal likes\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          // Numeric literals can't have newlines, so this is safe to do.\n          this.raise(Errors.ZeroDigitNumericSeparator, {\n            at: createPositionWithColumnOffset(startLoc, underscorePos),\n          });\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === charCodes.dot && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (\n      (next === charCodes.uppercaseE || next === charCodes.lowercaseE) &&\n      !isOctal\n    ) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === charCodes.plusSign || next === charCodes.dash) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, { at: startLoc });\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === charCodes.lowercaseN) {\n      // disallow floats, legacy octal syntax and non octal decimals\n      // new style octal (\"0o\") is handled in this.readRadixNumber\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, { at: startLoc });\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === charCodes.lowercaseM) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, { at: startLoc });\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    // remove \"_\" for numeric literal separator, and trailing `m` or `n`\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(tt.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(tt.num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  readCodePoint(throwOnInvalid: boolean): number | null {\n    const { code, pos } = readCodePoint(\n      this.input,\n      this.state.pos,\n      this.state.lineStart,\n      this.state.curLine,\n      throwOnInvalid,\n      this.errorHandlers_readCodePoint,\n    );\n    this.state.pos = pos;\n    return code;\n  }\n\n  readString(quote: number): void {\n    const { str, pos, curLine, lineStart } = readStringContents(\n      quote === charCodes.quotationMark ? \"double\" : \"single\",\n      this.input,\n      this.state.pos + 1, // skip the quote\n      this.state.lineStart,\n      this.state.curLine,\n      this.errorHandlers_readStringContents_string,\n    );\n    this.state.pos = pos + 1; // skip the quote\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(tt.string, str);\n  }\n\n  // Reads template continuation `}...`\n  readTemplateContinuation(): void {\n    if (!this.match(tt.braceR)) {\n      this.unexpected(null, tt.braceR);\n    }\n    // rewind pos to `}`\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n\n  // Reads template string tokens.\n  readTemplateToken(): void {\n    const opening = this.input[this.state.pos];\n    const { str, firstInvalidLoc, pos, curLine, lineStart } =\n      readStringContents(\n        \"template\",\n        this.input,\n        this.state.pos + 1, // skip '`' or `}`\n        this.state.lineStart,\n        this.state.curLine,\n        this.errorHandlers_readStringContents_template,\n      );\n    this.state.pos = pos + 1; // skip '`' or `$`\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(\n        firstInvalidLoc.curLine,\n        firstInvalidLoc.pos - firstInvalidLoc.lineStart,\n        firstInvalidLoc.pos,\n      );\n    }\n\n    if (this.input.codePointAt(pos) === charCodes.graveAccent) {\n      this.finishToken(\n        tt.templateTail,\n        firstInvalidLoc ? null : opening + str + \"`\",\n      );\n    } else {\n      this.state.pos++; // skip '{'\n      this.finishToken(\n        tt.templateNonTail,\n        firstInvalidLoc ? null : opening + str + \"${\",\n      );\n    }\n  }\n\n  recordStrictModeErrors(\n    toParseError: DeferredStrictError,\n    { at }: { at: Position },\n  ) {\n    const index = at.index;\n\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, { at });\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n  //\n  // When `firstCode` is given, it assumes it is always an identifier start and\n  // will skip reading start position again\n\n  readWord1(firstCode?: number): string {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === charCodes.backslash) {\n        this.state.containsEsc = true;\n\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck =\n          this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {\n          this.raise(Errors.MissingUnicodeEscape, {\n            at: this.state.curPosition(),\n          });\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, { at: escStart });\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  readWord(firstCode?: number): void {\n    const word = this.readWord1(firstCode);\n    const type = keywordTypes.get(word);\n    if (type !== undefined) {\n      // We don't use word as state.value here because word is a dynamic string\n      // while token label is a shared constant string\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(tt.name, word);\n    }\n  }\n\n  checkKeywordEscapes(): void {\n    const { type } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.startLoc,\n        reservedWord: tokenLabelName(type),\n      });\n    }\n  }\n\n  /**\n   * Raise a `ParseError` given the appropriate properties. If passed a\n   * `Position` for the `at` property, raises the `ParseError` at that location.\n   * Otherwise, if passed a `Node`, raises the `ParseError` at the start\n   * location of that `Node`.\n   *\n   * If `errorRecovery` is `true`, the error is pushed to the errors array and\n   * returned. If `errorRecovery` is `false`, the error is instead thrown.\n   */\n  raise<ErrorDetails>(\n    toParseError: ParseErrorConstructor<ErrorDetails>,\n    raiseProperties: RaiseProperties<ErrorDetails>,\n  ): ParseError<ErrorDetails> {\n    const { at, ...details } = raiseProperties;\n    const loc = at instanceof Position ? at : at.loc.start;\n    // @ts-expect-error: refine details typing\n    const error = toParseError({ loc, details });\n\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n\n    return error;\n  }\n\n  /**\n   * If `errorRecovery` is `false`, this method behaves identically to `raise`.\n   * If `errorRecovery` is `true`, this method will first see if there is\n   * already an error stored at the same `Position`, and replaces it with the\n   * one generated here.\n   */\n  raiseOverwrite<ErrorDetails>(\n    toParseError: ParseErrorConstructor<ErrorDetails>,\n    raiseProperties: RaiseProperties<ErrorDetails>,\n  ): ParseError<ErrorDetails> | never {\n    const { at, ...details } = raiseProperties;\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        // @ts-expect-error: refine details typing\n        return (errors[i] = toParseError({ loc, details }));\n      }\n      if (error.loc.index < pos) break;\n    }\n\n    return this.raise(toParseError, raiseProperties);\n  }\n\n  // updateContext is used by the jsx plugin\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateContext(prevType: TokenType): void {}\n\n  // Raise an unexpected token error. Can take the expected token type.\n  unexpected(loc?: Position | null, type?: TokenType): void {\n    throw this.raise(Errors.UnexpectedToken, {\n      expected: type ? tokenLabelName(type) : null,\n      at: loc != null ? loc : this.state.startLoc,\n    });\n  }\n\n  expectPlugin(pluginName: Plugin, loc?: Position): true {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n\n    throw this.raise(Errors.MissingPlugin, {\n      at: loc != null ? loc : this.state.startLoc,\n      missingPlugin: [pluginName],\n    });\n  }\n\n  expectOnePlugin(pluginNames: Plugin[]): void {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, {\n        at: this.state.startLoc,\n        missingPlugin: pluginNames,\n      });\n    }\n  }\n\n  errorBuilder(error: ParseErrorConstructor<{}>) {\n    return (pos: number, lineStart: number, curLine: number) => {\n      this.raise(error, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    };\n  }\n\n  errorHandlers_readInt: IntErrorHandlers = {\n    invalidDigit: (pos, lineStart, curLine, radix) => {\n      if (!this.options.errorRecovery) return false;\n\n      this.raise(Errors.InvalidDigit, {\n        at: buildPosition(pos, lineStart, curLine),\n        radix,\n      });\n      // Continue parsing the number as if there was no invalid digit.\n      return true;\n    },\n    numericSeparatorInEscapeSequence: this.errorBuilder(\n      Errors.NumericSeparatorInEscapeSequence,\n    ),\n    unexpectedNumericSeparator: this.errorBuilder(\n      Errors.UnexpectedNumericSeparator,\n    ),\n  };\n\n  errorHandlers_readCodePoint: CodePointErrorHandlers = {\n    ...this.errorHandlers_readInt,\n    invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n    invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint),\n  };\n\n  errorHandlers_readStringContents_string: StringContentsErrorHandlers = {\n    ...this.errorHandlers_readCodePoint,\n    strictNumericEscape: (pos, lineStart, curLine) => {\n      this.recordStrictModeErrors(Errors.StrictNumericEscape, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    },\n    unterminated: (pos, lineStart, curLine) => {\n      throw this.raise(Errors.UnterminatedString, {\n        // Report the error at the string quote\n        at: buildPosition(pos - 1, lineStart, curLine),\n      });\n    },\n  };\n\n  errorHandlers_readStringContents_template: StringContentsErrorHandlers = {\n    ...this.errorHandlers_readCodePoint,\n    strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n    unterminated: (pos, lineStart, curLine) => {\n      throw this.raise(Errors.UnterminatedTemplate, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    },\n  };\n}\n", "import { ClassElementType } from \"./scopeflags.ts\";\nimport type { Position } from \"./location.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport type Tokenizer from \"../tokenizer/index.ts\";\n\nexport class ClassScope {\n  // A list of private named declared in the current class\n  privateNames: Set<string> = new Set();\n\n  // A list of private getters of setters without their counterpart\n  loneAccessors: Map<string, ClassElementType> = new Map();\n\n  // A list of private names used before being defined, mapping to\n  // their position.\n  undefinedPrivateNames: Map<string, Position> = new Map();\n}\n\nexport default class ClassScopeHandler {\n  parser: Tokenizer;\n  stack: Array<ClassScope> = [];\n  undefinedPrivateNames: Map<string, Position> = new Map();\n\n  constructor(parser: Tokenizer) {\n    this.parser = parser;\n  }\n\n  current(): ClassScope {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n\n    // Migrate the usage of not yet defined private names to the outer\n    // class scope, or raise an error if we reached the top-level scope.\n\n    const current = this.current();\n\n    // Array.from is needed because this is compiled to an array-like for loop\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n          at: loc,\n          identifierName: name,\n        });\n      }\n    }\n  }\n\n  declarePrivateName(\n    name: string,\n    elementType: ClassElementType,\n    loc: Position,\n  ) {\n    const { privateNames, loneAccessors, undefinedPrivateNames } =\n      this.current();\n    let redefined = privateNames.has(name);\n\n    if (elementType & ClassElementType.KIND_ACCESSOR) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & ClassElementType.FLAG_STATIC;\n        const newStatic = elementType & ClassElementType.FLAG_STATIC;\n\n        const oldKind = accessor & ClassElementType.KIND_ACCESSOR;\n        const newKind = elementType & ClassElementType.KIND_ACCESSOR;\n\n        // The private name can be duplicated only if it is used by\n        // two accessors with different kind (get and set), and if\n        // they have the same placement (static or not).\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, {\n        at: loc,\n        identifierName: name,\n      });\n    }\n\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name: string, loc: Position) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      // top-level\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n        at: loc,\n        identifierName: name,\n      });\n    }\n  }\n}\n", "import { Errors, type ParseErrorConstructor } from \"../parse-error.ts\";\nimport type { Position } from \"./location.ts\";\nimport type { Node } from \"../types.ts\";\nimport type Tokenizer from \"../tokenizer/index.ts\";\n\n/**\n * @module util/expression-scope\n\nExpressionScope is used to track declaration errors in these ambiguous patterns:\n\n- CoverParenthesizedExpressionAndArrowParameterList\n  e.g. we don't know if `({ x })` is an parenthesized expression or an\n  arrow function parameters until we see an `=>` after `)`.\n\n- CoverCallExpressionAndAsyncArrowHead\n  e.g. we don't know if `async({ x })` is a call expression or an async arrow\n  function parameters until we see an `=>` after `)`\n\nThe following declaration errors (@see parser-errors/standard) will be recorded in\nsome expression scopes and thrown later when we know what the ambiguous pattern is\n\n- AwaitBindingIdentifier\n- AwaitExpressionFormalParameter\n- YieldInParameter\n- InvalidParenthesizedAssignment when parenthesized is an identifier\n\nThere are four different expression scope\n- Expression\n  A general scope that represents program / function body / static block. No errors\n  will be recorded nor thrown in this scope.\n\n- MaybeArrowParameterDeclaration\n  A scope that represents ambiguous arrow head e.g. `(x)`. Errors will be recorded\n  alongside parent scopes and thrown when `ExpressionScopeHandler#validateAsPattern`\n  is called.\n\n- MaybeAsyncArrowParameterDeclaration\n  A scope that represents ambiguous async arrow head e.g. `async(x)`. Errors will\n  be recorded alongside parent scopes and thrown when\n  `ExpressionScopeHandler#validateAsPattern` is called.\n\n- ParameterDeclaration\n  A scope that represents unambiguous function parameters `function(x)`. Errors\n  recorded in this scope will be thrown immediately. No errors will be recorded in\n  this scope.\n\n// @see {@link https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M|V8 Expression Scope design docs}\n */\n\nconst enum ExpressionScopeType {\n  kExpression = 0,\n  kMaybeArrowParameterDeclaration = 1,\n  kMaybeAsyncArrowParameterDeclaration = 2,\n  kParameterDeclaration = 3,\n}\n\nclass ExpressionScope {\n  declare type: ExpressionScopeType;\n\n  constructor(type: ExpressionScopeType = ExpressionScopeType.kExpression) {\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration(): this is ArrowHeadParsingScope {\n    return (\n      this.type === ExpressionScopeType.kMaybeAsyncArrowParameterDeclaration ||\n      this.type === ExpressionScopeType.kMaybeArrowParameterDeclaration\n    );\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === ExpressionScopeType.kParameterDeclaration;\n  }\n}\n\ntype ArrowHeadParsingParameterInitializerError =\n  | typeof Errors.AwaitExpressionFormalParameter\n  | typeof Errors.YieldInParameter;\ntype ArrowHeadParsingDeclarationError =\n  | ArrowHeadParsingParameterInitializerError\n  | typeof Errors.InvalidParenthesizedAssignment\n  | typeof Errors.AwaitBindingIdentifier;\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  declarationErrors: Map<number, [ParseErrorConstructor<{}>, Position]> =\n    new Map();\n  constructor(\n    type:\n      | ExpressionScopeType.kMaybeArrowParameterDeclaration\n      | ExpressionScopeType.kMaybeAsyncArrowParameterDeclaration,\n  ) {\n    super(type);\n  }\n  recordDeclarationError(\n    ParsingErrorClass: ParseErrorConstructor<{}>,\n    {\n      at,\n    }: {\n      at: Position;\n    },\n  ) {\n    const index = at.index;\n\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index: number) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(\n    iterator: (a: [ArrowHeadParsingDeclarationError, Position]) => void,\n  ) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\n\nexport default class ExpressionScopeHandler {\n  parser: Tokenizer;\n  stack: Array<ExpressionScope> = [new ExpressionScope()];\n\n  constructor(parser: Tokenizer) {\n    this.parser = parser;\n  }\n  enter(scope: ExpressionScope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  /**\n   * Record likely parameter initializer errors\n   *\n   * When current scope is a ParameterDeclaration, the error will be thrown immediately,\n   * otherwise it will be recorded to any ancestry MaybeArrowParameterDeclaration and\n   * MaybeAsyncArrowParameterDeclaration scope until an Expression scope is seen.\n   */\n  recordParameterInitializerError(\n    toParseError: ArrowHeadParsingParameterInitializerError,\n    {\n      at: node,\n    }: {\n      at: Node;\n    },\n  ): void {\n    const origin = { at: node.loc.start };\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        /*:: invariant(scope.type == ExpressionScopeType.kExpression) */\n        // Type-Expression is the boundary where initializer error can populate to\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n\n  /**\n   * Record errors that must be thrown if the current pattern ends up being an arrow\n   * function parameter. This is used to record parenthesized identifiers, and to record\n   * \"a as T\" and \"<T> a\" type assertions when parsing typescript.\n   *\n   * A parenthesized identifier (or type assertion) in LHS can be ambiguous because the assignment\n   * can be transformed to an assignable later, but not vice versa:\n   * For example, in `([(a) = []] = []) => {}`, we think `(a) = []` is an LHS in `[(a) = []]`,\n   * an LHS within `[(a) = []] = []`. However the LHS chain is then transformed by toAssignable,\n   * and we should throw assignment `(a)`, which is only valid in LHS. Hence we record the\n   * location of parenthesized `(a)` to current scope if it is one of MaybeArrowParameterDeclaration\n   * and MaybeAsyncArrowParameterDeclaration\n   *\n   * Unlike `recordParameterInitializerError`, we don't record to ancestry scope because we\n   * validate arrow head parsing scope before exit, and then the LHS will be unambiguous:\n   * For example, in `( x = ( [(a) = []] = [] ) ) => {}`, we should not record `(a)` in `( x = ... ) =>`\n   * arrow scope because when we finish parsing `( [(a) = []] = [] )`, it is an unambiguous assignment\n   * expression and can not be cast to pattern\n   */\n  recordArrowParameterBindingError(\n    error: ParseErrorConstructor<{}>,\n    {\n      at: node,\n    }: {\n      at: Node;\n    },\n  ): void {\n    const { stack } = this;\n    const scope: ExpressionScope = stack[stack.length - 1];\n    const origin = { at: node.loc.start };\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n\n  /**\n   * Record likely async arrow parameter errors\n   *\n   * Errors will be recorded to any ancestry MaybeAsyncArrowParameterDeclaration\n   * scope until an Expression scope is seen.\n   */\n  recordAsyncArrowParametersError({ at }: { at: Position }): void {\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (\n        scope.type === ExpressionScopeType.kMaybeAsyncArrowParameterDeclaration\n      ) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, { at });\n      }\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern(): void {\n    const { stack } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, { at: loc });\n      // iterate from parent scope\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\n\nexport function newParameterDeclarationScope() {\n  return new ExpressionScope(ExpressionScopeType.kParameterDeclaration);\n}\n\nexport function newArrowHeadScope() {\n  return new ArrowHeadParsingScope(\n    ExpressionScopeType.kMaybeArrowParameterDeclaration,\n  );\n}\n\nexport function newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(\n    ExpressionScopeType.kMaybeAsyncArrowParameterDeclaration,\n  );\n}\n\nexport function newExpressionScope() {\n  return new ExpressionScope();\n}\n", "// ProductionParameterHandler is a stack fashioned production parameter tracker\n// https://tc39.es/ecma262/#sec-grammar-notation\n// The tracked parameters are defined above.\n//\n// Whenever [+Await]/[+Yield] appears in the right-hand sides of a production,\n// we must enter a new tracking stack. For example when parsing\n//\n// AsyncFunctionDeclaration [Yield, Await]:\n//   async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await]\n//     ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }\n//\n// we must follow such process:\n//\n// 1. parse async keyword\n// 2. parse function keyword\n// 3. parse bindingIdentifier <= inherit current parameters: [?Await]\n// 4. enter new stack with (PARAM_AWAIT)\n// 5. parse formal parameters <= must have [Await] parameter [+Await]\n// 6. parse function body\n// 7. exit current stack\n\nexport const enum ParamKind {\n  // Initial Parameter flags\n  PARAM = 0b0000,\n  // track [Yield] production parameter\n  PARAM_YIELD = 0b0001,\n  // track [Await] production parameter\n  PARAM_AWAIT = 0b0010,\n  // track [Return] production parameter\n  PARAM_RETURN = 0b0100,\n  // track [In] production parameter\n  PARAM_IN = 0b1000,\n}\n\n// todo(flow->ts) - check if more granular type can be used,\n//  type below is not good because things like PARAM_AWAIT|PARAM_YIELD are not included\n// export type ParamKind =\n//   | typeof PARAM\n//   | typeof PARAM_AWAIT\n//   | typeof PARAM_IN\n//   | typeof PARAM_RETURN\n//   | typeof PARAM_YIELD;\n\nexport default class ProductionParameterHandler {\n  stacks: Array<ParamKind> = [];\n  enter(flags: ParamKind) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags(): ParamKind {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait(): boolean {\n    return (this.currentFlags() & ParamKind.PARAM_AWAIT) > 0;\n  }\n\n  get hasYield(): boolean {\n    return (this.currentFlags() & ParamKind.PARAM_YIELD) > 0;\n  }\n\n  get hasReturn(): boolean {\n    return (this.currentFlags() & ParamKind.PARAM_RETURN) > 0;\n  }\n\n  get hasIn(): boolean {\n    return (this.currentFlags() & ParamKind.PARAM_IN) > 0;\n  }\n}\n\nexport function functionFlags(\n  isAsync: boolean,\n  isGenerator: boolean,\n): ParamKind {\n  return (\n    (isAsync ? ParamKind.PARAM_AWAIT : 0) |\n    (isGenerator ? ParamKind.PARAM_YIELD : 0)\n  );\n}\n", "import type { Position } from \"../util/location.ts\";\nimport {\n  tokenIsLiteralPropertyName,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types.ts\";\nimport Tokenizer from \"../tokenizer/index.ts\";\nimport type State from \"../tokenizer/state.ts\";\nimport type {\n  EstreePropertyDefinition,\n  Node,\n  ObjectProperty,\n} from \"../types.ts\";\nimport { lineBreak, skipWhiteSpaceToLineBreak } from \"../util/whitespace.ts\";\nimport { isIdentifierChar } from \"../util/identifier.ts\";\nimport ClassScopeHandler from \"../util/class-scope.ts\";\nimport ExpressionScopeHandler from \"../util/expression-scope.ts\";\nimport { ScopeFlag } from \"../util/scopeflags.ts\";\nimport ProductionParameterHandler, {\n  ParamKind,\n} from \"../util/production-parameter.ts\";\nimport {\n  Errors,\n  type ParseError,\n  type ParseErrorConstructor,\n} from \"../parse-error.ts\";\nimport type Parser from \"./index.ts\";\n\nimport type ScopeHandler from \"../util/scope.ts\";\n\ntype TryParse<Node, Error, Thrown, Aborted, FailState> = {\n  node: Node;\n  error: Error;\n  thrown: Thrown;\n  aborted: Aborted;\n  failState: FailState;\n};\n\n// ## Parser utilities\n\nexport default abstract class UtilParser extends Tokenizer {\n  // Forward-declaration: defined in parser/index.js\n  abstract getScopeHandler(): { new (...args: any): ScopeHandler };\n\n  addExtra(\n    node: Partial<Node>,\n    key: string,\n    value: any,\n    enumerable: boolean = true,\n  ): void {\n    if (!node) return;\n\n    const extra = (node.extra = node.extra || {});\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, { enumerable, value });\n    }\n  }\n\n  // Tests whether parsed token is a contextual keyword.\n\n  isContextual(token: TokenType): boolean {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart: number, name: string): boolean {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(\n        isIdentifierChar(nextCh) ||\n        // check if `nextCh is between 0xd800 - 0xdbff,\n        // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function\n        // returns true\n        (nextCh & 0xfc00) === 0xd800\n      );\n    }\n    return false;\n  }\n\n  isLookaheadContextual(name: string): boolean {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  // Consumes contextual keyword if possible.\n\n  eatContextual(token: TokenType): boolean {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  // Asserts that following token is given contextual keyword.\n\n  expectContextual(\n    token: TokenType,\n    toParseError?: ParseErrorConstructor<any>,\n  ): void {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, { at: this.state.startLoc });\n      }\n      this.unexpected(null, token);\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  canInsertSemicolon(): boolean {\n    return (\n      this.match(tt.eof) ||\n      this.match(tt.braceR) ||\n      this.hasPrecedingLineBreak()\n    );\n  }\n\n  hasPrecedingLineBreak(): boolean {\n    return lineBreak.test(\n      this.input.slice(this.state.lastTokEndLoc.index, this.state.start),\n    );\n  }\n\n  hasFollowingLineBreak(): boolean {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n\n  isLineTerminator(): boolean {\n    return this.eat(tt.semi) || this.canInsertSemicolon();\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  semicolon(allowAsi: boolean = true): void {\n    if (allowAsi ? this.isLineTerminator() : this.eat(tt.semi)) return;\n    this.raise(Errors.MissingSemicolon, { at: this.state.lastTokEndLoc });\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error at given pos.\n\n  expect(type: TokenType, loc?: Position | null): void {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n\n  // tryParse will clone parser state.\n  // It is expensive and should be used with cautions\n  tryParse<T extends Node | ReadonlyArray<Node>>(\n    fn: (abort: (node?: T) => never) => T,\n    oldState: State = this.state.clone(),\n  ):\n    | TryParse<T, null, false, false, null>\n    | TryParse<T | null, ParseError<any>, boolean, false, State>\n    | TryParse<T | null, null, false, true, State> {\n    const abortSignal: {\n      node: T | null;\n    } = { node: null };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        // tokensLength should be preserved during error recovery mode\n        // since the parser does not halt and will instead parse the\n        // remaining tokens\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState,\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null,\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        // @ts-expect-error casting general syntax error to parse error\n        return { node: null, error, thrown: true, aborted: false, failState };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState,\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(\n    refExpressionErrors: ExpressionErrors | undefined | null,\n    andThrow: boolean,\n  ) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc,\n    } = refExpressionErrors;\n\n    const hasErrors =\n      !!shorthandAssignLoc ||\n      !!doubleProtoLoc ||\n      !!optionalParametersLoc ||\n      !!privateKeyLoc;\n\n    if (!andThrow) {\n      return hasErrors;\n    }\n\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, {\n        at: shorthandAssignLoc,\n      });\n    }\n\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, { at: doubleProtoLoc });\n    }\n\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, { at: privateKeyLoc });\n    }\n\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n\n  /**\n   * Test if current token is a literal property name\n   * https://tc39.es/ecma262/#prod-LiteralPropertyName\n   * LiteralPropertyName:\n   *   IdentifierName\n   *   StringLiteral\n   *   NumericLiteral\n   *   BigIntLiteral\n   */\n  isLiteralPropertyName(): boolean {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  /**\n   * Test if given node is a PrivateName\n   * will be overridden in ESTree plugin\n   */\n  isPrivateName(node: Node): boolean {\n    return node.type === \"PrivateName\";\n  }\n\n  /**\n   * Return the string value of a given private name\n   * WITHOUT `#`\n   * @see {@link https://tc39.es/ecma262/#sec-static-semantics-stringvalue}\n   */\n  getPrivateNameSV(node: Node): string {\n    return node.id.name;\n  }\n\n  /**\n   * Return whether the given node is a member/optional chain that\n   * contains a private name as its property\n   * It is overridden in ESTree plugin\n   */\n  hasPropertyAsPrivateName(node: Node): boolean {\n    return (\n      (node.type === \"MemberExpression\" ||\n        node.type === \"OptionalMemberExpression\") &&\n      this.isPrivateName(node.property)\n    );\n  }\n\n  isObjectProperty(\n    node: Node,\n  ): node is ObjectProperty | EstreePropertyDefinition {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node: Node): boolean {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(\n    this: Parser,\n    inModule: boolean = this.options.sourceType === \"module\",\n  ): () => void {\n    // Initialize state\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n\n    // initialize scopes\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n\n    return () => {\n      // Revert state\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n\n      // Revert scopes\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = ParamKind.PARAM;\n    if (this.inModule) {\n      paramFlags |= ParamKind.PARAM_AWAIT;\n    }\n    this.scope.enter(ScopeFlag.PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n\n  checkDestructuringPrivate(refExpressionErrors: ExpressionErrors) {\n    const { privateKeyLoc } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\n\n/**\n * The ExpressionErrors is a context struct used to track ambiguous patterns\n * When we are sure the parsed pattern is a RHS, which means it is not a pattern,\n * we will throw on this position on invalid assign syntax, otherwise it will be reset to -1\n *\n * Types of ExpressionErrors:\n *\n * - **shorthandAssignLoc**: track initializer `=` position\n * - **doubleProtoLoc**: track the duplicate `__proto__` key position\n * - **privateKey**: track private key `#p` position\n * - **optionalParametersLoc**: track the optional parameter (`?`).\n * It's only used by typescript and flow plugins\n */\nexport class ExpressionErrors {\n  shorthandAssignLoc: Position | undefined | null = null;\n  doubleProtoLoc: Position | undefined | null = null;\n  privateKeyLoc: Position | undefined | null = null;\n  optionalParametersLoc: Position | undefined | null = null;\n}\n", "import type Parser from \"./index.ts\";\nimport UtilParser from \"./util.ts\";\nimport { SourceLocation, type Position } from \"../util/location.ts\";\nimport type { Comment, Node as NodeType, NodeBase } from \"../types.ts\";\n\n// Start an AST node, attaching a start offset.\n\nclass Node implements NodeBase {\n  constructor(parser: Parser, pos: number, loc: Position) {\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser?.options.ranges) this.range = [pos, 0];\n    if (parser?.filename) this.loc.filename = parser.filename;\n  }\n\n  type: string = \"\";\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n  declare range: [number, number];\n  declare leadingComments: Array<Comment>;\n  declare trailingComments: Array<Comment>;\n  declare innerComments: Array<Comment>;\n  declare extra: {\n    [key: string]: any;\n  };\n}\nconst NodePrototype = Node.prototype;\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-expect-error __clone is not defined in Node prototype\n  NodePrototype.__clone = function (): Node {\n    const newNode = new Node(undefined, this.start, this.loc.start);\n    const keys = Object.keys(this) as (keyof Node)[];\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      // Do not clone comments that are already attached to the node\n      if (\n        key !== \"leadingComments\" &&\n        key !== \"trailingComments\" &&\n        key !== \"innerComments\"\n      ) {\n        // @ts-expect-error cloning this to newNode\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  };\n}\n\nfunction clonePlaceholder(node: any): any {\n  return cloneIdentifier(node);\n}\n\nexport function cloneIdentifier(node: any): any {\n  // We don't need to clone `typeAnnotations` and `optional`: because\n  // cloneIdentifier is only used in object shorthand and named import/export.\n  // Neither of them allow type annotations after the identifier or optional identifier\n  const { type, start, end, loc, range, extra, name } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\n\nexport function cloneStringLiteral(node: any): any {\n  const { type, start, end, loc, range, extra } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== undefined) {\n    // estree set node.raw instead of node.extra\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\n\nexport type Undone<T extends NodeType> = Omit<T, \"type\">;\n\nexport abstract class NodeUtils extends UtilParser {\n  startNode<T extends NodeType>(): Undone<T> {\n    // @ts-expect-error cast Node as Undone<T>\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt<T extends NodeType>(loc: Position): Undone<T> {\n    // @ts-expect-error cast Node as Undone<T>\n    return new Node(this, loc.index, loc);\n  }\n\n  /** Start a new node with a previous node's location. */\n  startNodeAtNode<T extends NodeType>(type: Undone<NodeType>): Undone<T> {\n    return this.startNodeAt(type.loc.start);\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  finishNode<T extends NodeType>(node: Undone<T>, type: T[\"type\"]): T {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n\n  // Finish node at given position\n\n  finishNodeAt<T extends NodeType>(\n    node: Omit<T, \"type\">,\n    type: T[\"type\"],\n    endLoc: Position,\n  ): T {\n    if (process.env.NODE_ENV !== \"production\" && node.end > 0) {\n      throw new Error(\n        \"Do not call finishNode*() twice on the same node.\" +\n          \" Instead use resetEndLocation() or change type directly.\",\n      );\n    }\n    // @ts-expect-error migrate to Babel types AST typings\n    node.type = type;\n    // @ts-expect-error migrate to Babel types AST typings\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node as T);\n    return node as T;\n  }\n\n  resetStartLocation(node: NodeBase, startLoc: Position): void {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = startLoc.index;\n  }\n\n  resetEndLocation(\n    node: NodeBase,\n    endLoc: Position = this.state.lastTokEndLoc,\n  ): void {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n\n  /**\n   * Reset the start location of node to the start location of locationNode\n   */\n  resetStartLocationFromNode(node: NodeBase, locationNode: NodeBase): void {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\n", "/*:: declare var invariant; */\n\nimport type Parser from \"../../parser/index.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeyword,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLiteralPropertyName,\n  tokenLabelName,\n  tt,\n  type TokenType,\n  tokenIsFlowInterfaceOrTypeOrOpaque,\n} from \"../../tokenizer/types.ts\";\nimport type * as N from \"../../types.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport * as charCodes from \"charcodes\";\nimport { isIteratorStart } from \"../../util/identifier.ts\";\nimport FlowScopeHandler from \"./scope.ts\";\nimport {\n  BindingFlag,\n  ScopeFlag,\n  type BindingTypes,\n} from \"../../util/scopeflags.ts\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport type { ParseStatementFlag } from \"../../parser/statement.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node.ts\";\n\nconst reservedTypes = new Set([\n  \"_\",\n  \"any\",\n  \"bool\",\n  \"boolean\",\n  \"empty\",\n  \"extends\",\n  \"false\",\n  \"interface\",\n  \"mixed\",\n  \"null\",\n  \"number\",\n  \"static\",\n  \"string\",\n  \"true\",\n  \"typeof\",\n  \"void\",\n]);\n\n/* eslint sort-keys: \"error\" */\n// The Errors key follows https://github.com/facebook/flow/blob/master/src/parser/parse_error.ml unless it does not exist\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow:\n    \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind:\n    \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  // TODO: When we get proper string enums in typescript make this ReservedType.\n  // Not really worth it to do the whole $Values dance with reservedTypes set.\n  AssignReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement:\n    \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer:\n    \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports:\n    \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({ enumName }: { enumName: string }) =>\n    `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName,\n  }: {\n    invalidEnumType: string;\n    enumName: string;\n  }) =>\n    `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n\n  // TODO: When moving to typescript, we should either have each of the\n  // following errors only accept the specific strings they want:\n  //\n  // ...PrimaryType: explicitType: \"string\" | \"number\" | \"boolean\"\n  // ...SymbolType: explicitType: \"symbol\"\n  // ...UnknownType: explicitType: null\n  //\n  // Or, alternatively, merge these three errors together into one\n  // `EnumInvalidMemberInitializer` error that can accept `EnumExplicitType`\n  // without alteration, and then just have its message change based on the\n  // explicitType.\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion,\n  }: {\n    enumName: string;\n    memberName: string;\n    suggestion: string;\n  }) =>\n    `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n  }) =>\n    `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType:\n    \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport:\n    \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact:\n    \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject:\n    \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule:\n    \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault:\n    \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule:\n    \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: {\n    message:\n      \"A binding pattern parameter cannot be optional in an implementation signature.\",\n    // For consistency in TypeScript and Flow error codes\n    ...(!process.env.BABEL_8_BREAKING\n      ? { reasonCode: \"OptionalBindingPattern\" }\n      : {}),\n  },\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired:\n    \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor:\n    \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst:\n    \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern:\n    \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject:\n    \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore:\n    \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks:\n    \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType:\n    \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand:\n    'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter:\n    \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction:\n    \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion,\n  }: {\n    unsupportedExportKind: string;\n    suggestion: string;\n  }) =>\n    `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule:\n    \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\",\n});\n/* eslint-disable sort-keys */\n\nfunction isEsModuleType(bodyElement: N.Node): boolean {\n  return (\n    bodyElement.type === \"DeclareExportAllDeclaration\" ||\n    (bodyElement.type === \"DeclareExportDeclaration\" &&\n      (!bodyElement.declaration ||\n        (bodyElement.declaration.type !== \"TypeAlias\" &&\n          bodyElement.declaration.type !== \"InterfaceDeclaration\")))\n  );\n}\n\nfunction hasTypeImportKind(node: N.Node): boolean {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\",\n};\n\n// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\nfunction partition<T>(\n  list: T[],\n  test: (c: T, b: number, a: T[]) => boolean | undefined | null,\n): [T[], T[]] {\n  const list1: T[] = [];\n  const list2: T[] = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\n\n// Flow enums types\ntype EnumExplicitType = null | \"boolean\" | \"number\" | \"string\" | \"symbol\";\n\ntype EnumContext = {\n  enumName: string;\n  explicitType: EnumExplicitType;\n  memberName: string;\n};\n\ntype EnumMemberInit =\n  | {\n      type: \"number\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"string\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"boolean\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"invalid\";\n      loc: Position;\n    }\n  | {\n      type: \"none\";\n      loc: Position;\n    };\n\nexport default (superClass: typeof Parser) =>\n  class FlowParserMixin extends superClass implements Parser {\n    // The value of the @flow/@noflow pragma. Initially undefined, transitions\n    // to \"@flow\" or \"@noflow\" if we see a pragma. Transitions to null if we are\n    // past the initial comment.\n    flowPragma: void | null | \"flow\" | \"noflow\" = undefined;\n\n    getScopeHandler(): {\n      new (...args: any): FlowScopeHandler;\n    } {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes(): boolean {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums(): boolean {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type: TokenType, val: any): void {\n      if (\n        type !== tt.string &&\n        type !== tt.semi &&\n        type !== tt.interpreterDirective\n      ) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n      super.finishToken(type, val);\n    }\n\n    addComment(comment: N.Comment): void {\n      if (this.flowPragma === undefined) {\n        // Try to parse a flow pragma.\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n        if (!matches) {\n          // do nothing\n        } else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n      super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || tt.colon);\n\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate(): N.FlowPredicate {\n      const node = this.startNode();\n      const moduloLoc = this.state.startLoc;\n      this.next(); // eat `%`\n      this.expectContextual(tt._checks);\n      // Force '%' and 'checks' to be adjacent\n      if (this.state.lastTokStart > moduloLoc.index + 1) {\n        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {\n          at: moduloLoc,\n        });\n      }\n      if (this.eat(tt.parenL)) {\n        node.value = super.parseExpression();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser(): [\n      N.FlowType | undefined | null,\n      N.FlowPredicate | undefined | null,\n    ] {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tt.colon);\n      let type = null;\n      let predicate = null;\n      if (this.match(tt.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n        if (this.match(tt.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(\n      node: Undone<N.FlowDeclareClass>,\n    ): N.FlowDeclareClass {\n      this.next();\n      this.flowParseInterfaceish(node, /*isClass*/ true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(\n      node: Undone<N.FlowDeclareFunction>,\n    ): N.FlowDeclareFunction {\n      this.next();\n\n      const id = (node.id = this.parseIdentifier());\n\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode<N.TypeAnnotation>();\n\n      if (this.match(tt.lt)) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(tt.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      typeNode.this = tmp._this;\n      this.expect(tt.parenR);\n\n      [typeNode.returnType, node.predicate] =\n        this.flowParseTypeAndPredicateInitialiser();\n\n      typeContainer.typeAnnotation = this.finishNode(\n        typeNode,\n        \"FunctionTypeAnnotation\",\n      );\n\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n      this.resetEndLocation(id);\n      this.semicolon();\n\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_FLOW_DECLARE_FN,\n        node.id.loc.start,\n      );\n\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(\n      node: Undone<N.FlowDeclare>,\n      insideModule?: boolean,\n    ): N.FlowDeclare {\n      if (this.match(tt._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(tt._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(tt._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(tt._module)) {\n        if (this.match(tt.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(FlowErrors.NestedDeclareModule, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(tt._type)) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(tt._opaque)) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(tt._interface)) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(tt._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(\n      node: Undone<N.FlowDeclareVariable>,\n    ): N.FlowDeclareVariable {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(\n        /*allowPrimitiveOverride*/ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_VAR,\n        node.id.loc.start,\n      );\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(\n      node: Undone<N.FlowDeclareModule>,\n    ): N.FlowDeclareModule {\n      this.scope.enter(ScopeFlag.OTHER);\n\n      if (this.match(tt.string)) {\n        node.id = super.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = (node.body = this.startNode());\n      // @ts-expect-error refine typings\n      const body = (bodyNode.body = []);\n      this.expect(tt.braceL);\n      while (!this.match(tt.braceR)) {\n        let bodyNode = this.startNode<N.ImportDeclaration>();\n\n        if (this.match(tt._import)) {\n          this.next();\n          if (!this.isContextual(tt._type) && !this.match(tt._typeof)) {\n            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          super.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\n            tt._declare,\n            FlowErrors.UnsupportedStatementInDeclareModule,\n          );\n          // @ts-expect-error refine typings\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n\n      this.expect(tt.braceR);\n\n      this.finishNode(bodyNode, \"BlockStatement\");\n\n      let kind: \"CommonJS\" | \"ES\" | null = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n              at: bodyElement,\n            });\n          }\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(FlowErrors.DuplicateDeclareModuleExports, {\n              at: bodyElement,\n            });\n          }\n          if (kind === \"ES\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n              at: bodyElement,\n            });\n          }\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(\n      node: Undone<N.FlowDeclareExportDeclaration>,\n      insideModule?: boolean | null,\n    ): N.FlowDeclareExportDeclaration {\n      this.expect(tt._export);\n\n      if (this.eat(tt._default)) {\n        if (this.match(tt._function) || this.match(tt._class)) {\n          // declare export default class ...\n          // declare export default function ...\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          // declare export default [type];\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n        node.default = true;\n\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (\n          this.match(tt._const) ||\n          this.isLet() ||\n          ((this.isContextual(tt._type) || this.isContextual(tt._interface)) &&\n            !insideModule)\n        ) {\n          const label = this.state.value as\n            | \"const\"\n            | \"let\"\n            | \"type\"\n            | \"interface\";\n          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {\n            at: this.state.startLoc,\n            unsupportedExportKind: label,\n            suggestion: exportSuggestions[label],\n          });\n        }\n\n        if (\n          this.match(tt._var) || // declare export var ...\n          this.match(tt._function) || // declare export function ...\n          this.match(tt._class) || // declare export class ...\n          this.isContextual(tt._opaque) // declare export opaque ..\n        ) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (\n          this.match(tt.star) || // declare export * from ''\n          this.match(tt.braceL) || // declare export {} ...\n          this.isContextual(tt._interface) || // declare export interface ...\n          this.isContextual(tt._type) || // declare export type ...\n          this.isContextual(tt._opaque) // declare export opaque type ...\n        ) {\n          node = this.parseExport(\n            node as Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n            /* decorators */ null,\n          );\n          if (node.type === \"ExportNamedDeclaration\") {\n            node.type = \"ExportDeclaration\";\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          node.type = \"Declare\" + node.type;\n\n          return node as N.Node;\n        }\n      }\n\n      this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(\n      node: Undone<N.FlowDeclareModuleExports>,\n    ): N.FlowDeclareModuleExports {\n      this.next();\n      this.expectContextual(tt._exports);\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(\n      node: Undone<N.FlowDeclareTypeAlias>,\n    ): N.FlowDeclareTypeAlias {\n      this.next();\n      const finished = this.flowParseTypeAlias(node);\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareTypeAlias\";\n      return finished;\n    }\n\n    flowParseDeclareOpaqueType(\n      node: Undone<N.FlowDeclareOpaqueType>,\n    ): N.FlowDeclareOpaqueType {\n      this.next();\n      const finished = this.flowParseOpaqueType(node, true);\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareOpaqueType\";\n      return finished;\n    }\n\n    flowParseDeclareInterface(\n      node: Undone<N.FlowDeclareInterface>,\n    ): N.FlowDeclareInterface {\n      this.next();\n      this.flowParseInterfaceish(node, /* isClass */ false);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    // Interfaces\n\n    flowParseInterfaceish(node: Undone<N.FlowDeclare>, isClass: boolean): void {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ !isClass,\n        /* declaration */ true,\n      );\n\n      this.scope.declareName(\n        node.id.name,\n        isClass ? BindingFlag.TYPE_FUNCTION : BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(tt.comma));\n      }\n\n      if (isClass) {\n        node.implements = [];\n        node.mixins = [];\n\n        if (this.eatContextual(tt._mixins)) {\n          do {\n            node.mixins.push(this.flowParseInterfaceExtends());\n          } while (this.eat(tt.comma));\n        }\n\n        if (this.eatContextual(tt._implements)) {\n          do {\n            node.implements.push(this.flowParseInterfaceExtends());\n          } while (this.eat(tt.comma));\n        }\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false,\n      });\n    }\n\n    flowParseInterfaceExtends(): N.FlowInterfaceExtends {\n      const node = this.startNode();\n\n      node.id = this.flowParseQualifiedTypeIdentifier();\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node: Undone<N.FlowInterface>): N.FlowInterface {\n      this.flowParseInterfaceish(node, /* isClass */ false);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word: string) {\n      if (word === \"_\") {\n        this.raise(FlowErrors.UnexpectedReservedUnderscore, {\n          at: this.state.startLoc,\n        });\n      }\n    }\n\n    checkReservedType(word: string, startLoc: Position, declaration?: boolean) {\n      if (!reservedTypes.has(word)) return;\n\n      this.raise(\n        declaration\n          ? FlowErrors.AssignReservedType\n          : FlowErrors.UnexpectedReservedType,\n        {\n          at: startLoc,\n          reservedType: word,\n        },\n      );\n    }\n\n    flowParseRestrictedIdentifier(\n      liberal?: boolean,\n      declaration?: boolean,\n    ): N.Identifier {\n      this.checkReservedType(\n        this.state.value,\n        this.state.startLoc,\n        declaration,\n      );\n      return this.parseIdentifier(liberal);\n    }\n\n    // Type aliases\n\n    flowParseTypeAlias(node: Undone<N.FlowTypeAlias>): N.FlowTypeAlias {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ false,\n        /* declaration */ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(tt.eq);\n      this.semicolon();\n\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(\n      node: Undone<N.FlowOpaqueType>,\n      declare: boolean,\n    ): N.FlowOpaqueType {\n      this.expectContextual(tt._type);\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ true,\n        /* declaration */ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      // Parse the supertype\n      node.supertype = null;\n      if (this.match(tt.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(tt.colon);\n      }\n\n      node.impltype = null;\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(tt.eq);\n      }\n      this.semicolon();\n\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    // Type annotations\n\n    flowParseTypeParameter(requireDefault: boolean = false): N.TypeParameter {\n      const nodeStartLoc = this.state.startLoc;\n\n      const node = this.startNode<N.TypeParameter>();\n\n      const variance = this.flowParseVariance();\n\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      // @ts-expect-error migrate to Babel types\n      node.variance = variance;\n      // @ts-expect-error migrate to Babel types\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(tt.eq)) {\n        this.eat(tt.eq);\n        // @ts-expect-error migrate to Babel types\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(FlowErrors.MissingTypeParamDefault, { at: nodeStartLoc });\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration(): N.TypeParameterDeclaration {\n      const oldInType = this.state.inType;\n      const node = this.startNode<N.TypeParameterDeclaration>();\n      node.params = [];\n\n      this.state.inType = true;\n\n      // istanbul ignore else: this condition is already checked at all call sites\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      } while (!this.match(tt.gt));\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType(): N.FlowInterfaceType {\n      const node = this.startNode<N.FlowInterfaceType>();\n      this.expectContextual(tt._interface);\n\n      node.extends = [];\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false,\n      });\n\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey(): N.Expression {\n      return this.match(tt.num) || this.match(tt.string)\n        ? super.parseExprAtom()\n        : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(\n      node: Undone<N.FlowObjectTypeIndexer>,\n      isStatic: boolean,\n      variance?: N.FlowVariance | null,\n    ): N.FlowObjectTypeIndexer {\n      node.static = isStatic;\n\n      // Note: bracketL has already been consumed\n      if (this.lookahead().type === tt.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n      this.expect(tt.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(\n      node: Undone<N.FlowObjectTypeInternalSlot>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeInternalSlot {\n      node.static = isStatic;\n      // Note: both bracketL have already been consumed\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(tt.bracketR);\n      this.expect(tt.bracketR);\n      if (this.match(tt.lt) || this.match(tt.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(\n          this.startNodeAt(node.loc.start),\n        );\n      } else {\n        node.method = false;\n        if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n      }\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(\n      node: Undone<N.FlowFunctionTypeAnnotation>,\n    ): N.FlowFunctionTypeAnnotation {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n      node.this = null;\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(tt.parenL);\n      if (this.match(tt._this)) {\n        node.this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        node.this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n\n      if (this.eat(tt.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam(false);\n      }\n      this.expect(tt.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(\n      node: Undone<N.FlowObjectTypeCallProperty>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeCallProperty {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact,\n    }: {\n      allowStatic: boolean;\n      allowExact: boolean;\n      allowSpread: boolean;\n      allowProto: boolean;\n      allowInexact: boolean;\n    }): N.FlowObjectTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n\n      const nodeStart = this.startNode();\n\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n\n      let endDelim;\n      let exact;\n      let inexact = false;\n      if (allowExact && this.match(tt.braceBarL)) {\n        this.expect(tt.braceBarL);\n        endDelim = tt.braceBarR;\n        exact = true;\n      } else {\n        this.expect(tt.braceL);\n        endDelim = tt.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStartLoc: Position | undefined | null = null;\n        let inexactStartLoc: Position | undefined | null = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(tt._proto)) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            protoStartLoc = this.state.startLoc;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(tt._static)) {\n          const lookahead = this.lookahead();\n\n          // static is a valid identifier name\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(tt.bracketL)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (this.eat(tt.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.loc.start);\n            }\n            nodeStart.internalSlots.push(\n              this.flowParseObjectTypeInternalSlot(node, isStatic),\n            );\n          } else {\n            nodeStart.indexers.push(\n              this.flowParseObjectTypeIndexer(node, isStatic, variance),\n            );\n          }\n        } else if (this.match(tt.parenL) || this.match(tt.lt)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.callProperties.push(\n            this.flowParseObjectTypeCallProperty(node, isStatic),\n          );\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(tt._get) || this.isContextual(tt._set)) {\n            const lookahead = this.lookahead();\n            if (tokenIsLiteralPropertyName(lookahead.type)) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(\n            node,\n            isStatic,\n            protoStartLoc,\n            variance,\n            kind,\n            allowSpread,\n            allowInexact ?? !exact,\n          );\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStartLoc = this.state.lastTokStartLoc;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (\n          inexactStartLoc &&\n          !this.match(tt.braceR) &&\n          !this.match(tt.braceBarR)\n        ) {\n          this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {\n            at: inexactStartLoc,\n          });\n        }\n      }\n\n      this.expect(endDelim);\n\n      /* The inexact flag should only be added on ObjectTypeAnnotations that\n       * are not the body of an interface, declare interface, or declare class.\n       * Since spreads are only allowed in object types, checking that is\n       * sufficient here.\n       */\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n      this.state.inType = oldInType;\n\n      return out;\n    }\n\n    flowParseObjectTypeProperty(\n      node: Undone<N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty>,\n      isStatic: boolean,\n      protoStartLoc: Position | undefined | null,\n      variance: N.FlowVariance | undefined | null,\n      kind: string,\n      allowSpread: boolean,\n      allowInexact: boolean,\n    ): N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty | null {\n      if (this.eat(tt.ellipsis)) {\n        const isInexactToken =\n          this.match(tt.comma) ||\n          this.match(tt.semi) ||\n          this.match(tt.braceR) ||\n          this.match(tt.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(FlowErrors.InexactInsideNonObject, {\n              at: this.state.lastTokStartLoc,\n            });\n          } else if (!allowInexact) {\n            this.raise(FlowErrors.InexactInsideExact, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          if (variance) {\n            this.raise(FlowErrors.InexactVariance, { at: variance });\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(FlowErrors.UnexpectedSpreadType, {\n            at: this.state.lastTokStartLoc,\n          });\n        }\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.SpreadVariance, { at: variance });\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStartLoc != null;\n        node.kind = kind;\n\n        let optional = false;\n        if (this.match(tt.lt) || this.match(tt.parenL)) {\n          // This is a method property\n          node.method = true;\n\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(\n            this.startNodeAt(node.loc.start),\n          );\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n          /** Declared classes/interfaces do not allow spread */\n          if (\n            !allowSpread &&\n            node.key.name === \"constructor\" &&\n            node.value.this\n          ) {\n            this.raise(FlowErrors.ThisParamBannedInConstructor, {\n              at: node.value.this,\n            });\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n\n          node.method = false;\n\n          if (this.eat(tt.question)) {\n            optional = true;\n          }\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    // This is similar to checkGetterSetterParams, but as\n    // @babel/parser uses non estree properties we cannot reuse it here\n    flowCheckGetterSetterParams(\n      property: Undone<\n        N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty\n      >,\n    ): void {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const length =\n        property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (property.value.this) {\n        this.raise(\n          property.kind === \"get\"\n            ? FlowErrors.GetterMayNotHaveThisParam\n            : FlowErrors.SetterMayNotHaveThisParam,\n          { at: property.value.this },\n        );\n      }\n\n      if (length !== paramCount) {\n        this.raise(\n          property.kind === \"get\"\n            ? Errors.BadGetterArity\n            : Errors.BadSetterArity,\n          { at: property },\n        );\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(Errors.BadSetterRestParameter, { at: property });\n      }\n    }\n\n    flowObjectTypeSemicolon(): void {\n      if (\n        !this.eat(tt.semi) &&\n        !this.eat(tt.comma) &&\n        !this.match(tt.braceR) &&\n        !this.match(tt.braceBarR)\n      ) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(\n      startLoc?: Position,\n      id?: N.Identifier,\n    ): N.FlowQualifiedTypeIdentifier {\n      startLoc ??= this.state.startLoc;\n      let node: N.Identifier | N.FlowQualifiedTypeIdentifier =\n        id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(tt.dot)) {\n        const node2 = this.startNodeAt<N.FlowQualifiedTypeIdentifier>(startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(\n      startLoc: Position,\n      id: N.Identifier,\n    ): N.FlowGenericTypeAnnotation {\n      const node = this.startNodeAt(startLoc);\n\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {\n      const node = this.startNode();\n      this.expect(tt._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType(): N.FlowTupleTypeAnnotation {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(tt.bracketL);\n      // We allow trailing commas\n      while (this.state.pos < this.length && !this.match(tt.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(tt.bracketR)) break;\n        this.expect(tt.comma);\n      }\n      this.expect(tt.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam(first: boolean): N.FlowFunctionTypeParam {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode<N.FlowFunctionTypeParam>();\n      const lh = this.lookahead();\n      const isThis = this.state.type === tt._this;\n\n      if (lh.type === tt.colon || lh.type === tt.question) {\n        if (isThis && !first) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, { at: node });\n        }\n        name = this.parseIdentifier(isThis);\n        if (this.eat(tt.question)) {\n          optional = true;\n          if (isThis) {\n            this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: node });\n          }\n        }\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(\n      type: N.FlowType,\n    ): N.FlowFunctionTypeParam {\n      const node = this.startNodeAt(type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params: N.FlowFunctionTypeParam[] = []): {\n      params: N.FlowFunctionTypeParam[];\n      rest: N.FlowFunctionTypeParam | undefined | null;\n      _this: N.FlowFunctionTypeParam | undefined | null;\n    } {\n      let rest: N.FlowFunctionTypeParam | undefined | null = null;\n      let _this: N.FlowFunctionTypeParam | undefined | null = null;\n      if (this.match(tt._this)) {\n        _this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        _this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      if (this.eat(tt.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam(false);\n      }\n      return { params, rest, _this };\n    }\n\n    flowIdentToTypeAnnotation(\n      startLoc: Position,\n      node: Undone<N.FlowTypeAnnotation>,\n      id: N.Identifier,\n    ): N.FlowTypeAnnotation {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startLoc, id);\n      }\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    flowParsePrimaryType(): N.FlowTypeAnnotation {\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case tt.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true,\n          });\n\n        case tt.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false,\n          });\n\n        case tt.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case tt.lt:\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(tt.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.parenL:\n          this.next();\n\n          // Check to see if this is actually a grouped type\n          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== tt.question && token !== tt.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            // A `,` or a `) =>` means this is an anonymous function type\n            if (\n              this.state.noAnonFunctionType ||\n              !(\n                this.match(tt.comma) ||\n                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)\n              )\n            ) {\n              this.expect(tt.parenR);\n              return type;\n            } else {\n              // Eat a comma if there is one\n              this.eat(tt.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([\n              this.reinterpretTypeAsFunctionTypeParam(type),\n            ]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          node.typeParameters = null;\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.string:\n          return this.parseLiteral<N.StringLiteralTypeAnnotation>(\n            this.state.value,\n            \"StringLiteralTypeAnnotation\",\n          );\n\n        case tt._true:\n        case tt._false:\n          node.value = this.match(tt._true);\n          this.next();\n          return this.finishNode(\n            node as Undone<N.BooleanLiteralTypeAnnotation>,\n            \"BooleanLiteralTypeAnnotation\",\n          );\n\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n            if (this.match(tt.num)) {\n              return this.parseLiteralAtNode<N.NumberLiteralTypeAnnotation>(\n                -this.state.value,\n                \"NumberLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            if (this.match(tt.bigint)) {\n              return this.parseLiteralAtNode<N.BigIntLiteralTypeAnnotation>(\n                -this.state.value,\n                \"BigIntLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {\n              at: this.state.startLoc,\n            });\n          }\n          this.unexpected();\n          return;\n        case tt.num:\n          return this.parseLiteral(\n            this.state.value,\n            \"NumberLiteralTypeAnnotation\",\n          );\n\n        case tt.bigint:\n          return this.parseLiteral(\n            this.state.value,\n            \"BigIntLiteralTypeAnnotation\",\n          );\n\n        case tt._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case tt._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case tt._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case tt.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        case tt._typeof:\n          return this.flowParseTypeofType();\n\n        default:\n          if (tokenIsKeyword(this.state.type)) {\n            const label = tokenLabelName(this.state.type);\n            this.next();\n            return super.createIdentifier(node as Undone<N.Identifier>, label);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            if (this.isContextual(tt._interface)) {\n              return this.flowParseInterfaceType();\n            }\n\n            return this.flowIdentToTypeAnnotation(\n              startLoc,\n              node,\n              this.parseIdentifier(),\n            );\n          }\n      }\n\n      this.unexpected();\n    }\n\n    flowParsePostfixType(): N.FlowTypeAnnotation {\n      const startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n      let seenOptionalIndexedAccess = false;\n      while (\n        (this.match(tt.bracketL) || this.match(tt.questionDot)) &&\n        !this.canInsertSemicolon()\n      ) {\n        const node = this.startNodeAt(startLoc);\n        const optional = this.eat(tt.questionDot);\n        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n        this.expect(tt.bracketL);\n        if (!optional && this.match(tt.bracketR)) {\n          node.elementType = type;\n          this.next(); // eat `]`\n          type = this.finishNode(node, \"ArrayTypeAnnotation\");\n        } else {\n          node.objectType = type;\n          node.indexType = this.flowParseType();\n          this.expect(tt.bracketR);\n          if (seenOptionalIndexedAccess) {\n            node.optional = optional;\n            type = this.finishNode<N.FlowOptionalIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"OptionalIndexedAccessType\",\n            );\n          } else {\n            type = this.finishNode<N.FlowIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"IndexedAccessType\",\n            );\n          }\n        }\n      }\n      return type;\n    }\n\n    flowParsePrefixType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      if (this.eat(tt.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {\n      const param = this.flowParsePrefixType();\n      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {\n        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\n        const node = this.startNodeAt(param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.this = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      return param;\n    }\n\n    flowParseIntersectionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n      while (this.eat(tt.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n      while (this.eat(tt.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType(): N.FlowTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation(): N.FlowTypeAnnotation {\n      if (this.state.type === tt.name && this.state.value === \"_\") {\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation(): N.FlowTypeAnnotation {\n      const node = this.startNode<N.FlowTypeAnnotation>();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(\n      allowPrimitiveOverride?: boolean,\n    ): N.Identifier {\n      const ident = allowPrimitiveOverride\n        ? this.parseIdentifier()\n        : this.flowParseRestrictedIdentifier();\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n      return ident;\n    }\n\n    typeCastToParameter(node: N.Node): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    flowParseVariance(): N.FlowVariance | undefined | null {\n      let variance = null;\n      if (this.match(tt.plusMin)) {\n        variance = this.startNode<N.FlowVariance>();\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n        this.next();\n        return this.finishNode(variance, \"Variance\");\n      }\n      return variance;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpressionBody?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      if (allowExpressionBody) {\n        this.forwardNoArrowParamsConversionAt(node, () =>\n          super.parseFunctionBody(node, true, isMethod),\n        );\n        return;\n      }\n\n      super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        const typeNode = this.startNode<N.TypeAnnotation>();\n\n        [\n          typeNode.typeAnnotation,\n          // @ts-expect-error predicate may not exist\n          node.predicate,\n        ] = this.flowParseTypeAndPredicateInitialiser();\n\n        node.returnType = typeNode.typeAnnotation\n          ? this.finishNode(typeNode, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    // interfaces and enums\n    parseStatementLike(flags: ParseStatementFlag): N.Statement {\n      // strict mode handling of `interface` since it's a reserved word\n      if (this.state.strict && this.isContextual(tt._interface)) {\n        const lookahead = this.lookahead();\n        if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n          const node = this.startNode<N.FlowInterface>();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      const stmt = super.parseStatementLike(flags);\n      // We will parse a flow pragma in any comment before the first statement.\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n      return stmt;\n    }\n\n    // declares, interfaces and type aliases\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n      decorators: N.Decorator[] | null,\n    ): N.ExpressionStatement {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (\n            this.match(tt._class) ||\n            tokenIsIdentifier(this.state.type) ||\n            this.match(tt._function) ||\n            this.match(tt._var) ||\n            this.match(tt._export)\n          ) {\n            // @ts-expect-error: refine typings\n            return this.flowParseDeclare(node);\n          }\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (expr.name === \"interface\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr, decorators);\n    }\n\n    // export type\n    shouldParseExportDeclaration(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return !this.state.containsEsc;\n      }\n      return super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return this.state.containsEsc;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(\n      expr: N.Expression,\n\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      if (!this.match(tt.question)) return expr;\n\n      if (this.state.maybeInArrowParameters) {\n        const nextCh = this.lookaheadCharCode();\n        // These tokens cannot start an expression, so if one of them follows\n        // ? then we are probably in an arrow function parameters list and we\n        // don't parse the conditional expression.\n        if (\n          nextCh === charCodes.comma || // (a?, b) => c\n          nextCh === charCodes.equalsTo || // (a? = b) => c\n          nextCh === charCodes.colon || // (a?: b) => c\n          nextCh === charCodes.rightParenthesis // (a?) => c\n        ) {\n          /*:: invariant(refExpressionErrors != null) */\n          this.setOptionalParametersError(refExpressionErrors);\n          return expr;\n        }\n      }\n\n      this.expect(tt.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startLoc);\n      let { consequent, failed } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          // if there are two or more possible correct ways of parsing, throw an\n          // error.\n          // e.g.   Source: a ? (b): c => (d): e => f\n          //      Result 1: a ? b : (c => ((d): e => f))\n          //      Result 2: a ? ((b): c => d) : (e => f)\n          this.raise(FlowErrors.AmbiguousConditionalArrow, {\n            at: state.startLoc,\n          });\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          noArrowAt.push(valid[0].start);\n          this.state.noArrowAt = noArrowAt;\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(tt.colon);\n\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>\n        this.parseMaybeAssign(undefined, undefined),\n      );\n\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent(): {\n      consequent: N.Expression;\n      failed: boolean;\n    } {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(tt.colon);\n\n      this.state.noArrowParamsConversionAt.pop();\n\n      return { consequent, failed };\n    }\n\n    // Given an expression, walks through out its arrow functions whose body is\n    // an expression and through out conditional expressions. It returns every\n    // function which has been parsed with a return type but could have been\n    // parenthesized expressions.\n    // These functions are separated into two arrays: one containing the ones\n    // whose parameters can be converted to assignable lists, one containing the\n    // others.\n    getArrowLikeExpressions(\n      node: N.Expression,\n      disallowInvalid?: boolean,\n    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {\n      const stack = [node];\n      const arrows: N.ArrowFunctionExpression[] = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            // This is an arrow expression without ambiguity, so check its parameters\n            // @ts-expect-error: refine typings\n            this.finishArrowValidation(node);\n          } else {\n            // @ts-expect-error: refine typings\n            arrows.push(node);\n          }\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node =>\n        node.params.every(param => this.isAssignable(param, true)),\n      );\n    }\n\n    finishArrowValidation(node: N.ArrowFunctionExpression) {\n      this.toAssignableList(\n        // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\n        // has not been converted yet.\n        node.params as any as N.Expression[],\n        node.extra?.trailingCommaLoc,\n        /* isLHS */ false,\n      );\n      // Enter scope, as checkParams defines bindings\n      this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.ARROW);\n      // Use super's method to force the parameters to be checked\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt<T>(\n      node: Undone<N.Node>,\n      parse: () => T,\n    ): T {\n      let result: T;\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(\n      node: N.Expression,\n\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt(startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node: N.Node) {\n      if (\n        (node.type === \"ImportDeclaration\" &&\n          (node.importKind === \"type\" || node.importKind === \"typeof\")) ||\n        (node.type === \"ExportNamedDeclaration\" &&\n          node.exportKind === \"type\") ||\n        (node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\")\n      ) {\n        // Allow Flowtype imports and exports in all conditions because\n        // Flow itself does not care about 'sourceType'.\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (this.isContextual(tt._type)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(tt.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers(\n            /* isInTypeExport */ true,\n          );\n          super.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          // @ts-expect-error: refine typings\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(tt._opaque)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        // @ts-expect-error: refine typings\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(tt._interface)) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node: N.Node): boolean {\n      if (super.eatExportStar(node)) return true;\n\n      if (this.isContextual(tt._type) && this.lookahead().type === tt.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n      const { startLoc } = this.state;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(startLoc);\n      }\n      return hasNamespace;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n    ) {\n      super.parseClassId(node, isStatement, optionalId);\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const { startLoc } = this.state;\n      if (this.isContextual(tt._declare)) {\n        if (super.parseClassMemberFromModifier(classBody, member)) {\n          // 'declare' is a class element name\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (\n          member.type !== \"ClassProperty\" &&\n          member.type !== \"ClassPrivateProperty\" &&\n          member.type !== \"PropertyDefinition\" // Used by estree plugin\n        ) {\n          this.raise(FlowErrors.DeclareClassElement, { at: startLoc });\n        } else if (member.value) {\n          this.raise(FlowErrors.DeclareClassFieldInitializer, {\n            at: member.value,\n          });\n        }\n      }\n    }\n\n    isIterator(word: string): boolean {\n      return word === \"iterator\" || word === \"asyncIterator\";\n    }\n\n    readIterator(): void {\n      const word = super.readWord1();\n      const fullWord = \"@@\" + word;\n\n      // Allow @@iterator and @@asyncIterator as a identifier only inside type\n      if (!this.isIterator(word) || !this.state.inType) {\n        this.raise(Errors.InvalidIdentifier, {\n          at: this.state.curPosition(),\n          identifierName: fullWord,\n        });\n      }\n\n      this.finishToken(tt.name, fullWord);\n    }\n\n    // ensure that inside flow types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (code === charCodes.leftCurlyBrace && next === charCodes.verticalBar) {\n        this.finishOp(tt.braceBarL, 2);\n      } else if (\n        this.state.inType &&\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\n      ) {\n        this.finishOp(code === charCodes.greaterThan ? tt.gt : tt.lt, 1);\n      } else if (this.state.inType && code === charCodes.questionMark) {\n        if (next === charCodes.dot) {\n          this.finishOp(tt.questionDot, 2);\n        } else {\n          // allow double nullable types in Flow: ??string\n          this.finishOp(tt.question, 1);\n        }\n      } else if (\n        isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))\n      ) {\n        this.state.pos += 2; // eat \"@@\"\n        this.readIterator();\n      } else {\n        super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node.type === \"TypeCastExpression\") {\n        return this.isAssignable(node.expression, isBinding);\n      } else {\n        return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (\n        !isLHS &&\n        node.type === \"AssignmentExpression\" &&\n        node.left.type === \"TypeCastExpression\"\n      ) {\n        node.left = this.typeCastToParameter(node.left);\n      }\n      super.toAssignable(node, isLHS);\n    }\n\n    // turn type casts that we found in function parameter head into type annotated params\n    toAssignableList(\n      exprList: N.Expression[],\n      trailingCommaLoc: Position | undefined | null,\n      isLHS: boolean,\n    ): void {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n    }\n\n    // this is a list of nodes, from something like a call expression, we need to filter the\n    // type casts that we've found that are illegal in this context\n    toReferencedList(\n      exprList: ReadonlyArray<N.Expression | undefined | null>,\n      isParenthesizedExpr?: boolean,\n    ): ReadonlyArray<N.Expression | undefined | null> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (\n          expr &&\n          expr.type === \"TypeCastExpression\" &&\n          !expr.extra?.parenthesized &&\n          (exprList.length > 1 || !isParenthesizedExpr)\n        ) {\n          this.raise(FlowErrors.TypeCastInPattern, {\n            at: expr.typeAnnotation,\n          });\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      // This could be an array pattern:\n      //   ([a: string, b: string]) => {}\n      // In this case, we don't have to call toReferencedList. We will\n      // call it, if needed, when we are sure that it is a parenthesized\n      // expression by calling toReferencedListDeep.\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingTypes) {\n      return (\n        type === \"TypeCastExpression\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    // parse class property type annotations\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error refine typings\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error refine typings\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassPrivateProperty(node);\n    }\n\n    // determine whether or not we're currently in the position where a class method would appear\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    // determine whether or not we're currently in the position where a class property would appear\n    isClassProperty(): boolean {\n      return this.match(tt.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n      return !this.match(tt.colon) && super.isNonstaticConstructor(method);\n    }\n\n    // parse type parameters for class methods\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n\n      if (method.params && isConstructor) {\n        const params = method.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });\n        }\n        // estree support\n      } else if (\n        // @ts-expect-error TS does not know about the face that estree can replace ClassMethod with MethodDefinition\n        method.type === \"MethodDefinition\" &&\n        isConstructor &&\n        // @ts-expect-error estree\n        method.value.params\n      ) {\n        // @ts-expect-error estree\n        const params = method.value.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });\n        }\n      }\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    // parse a the super class type parameters and implements\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (node.superClass && this.match(tt.lt)) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n      if (this.isContextual(tt._implements)) {\n        this.next();\n        const implemented: N.FlowClassImplements[] = (node.implements = []);\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(tt.comma));\n      }\n    }\n\n    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n      super.checkGetterSetterParams(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      if (params.length > 0) {\n        const param = params[0];\n        if (this.isThisParam(param) && method.kind === \"get\") {\n          this.raise(FlowErrors.GetterMayNotHaveThisParam, { at: param });\n        } else if (this.isThisParam(param)) {\n          this.raise(FlowErrors.SetterMayNotHaveThisParam, { at: param });\n        }\n      }\n    }\n\n    parsePropertyNamePrefixOperator(\n      node: N.ObjectOrClassMember | N.ClassMember,\n    ): void {\n      node.variance = this.flowParseVariance();\n    }\n\n    // parse type parameters for object method shorthand\n    parseObjPropValue(\n      prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ObjectMethod | N.ObjectProperty {\n      if ((prop as any).variance) {\n        this.unexpected((prop as any).variance.loc.start);\n      }\n      delete (prop as any).variance;\n\n      let typeParameters;\n\n      // method shorthand\n      if (this.match(tt.lt) && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(tt.parenL)) this.unexpected();\n      }\n\n      const result = super.parseObjPropValue(\n        prop,\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        // @ts-expect-error: refine typings\n        (result.value || result).typeParameters = typeParameters;\n      }\n      return result;\n    }\n\n    parseAssignableListItemTypes(param: N.Pattern): N.Pattern {\n      if (this.eat(tt.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(FlowErrors.PatternIsOptional, { at: param });\n        }\n        if (this.isThisParam(param)) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: param });\n        }\n\n        (param as any as N.Identifier).optional = true;\n      }\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamAnnotationRequired, { at: param });\n      }\n\n      if (this.match(tt.eq) && this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamNoDefault, { at: param });\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(\n      startLoc?: Position | null,\n      left?: N.Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(FlowErrors.TypeBeforeInitializer, {\n          at: node.typeAnnotation,\n        });\n      }\n\n      return node;\n    }\n\n    checkImportReflection(node: Undone<N.ImportDeclaration>) {\n      super.checkImportReflection(node);\n      if (node.module && node.importKind !== \"value\") {\n        this.raise(FlowErrors.ImportReflectionHasImportType, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n    }\n\n    parseImportSpecifierLocal<\n      T extends\n        | N.ImportSpecifier\n        | N.ImportDefaultSpecifier\n        | N.ImportNamespaceSpecifier,\n    >(node: N.ImportDeclaration, specifier: Undone<T>, type: T[\"type\"]): void {\n      specifier.local = hasTypeImportKind(node)\n        ? this.flowParseRestrictedIdentifier(\n            /* liberal */ true,\n            /* declaration */ true,\n          )\n        : this.parseIdentifier();\n\n      node.specifiers.push(this.finishImportSpecifier(specifier, type));\n    }\n\n    isPotentialImportPhase(isExport: boolean): boolean {\n      if (super.isPotentialImportPhase(isExport)) return true;\n      if (this.isContextual(tt._type)) {\n        if (!isExport) return true;\n        const ch = this.lookaheadCharCode();\n        return ch === charCodes.leftCurlyBrace || ch === charCodes.asterisk;\n      }\n      return !isExport && this.isContextual(tt._typeof);\n    }\n\n    applyImportPhase(\n      node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n      isExport: boolean,\n      phase: string | null,\n      loc?: Position,\n    ): void {\n      super.applyImportPhase(node, isExport, phase, loc);\n      if (isExport) {\n        if (!phase && this.match(tt._default)) {\n          // TODO: Align with our TS AST and always add .exportKind\n          return;\n        }\n        (node as N.ExportNamedDeclaration).exportKind =\n          phase === \"type\" ? phase : \"value\";\n      } else {\n        if (phase === \"type\" && this.match(tt.star)) this.unexpected();\n        (node as N.ImportDeclaration).importKind =\n          phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n      }\n    }\n\n    // parse import-type/typeof shorthand\n    parseImportSpecifier(\n      specifier: any,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isMaybeTypeOnly: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType: BindingTypes | undefined,\n    ): N.ImportSpecifier {\n      const firstIdent = specifier.imported;\n\n      let specifierTypeKind = null;\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n      if (this.isContextual(tt._as) && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n        if (\n          specifierTypeKind !== null &&\n          !tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = cloneIdentifier(as_ident);\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else {\n        if (\n          specifierTypeKind !== null &&\n          tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type foo`\n          specifier.imported = this.parseIdentifier(true);\n          specifier.importKind = specifierTypeKind;\n        } else {\n          if (importedIsString) {\n            /*:: invariant(firstIdent instanceof N.StringLiteral) */\n            throw this.raise(Errors.ImportBindingIsString, {\n              at: specifier,\n              importName: firstIdent.value,\n            });\n          }\n          /*:: invariant(firstIdent instanceof N.Node) */\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n        }\n\n        if (this.eatContextual(tt._as)) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = cloneIdentifier(specifier.imported);\n        }\n      }\n\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (isInTypeOnlyImport && specifierIsTypeImport) {\n        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {\n          at: specifier,\n        });\n      }\n\n      if (isInTypeOnlyImport || specifierIsTypeImport) {\n        this.checkReservedType(\n          specifier.local.name,\n          specifier.local.loc.start,\n          /* declaration */ true,\n        );\n      }\n\n      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n        this.checkReservedWord(\n          specifier.local.name,\n          specifier.loc.start,\n          true,\n          true,\n        );\n      }\n\n      return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    // parse function type parameters - function foo<T>() {}\n    parseFunctionParams(\n      node: Undone<N.Function>,\n      isConstructor: boolean,\n    ): void {\n      // @ts-expect-error kind may not index node\n      const kind = node.kind;\n      if (kind !== \"get\" && kind !== \"set\" && this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      super.parseFunctionParams(node, isConstructor);\n    }\n\n    // parse flow type annotations on variable declarator heads - let foo: string = bar\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        // @ts-expect-error refine typings\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    // todo description\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    // We need to support type parameter declarations for arrow functions. This\n    // is tricky. There are three situations we need to handle\n    //\n    // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n    //    error.\n    // 2. This is an arrow function. We'll parse the type parameter declaration,\n    //    parse the rest, make sure the rest is an arrow function, and go from\n    //    there\n    // 3. This is neither. Just call the super method\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      let state = null;\n\n      let jsx;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (jsx?.error || this.match(tt.lt)) {\n        state = state || this.state.clone();\n\n        let typeParameters: N.TypeParameterDeclaration;\n\n        const arrow = this.tryParse(abort => {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(\n            typeParameters,\n            () => {\n              const result = super.parseMaybeAssign(\n                refExpressionErrors,\n                afterLeftParse,\n              );\n\n              this.resetStartLocationFromNode(result, typeParameters);\n\n              return result;\n            },\n          );\n\n          // <T>(() => {});\n          // <T>(() => {}: any);\n          if (arrowExpression.extra?.parenthesized) abort();\n\n          // The above can return a TypeCastExpression when the arrow\n          // expression is not wrapped in parens. See also `this.parseParenItem`.\n          // (<T>() => {}: any);\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n\n          if (expr.type !== \"ArrowFunctionExpression\") abort();\n\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n\n          return arrowExpression;\n        }, state);\n\n        let arrowExpression:\n          | N.ArrowFunctionExpression\n          | N.TypeCastExpression\n          | undefined\n          | null = null;\n\n        if (\n          arrow.node &&\n          // @ts-expect-error: refine tryParse typings\n          this.maybeUnwrapTypeCastExpression(arrow.node).type ===\n            \"ArrowFunctionExpression\"\n        ) {\n          if (!arrow.error && !arrow.aborted) {\n            // <T> async () => {}\n            // @ts-expect-error: refine tryParse typings\n            if (arrow.node.async) {\n              /*:: invariant(typeParameters) */\n              this.raise(\n                FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,\n                { at: typeParameters },\n              );\n            }\n            // @ts-expect-error: refine tryParse typings\n            return arrow.node;\n          }\n\n          // @ts-expect-error: refine typings\n          arrowExpression = arrow.node;\n        }\n\n        // If we are here, both JSX and Flow parsing attempts failed.\n        // Give the precedence to the JSX error, except if JSX had an\n        // unrecoverable error while Flow didn't.\n        // If the error is recoverable, we can only re-report it if there is\n        // a node we can return.\n\n        if (jsx?.node) {\n          /*:: invariant(jsx.failState) */\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          /*:: invariant(arrow.failState) */\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if (jsx?.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n\n        /*:: invariant(typeParameters) */\n        throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {\n          at: typeParameters,\n        });\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n\n    // handle return types for arrow functions\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error todo(flow->ts)\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n\n          const typeNode = this.startNode<N.TypeAnnotation>();\n\n          [\n            typeNode.typeAnnotation,\n            // @ts-expect-error (destructuring not supported yet)\n            node.predicate,\n          ] = this.flowParseTypeAndPredicateInitialiser();\n\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(tt.arrow)) this.unexpected();\n\n          return typeNode;\n        });\n\n        if (result.thrown) return null;\n        /*:: invariant(result.node) */\n\n        if (result.error) this.state = result.failState;\n\n        // assign after it is clear it is an arrow\n        // @ts-expect-error todo(flow->ts)\n        node.returnType = result.node.typeAnnotation\n          ? this.finishNode(result.node, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow(params: Array<N.Node>): boolean {\n      return this.match(tt.colon) || super.shouldParseArrow(params);\n    }\n\n    setArrowFunctionParameters(\n      node: N.ArrowFunctionExpression,\n      params: N.Pattern[],\n    ): void {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(\n      node: N.Function,\n      allowDuplicates: boolean,\n      isArrowFunction?: boolean | null,\n      strictModeChanged: boolean = true,\n    ): void {\n      if (\n        isArrowFunction &&\n        this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1\n      ) {\n        return;\n      }\n\n      // ensure the `this` param is first, if it exists\n      for (let i = 0; i < node.params.length; i++) {\n        if (this.isThisParam(node.params[i]) && i > 0) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, { at: node.params[i] });\n        }\n      }\n\n      super.checkParams(\n        node,\n        allowDuplicates,\n        isArrowFunction,\n        strictModeChanged,\n      );\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n      return super.parseParenAndDistinguishExpression(\n        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,\n      );\n    }\n\n    parseSubscripts(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls?: boolean | null,\n    ): N.Expression {\n      if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.state.noArrowAt.indexOf(startLoc.index) !== -1\n      ) {\n        this.next();\n\n        const node = this.startNodeAt(startLoc);\n        node.callee = base;\n        node.arguments = super.parseCallExpressionArguments(tt.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.match(tt.lt)\n      ) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(\n          abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(),\n          state,\n        );\n\n        /*:: invariant(arrow.node != null) */\n        // @ts-expect-error: refine tryParse typings\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n\n        const result = this.tryParse(\n          () => super.parseSubscripts(base, startLoc, noCalls),\n          state,\n        );\n\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          // @ts-expect-error: refine tryParse typings\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startLoc, noCalls);\n    }\n\n    parseSubscript(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      subscriptState: N.ParseSubscriptState,\n    ): N.Expression {\n      if (this.match(tt.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n        this.next();\n        const node = this.startNodeAt<N.OptionalCallExpression>(startLoc);\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(tt.parenL);\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, /* optional */ true);\n      } else if (!noCalls && this.shouldParseTypes() && this.match(tt.lt)) {\n        const node = this.startNodeAt<\n          N.OptionalCallExpression | N.CallExpression\n        >(startLoc);\n        node.callee = base;\n\n        const result = this.tryParse(() => {\n          node.typeArguments =\n            this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(tt.parenL);\n          node.arguments = super.parseCallExpressionArguments(tt.parenR, false);\n          if (subscriptState.optionalChainMember) {\n            (node as Undone<N.OptionalCallExpression>).optional = false;\n          }\n          return this.finishCallExpression(\n            node,\n            subscriptState.optionalChainMember,\n          );\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(\n        base,\n\n        startLoc,\n        noCalls,\n        subscriptState,\n      );\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      let targs = null;\n      if (this.shouldParseTypes() && this.match(tt.lt)) {\n        targs = this.tryParse(() =>\n          this.flowParseTypeParameterInstantiationCallOrNew(),\n        ).node;\n      }\n      node.typeArguments = targs;\n    }\n\n    parseAsyncArrowWithTypeParameters(\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined | null {\n      const node = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n      this.parseFunctionParams(node, false);\n      if (!this.parseArrow(node)) return;\n      return super.parseArrowExpression(\n        node,\n        /* params */ undefined,\n        /* isAsync */ true,\n      );\n    }\n\n    readToken_mult_modulo(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.asterisk &&\n        next === charCodes.slash &&\n        this.state.hasFlowComment\n      ) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.verticalBar &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        // '|}'\n        this.finishOp(tt.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file: N.File, program: N.Program): N.File {\n      const fileNode = super.parseTopLevel(file, program);\n      if (this.state.hasFlowComment) {\n        this.raise(FlowErrors.UnterminatedFlowComment, {\n          at: this.state.curPosition(),\n        });\n      }\n      return fileNode;\n    }\n\n    skipBlockComment(): N.CommentBlock | undefined {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          throw this.raise(FlowErrors.NestedFlowComment, {\n            at: this.state.startLoc,\n          });\n        }\n        this.hasFlowCommentCompletion();\n        const commentSkip = this.skipFlowComment();\n        if (commentSkip) {\n          this.state.pos += commentSkip;\n          this.state.hasFlowComment = true;\n        }\n        return;\n      }\n\n      return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n    }\n\n    skipFlowComment(): number | false {\n      const { pos } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n      while (\n        [charCodes.space, charCodes.tab].includes(\n          // @ts-expect-error testing whether a number is included\n          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),\n        )\n      ) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {\n        return shiftToFirstNonWhiteSpace + 2; // check for /*::\n      }\n      if (\n        this.input.slice(\n          shiftToFirstNonWhiteSpace + pos,\n          shiftToFirstNonWhiteSpace + pos + 12,\n        ) === \"flow-include\"\n      ) {\n        return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include\n      }\n      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {\n        return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :\n      }\n      return false;\n    }\n\n    hasFlowCommentCompletion(): void {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n      if (end === -1) {\n        throw this.raise(Errors.UnterminatedComment, {\n          at: this.state.curPosition(),\n        });\n      }\n    }\n\n    // Flow enum parsing\n\n    flowEnumErrorBooleanMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {\n        at: loc,\n        memberName,\n        enumName,\n      });\n    }\n\n    flowEnumErrorInvalidMemberInitializer(\n      loc: Position,\n      enumContext: EnumContext,\n    ) {\n      return this.raise(\n        !enumContext.explicitType\n          ? FlowErrors.EnumInvalidMemberInitializerUnknownType\n          : enumContext.explicitType === \"symbol\"\n            ? FlowErrors.EnumInvalidMemberInitializerSymbolType\n            : FlowErrors.EnumInvalidMemberInitializerPrimaryType,\n        {\n          at: loc,\n          ...enumContext,\n        },\n      );\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumNumberMemberNotInitialized, {\n        at: loc,\n        enumName,\n        memberName,\n      });\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitialized(\n      node: N.Node,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, {\n        at: node,\n        enumName,\n      });\n    }\n\n    flowEnumMemberInit(): EnumMemberInit {\n      const startLoc = this.state.startLoc;\n      const endOfInit = () => this.match(tt.comma) || this.match(tt.braceR);\n      switch (this.state.type) {\n        case tt.num: {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"number\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt.string: {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"string\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt._true:\n        case tt._false: {\n          const literal = this.parseBooleanLiteral(this.match(tt._true));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal,\n            };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        default:\n          return { type: \"invalid\", loc: startLoc };\n      }\n    }\n\n    flowEnumMemberRaw(): {\n      id: N.Node;\n      init: EnumMemberInit;\n    } {\n      const loc = this.state.startLoc;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(tt.eq)\n        ? this.flowEnumMemberInit()\n        : { type: \"none\" as const, loc };\n      return { id, init };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(\n      loc: Position,\n      context: EnumContext,\n      expectedType: EnumExplicitType,\n    ): void {\n      const { explicitType } = context;\n      if (explicitType === null) {\n        return;\n      }\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(loc, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType,\n    }: {\n      enumName: string;\n      explicitType: EnumExplicitType;\n    }): {\n      members: {\n        booleanMembers: Array<N.Node>;\n        numberMembers: Array<N.Node>;\n        stringMembers: Array<N.Node>;\n        defaultedMembers: Array<N.Node>;\n      };\n      hasUnknownMembers: boolean;\n    } {\n      const seenNames = new Set();\n      const members = {\n        // @ts-expect-error: migrate to Babel types\n        booleanMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        numberMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        stringMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        defaultedMembers: [],\n      };\n      let hasUnknownMembers = false;\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.ellipsis)) {\n          hasUnknownMembers = true;\n          break;\n        }\n        const memberNode = this.startNode();\n        const { id, init } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n        if (memberName === \"\") {\n          continue;\n        }\n        if (/^[a-z]/.test(memberName)) {\n          this.raise(FlowErrors.EnumInvalidMemberName, {\n            at: id,\n            memberName,\n            suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n            enumName,\n          });\n        }\n        if (seenNames.has(memberName)) {\n          this.raise(FlowErrors.EnumDuplicateMemberName, {\n            at: id,\n            memberName,\n            enumName,\n          });\n        }\n        seenNames.add(memberName);\n        const context = { enumName, explicitType, memberName };\n        memberNode.id = id;\n        switch (init.type) {\n          case \"boolean\": {\n            this.flowEnumCheckExplicitTypeMismatch(\n              init.loc,\n              context,\n              \"boolean\",\n            );\n            memberNode.init = init.value;\n            members.booleanMembers.push(\n              this.finishNode(memberNode, \"EnumBooleanMember\"),\n            );\n            break;\n          }\n          case \"number\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(\n              this.finishNode(memberNode, \"EnumNumberMember\"),\n            );\n            break;\n          }\n          case \"string\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(\n              this.finishNode(memberNode, \"EnumStringMember\"),\n            );\n            break;\n          }\n          case \"invalid\": {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n          case \"none\": {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(\n                  init.loc,\n                  context,\n                );\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(\n                  this.finishNode(memberNode, \"EnumDefaultedMember\"),\n                );\n            }\n          }\n        }\n\n        if (!this.match(tt.braceR)) {\n          this.expect(tt.comma);\n        }\n      }\n      return { members, hasUnknownMembers };\n    }\n\n    flowEnumStringMembers(\n      initializedMembers: Array<N.Node>,\n      defaultedMembers: Array<N.Node>,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): Array<N.Node> {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (const member of initializedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n            enumName,\n          });\n        }\n        return defaultedMembers;\n      } else {\n        for (const member of defaultedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n            enumName,\n          });\n        }\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName,\n    }: {\n      enumName: string;\n    }): EnumExplicitType {\n      if (!this.eatContextual(tt._of)) return null;\n\n      if (!tokenIsIdentifier(this.state.type)) {\n        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {\n          at: this.state.startLoc,\n          enumName,\n        });\n      }\n\n      const { value } = this.state;\n      this.next();\n\n      if (\n        value !== \"boolean\" &&\n        value !== \"number\" &&\n        value !== \"string\" &&\n        value !== \"symbol\"\n      ) {\n        this.raise(FlowErrors.EnumInvalidExplicitType, {\n          at: this.state.startLoc,\n          enumName,\n          invalidEnumType: value,\n        });\n      }\n\n      return value;\n    }\n\n    flowEnumBody(node: Undone<N.Node>, id: N.Node): N.Node {\n      const enumName = id.name;\n      const nameLoc = id.loc.start;\n      const explicitType = this.flowEnumParseExplicitType({ enumName });\n      this.expect(tt.braceL);\n      const { members, hasUnknownMembers } = this.flowEnumMembers({\n        enumName,\n        explicitType,\n      });\n      node.hasUnknownMembers = hasUnknownMembers;\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(\n            members.stringMembers,\n            members.defaultedMembers,\n            { enumName },\n          );\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n        default: {\n          // `explicitType` is `null`\n          const empty = () => {\n            node.members = [];\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(\n              members.stringMembers,\n              members.defaultedMembers,\n              { enumName },\n            );\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, {\n              at: nameLoc,\n              enumName,\n            });\n            return empty();\n          }\n        }\n      }\n    }\n\n    flowParseEnumDeclaration(node: Undone<N.Node>): N.Node {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), id);\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    // check if the next token is a tt.lt\n    isLookaheadToken_lt(): boolean {\n      const next = this.nextTokenStart();\n      if (this.input.charCodeAt(next) === charCodes.lessThan) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return (\n          afterNext !== charCodes.lessThan && afterNext !== charCodes.equalsTo\n        );\n      }\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node: N.Node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n  };\n", "const entities: {\n  __proto__: null;\n  [name: string]: string;\n} = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\",\n} as const;\nexport default entities;\n", "import * as charCodes from \"charcodes\";\n\nimport XHTMLEntities from \"./xhtml.ts\";\nimport type Parser from \"../../parser/index.ts\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport {\n  tokenComesBeforeExpression,\n  tokenIsKeyword,\n  tokenLabelName,\n  type TokenType,\n  tt,\n} from \"../../tokenizer/types.ts\";\nimport type { TokContext } from \"../../tokenizer/context.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport type * as N from \"../../types.ts\";\nimport { isIdentifierChar, isIdentifierStart } from \"../../util/identifier.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { isNewLine } from \"../../util/whitespace.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport type { Undone } from \"../../parser/node.ts\";\n\n/* eslint sort-keys: \"error\" */\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty:\n    \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({ openingTagName }: { openingTagName: string }) =>\n    `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression:\n    \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  // FIXME: Unify with Errors.UnexpectedToken\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity,\n  }: {\n    unexpected: string;\n    HTMLEntity: string;\n  }) =>\n    `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue:\n    \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements:\n    \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\",\n});\n\n/* eslint-disable sort-keys */\n\nfunction isFragment(object?: N.JSXElement | null): boolean {\n  return object\n    ? object.type === \"JSXOpeningFragment\" ||\n        object.type === \"JSXClosingFragment\"\n    : false;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(\n  object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,\n): string {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return (\n      getQualifiedJSXName(object.object) +\n      \".\" +\n      getQualifiedJSXName(object.property)\n    );\n  }\n\n  // istanbul ignore next\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nexport interface IJSXParserMixin {\n  jsxParseOpeningElementAfterName(\n    node: N.JSXOpeningElement,\n  ): N.JSXOpeningElement;\n}\n\nexport default (superClass: typeof Parser) =>\n  class JSXParserMixin extends superClass implements Parser, IJSXParserMixin {\n    // Reads inline JSX contents token.\n\n    jsxReadToken(): void {\n      let out = \"\";\n      let chunkStart = this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(JsxErrors.UnterminatedJsxContent, {\n            at: this.state.startLoc,\n          });\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n\n        switch (ch) {\n          case charCodes.lessThan:\n          case charCodes.leftCurlyBrace:\n            if (this.state.pos === this.state.start) {\n              if (ch === charCodes.lessThan && this.state.canStartJSXElement) {\n                ++this.state.pos;\n                this.finishToken(tt.jsxTagStart);\n              } else {\n                super.getTokenFromCode(ch);\n              }\n              return;\n            }\n            out += this.input.slice(chunkStart, this.state.pos);\n            this.finishToken(tt.jsxText, out);\n            return;\n\n          case charCodes.ampersand:\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadEntity();\n            chunkStart = this.state.pos;\n            break;\n\n          case charCodes.greaterThan:\n          case charCodes.rightCurlyBrace:\n            if (process.env.BABEL_8_BREAKING) {\n              this.raise(JsxErrors.UnexpectedToken, {\n                at: this.state.curPosition(),\n                unexpected: this.input[this.state.pos],\n                HTMLEntity:\n                  ch === charCodes.rightCurlyBrace ? \"&rbrace;\" : \"&gt;\",\n              });\n            }\n          /* falls through */\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.state.pos);\n              out += this.jsxReadNewLine(true);\n              chunkStart = this.state.pos;\n            } else {\n              ++this.state.pos;\n            }\n        }\n      }\n    }\n\n    jsxReadNewLine(normalizeCRLF: boolean): string {\n      const ch = this.input.charCodeAt(this.state.pos);\n      let out;\n      ++this.state.pos;\n      if (\n        ch === charCodes.carriageReturn &&\n        this.input.charCodeAt(this.state.pos) === charCodes.lineFeed\n      ) {\n        ++this.state.pos;\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      ++this.state.curLine;\n      this.state.lineStart = this.state.pos;\n\n      return out;\n    }\n\n    jsxReadString(quote: number): void {\n      let out = \"\";\n      let chunkStart = ++this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(Errors.UnterminatedString, {\n            at: this.state.startLoc,\n          });\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n        if (ch === quote) break;\n        if (ch === charCodes.ampersand) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(false);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.state.pos++);\n      this.finishToken(tt.string, out);\n    }\n\n    jsxReadEntity(): string {\n      const startPos = ++this.state.pos;\n      if (this.codePointAtPos(this.state.pos) === charCodes.numberSign) {\n        ++this.state.pos;\n\n        let radix = 10;\n        if (this.codePointAtPos(this.state.pos) === charCodes.lowercaseX) {\n          radix = 16;\n          ++this.state.pos;\n        }\n\n        const codePoint = this.readInt(\n          radix,\n          /* len */ undefined,\n          /* forceLen */ false,\n          /* allowNumSeparator */ \"bail\",\n        );\n        if (\n          codePoint !== null &&\n          this.codePointAtPos(this.state.pos) === charCodes.semicolon\n        ) {\n          ++this.state.pos;\n          return String.fromCodePoint(codePoint);\n        }\n      } else {\n        let count = 0;\n        let semi = false;\n        while (\n          count++ < 10 &&\n          this.state.pos < this.length &&\n          !(semi = this.codePointAtPos(this.state.pos) == charCodes.semicolon)\n        ) {\n          ++this.state.pos;\n        }\n\n        if (semi) {\n          const desc = this.input.slice(startPos, this.state.pos);\n          const entity = XHTMLEntities[desc];\n          ++this.state.pos;\n\n          if (entity) {\n            return entity;\n          }\n        }\n      }\n\n      // Not a valid entity\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can\"t contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsxReadWord(): void {\n      let ch;\n      const start = this.state.pos;\n      do {\n        ch = this.input.charCodeAt(++this.state.pos);\n      } while (isIdentifierChar(ch) || ch === charCodes.dash);\n      this.finishToken(tt.jsxName, this.input.slice(start, this.state.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsxParseIdentifier(): N.JSXIdentifier {\n      const node = this.startNode();\n      if (this.match(tt.jsxName)) {\n        node.name = this.state.value;\n      } else if (tokenIsKeyword(this.state.type)) {\n        node.name = tokenLabelName(this.state.type);\n      } else {\n        this.unexpected();\n      }\n      this.next();\n      return this.finishNode(node, \"JSXIdentifier\");\n    }\n\n    // Parse namespaced identifier.\n\n    jsxParseNamespacedName(): N.JSXNamespacedName {\n      const startLoc = this.state.startLoc;\n      const name = this.jsxParseIdentifier();\n      if (!this.eat(tt.colon)) return name;\n\n      const node = this.startNodeAt(startLoc);\n      node.namespace = name;\n      node.name = this.jsxParseIdentifier();\n      return this.finishNode(node, \"JSXNamespacedName\");\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsxParseElementName():\n      | N.JSXIdentifier\n      | N.JSXNamespacedName\n      | N.JSXMemberExpression {\n      const startLoc = this.state.startLoc;\n      let node = this.jsxParseNamespacedName();\n      if (node.type === \"JSXNamespacedName\") {\n        return node;\n      }\n      while (this.eat(tt.dot)) {\n        const newNode = this.startNodeAt(startLoc);\n        newNode.object = node;\n        newNode.property = this.jsxParseIdentifier();\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsxParseAttributeValue(): N.Expression {\n      let node;\n      switch (this.state.type) {\n        case tt.braceL:\n          node = this.startNode();\n          this.setContext(tc.brace);\n          this.next();\n          node = this.jsxParseExpressionContainer(node, tc.j_oTag);\n          if (node.expression.type === \"JSXEmptyExpression\") {\n            this.raise(JsxErrors.AttributeIsEmpty, { at: node });\n          }\n          return node;\n\n        case tt.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n\n        default:\n          throw this.raise(JsxErrors.UnsupportedJsxValue, {\n            at: this.state.startLoc,\n          });\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsxParseEmptyExpression(): N.JSXEmptyExpression {\n      const node = this.startNodeAt(this.state.lastTokEndLoc);\n      return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n    }\n\n    // Parse JSX spread child\n\n    jsxParseSpreadChild(node: Undone<N.JSXSpreadChild>): N.JSXSpreadChild {\n      this.next(); // ellipsis\n      node.expression = this.parseExpression();\n      this.setContext(tc.j_expr);\n      this.state.canStartJSXElement = true;\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXSpreadChild\");\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsxParseExpressionContainer(\n      node: Undone<N.JSXExpressionContainer>,\n      previousContext: TokContext,\n    ): N.JSXExpressionContainer {\n      if (this.match(tt.braceR)) {\n        node.expression = this.jsxParseEmptyExpression();\n      } else {\n        const expression = this.parseExpression();\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            expression.type === \"SequenceExpression\" &&\n            !expression.extra?.parenthesized\n          ) {\n            this.raise(JsxErrors.UnexpectedSequenceExpression, {\n              at: expression.expressions[1],\n            });\n          }\n        }\n\n        node.expression = expression;\n      }\n      this.setContext(previousContext);\n      this.state.canStartJSXElement = true;\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXExpressionContainer\");\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsxParseAttribute(): N.JSXAttribute {\n      const node = this.startNode();\n      if (this.match(tt.braceL)) {\n        this.setContext(tc.brace);\n        this.next();\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssignAllowIn();\n        this.setContext(tc.j_oTag);\n        this.state.canStartJSXElement = true;\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"JSXSpreadAttribute\");\n      }\n      node.name = this.jsxParseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;\n      return this.finishNode(node, \"JSXAttribute\");\n    }\n\n    // Parses JSX opening tag starting after \"<\".\n\n    jsxParseOpeningElementAt(startLoc: Position): N.JSXOpeningElement {\n      const node = this.startNodeAt<N.JSXOpeningElement | N.JSXOpeningFragment>(\n        startLoc,\n      );\n      if (this.eat(tt.jsxTagEnd)) {\n        // @ts-expect-error migrate to Babel types\n        return this.finishNode(node, \"JSXOpeningFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      return this.jsxParseOpeningElementAfterName(\n        node as Undone<N.JSXOpeningElement>,\n      );\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: Undone<N.JSXOpeningElement>,\n    ): N.JSXOpeningElement {\n      const attributes: N.JSXAttribute[] = [];\n      while (!this.match(tt.slash) && !this.match(tt.jsxTagEnd)) {\n        attributes.push(this.jsxParseAttribute());\n      }\n      node.attributes = attributes;\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningElement\");\n    }\n\n    // Parses JSX closing tag starting after \"</\".\n\n    jsxParseClosingElementAt(startLoc: Position): N.JSXClosingElement {\n      const node = this.startNodeAt(startLoc);\n      if (this.eat(tt.jsxTagEnd)) {\n        return this.finishNode(node, \"JSXClosingFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingElement\");\n    }\n\n    // Parses entire JSX element, including it\"s opening tag\n    // (starting after \"<\"), attributes, contents and closing tag.\n\n    jsxParseElementAt(startLoc: Position): N.JSXElement {\n      const node = this.startNodeAt(startLoc);\n      const children = [];\n      const openingElement = this.jsxParseOpeningElementAt(startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.state.type) {\n            case tt.jsxTagStart:\n              startLoc = this.state.startLoc;\n              this.next();\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsxParseClosingElementAt(startLoc);\n                break contents;\n              }\n              children.push(this.jsxParseElementAt(startLoc));\n              break;\n\n            case tt.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n\n            case tt.braceL: {\n              const node = this.startNode<\n                N.JSXSpreadChild | N.JSXExpressionContainer\n              >();\n              this.setContext(tc.brace);\n              this.next();\n              if (this.match(tt.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(\n                  this.jsxParseExpressionContainer(node, tc.j_expr),\n                );\n              }\n\n              break;\n            }\n            // istanbul ignore next - should never happen\n            default:\n              this.unexpected();\n          }\n        }\n\n        if (\n          isFragment(openingElement) &&\n          !isFragment(closingElement) &&\n          closingElement !== null\n        ) {\n          this.raise(JsxErrors.MissingClosingTagFragment, {\n            at: closingElement,\n          });\n        } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n          this.raise(JsxErrors.MissingClosingTagElement, {\n            at: closingElement,\n            openingTagName: getQualifiedJSXName(openingElement.name),\n          });\n        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n          if (\n            getQualifiedJSXName(closingElement.name) !==\n            getQualifiedJSXName(openingElement.name)\n          ) {\n            this.raise(JsxErrors.MissingClosingTagElement, {\n              at: closingElement,\n              openingTagName: getQualifiedJSXName(openingElement.name),\n            });\n          }\n        }\n      }\n\n      if (isFragment(openingElement)) {\n        node.openingFragment = openingElement;\n        node.closingFragment = closingElement;\n      } else {\n        node.openingElement = openingElement;\n        node.closingElement = closingElement;\n      }\n      node.children = children;\n      if (this.match(tt.lt)) {\n        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {\n          at: this.state.startLoc,\n        });\n      }\n\n      return isFragment(openingElement)\n        ? this.finishNode(node, \"JSXFragment\")\n        : this.finishNode(node, \"JSXElement\");\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsxParseElement(): N.JSXElement {\n      const startLoc = this.state.startLoc;\n      this.next();\n      return this.jsxParseElementAt(startLoc);\n    }\n\n    setContext(newContext: TokContext) {\n      const { context } = this.state;\n      context[context.length - 1] = newContext;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseExprAtom(refExpressionErrors?: ExpressionErrors | null): N.Expression {\n      if (this.match(tt.jsxText)) {\n        return this.parseLiteral(this.state.value, \"JSXText\");\n      } else if (this.match(tt.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else if (\n        this.match(tt.lt) &&\n        this.input.charCodeAt(this.state.pos) !== charCodes.exclamationMark\n      ) {\n        // In case we encounter an lt token here it will always be the start of\n        // jsx as the lt sign is not allowed in places that expect an expression\n        this.replaceToken(tt.jsxTagStart);\n        return this.jsxParseElement();\n      } else {\n        return super.parseExprAtom(refExpressionErrors);\n      }\n    }\n\n    skipSpace() {\n      const curContext = this.curContext();\n      if (!curContext.preserveSpace) super.skipSpace();\n    }\n\n    getTokenFromCode(code: number): void {\n      const context = this.curContext();\n\n      if (context === tc.j_expr) {\n        this.jsxReadToken();\n        return;\n      }\n\n      if (context === tc.j_oTag || context === tc.j_cTag) {\n        if (isIdentifierStart(code)) {\n          this.jsxReadWord();\n          return;\n        }\n\n        if (code === charCodes.greaterThan) {\n          ++this.state.pos;\n          this.finishToken(tt.jsxTagEnd);\n          return;\n        }\n\n        if (\n          (code === charCodes.quotationMark || code === charCodes.apostrophe) &&\n          context === tc.j_oTag\n        ) {\n          this.jsxReadString(code);\n          return;\n        }\n      }\n\n      if (\n        code === charCodes.lessThan &&\n        this.state.canStartJSXElement &&\n        this.input.charCodeAt(this.state.pos + 1) !== charCodes.exclamationMark\n      ) {\n        ++this.state.pos;\n        this.finishToken(tt.jsxTagStart);\n        return;\n      }\n\n      super.getTokenFromCode(code);\n    }\n\n    updateContext(prevType: TokenType): void {\n      const { context, type } = this.state;\n      if (type === tt.slash && prevType === tt.jsxTagStart) {\n        // do not consider JSX expr -> JSX open tag -> ... anymore\n        // reconsider as closing tag context\n        context.splice(-2, 2, tc.j_cTag);\n        this.state.canStartJSXElement = false;\n      } else if (type === tt.jsxTagStart) {\n        // start opening tag context\n        context.push(tc.j_oTag);\n      } else if (type === tt.jsxTagEnd) {\n        const out = context[context.length - 1];\n        if ((out === tc.j_oTag && prevType === tt.slash) || out === tc.j_cTag) {\n          context.pop();\n          this.state.canStartJSXElement =\n            context[context.length - 1] === tc.j_expr;\n        } else {\n          this.setContext(tc.j_expr);\n          this.state.canStartJSXElement = true;\n        }\n      } else {\n        this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n      }\n    }\n  };\n", "import type { Position } from \"../../util/location.ts\";\nimport ScopeHandler, { Scope } from \"../../util/scope.ts\";\nimport {\n  BindingFlag,\n  ScopeFlag,\n  type BindingTypes,\n} from \"../../util/scopeflags.ts\";\nimport type * as N from \"../../types.ts\";\nimport { Errors } from \"../../parse-error.ts\";\n\nclass TypeScriptScope extends Scope {\n  types: Set<string> = new Set();\n\n  // enums (which are also in .types)\n  enums: Set<string> = new Set();\n\n  // const enums (which are also in .enums and .types)\n  constEnums: Set<string> = new Set();\n\n  // classes (which are also in .lexical) and interface (which are also in .types)\n  classes: Set<string> = new Set();\n\n  // namespaces and ambient functions (or classes) are too difficult to track,\n  // especially without type analysis.\n  // We need to track them anyway, to avoid \"X is not defined\" errors\n  // when exporting them.\n  exportOnlyBindings: Set<string> = new Set();\n}\n\n// See https://github.com/babel/babel/pull/9766#discussion_r268920730 for an\n// explanation of how typescript handles scope.\n\nexport default class TypeScriptScopeHandler extends ScopeHandler<TypeScriptScope> {\n  importsStack: Set<string>[] = [];\n\n  createScope(flags: ScopeFlag): TypeScriptScope {\n    this.importsStack.push(new Set()); // Always keep the top-level scope for export checks.\n\n    return new TypeScriptScope(flags);\n  }\n\n  enter(flags: ScopeFlag): void {\n    if (flags == ScopeFlag.TS_MODULE) {\n      this.importsStack.push(new Set());\n    }\n\n    super.enter(flags);\n  }\n\n  exit() {\n    const flags = super.exit();\n\n    if (flags == ScopeFlag.TS_MODULE) {\n      this.importsStack.pop();\n    }\n\n    return flags;\n  }\n\n  hasImport(name: string, allowShadow?: boolean) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n\n  declareName(name: string, bindingType: BindingTypes, loc: Position) {\n    if (bindingType & BindingFlag.FLAG_TS_IMPORT) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, {\n          at: loc,\n          identifierName: name,\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n\n    const scope = this.currentScope();\n    if (bindingType & BindingFlag.FLAG_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.add(name);\n      return;\n    }\n\n    super.declareName(name, bindingType, loc);\n\n    if (bindingType & BindingFlag.KIND_TYPE) {\n      if (!(bindingType & BindingFlag.KIND_VALUE)) {\n        // \"Value\" bindings have already been registered by the superclass.\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      scope.types.add(name);\n    }\n    if (bindingType & BindingFlag.FLAG_TS_ENUM) scope.enums.add(name);\n    if (bindingType & BindingFlag.FLAG_TS_CONST_ENUM) {\n      scope.constEnums.add(name);\n    }\n    if (bindingType & BindingFlag.FLAG_CLASS) scope.classes.add(name);\n  }\n\n  isRedeclaredInScope(\n    scope: TypeScriptScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (scope.enums.has(name)) {\n      if (bindingType & BindingFlag.FLAG_TS_ENUM) {\n        // Enums can be merged with other enums if they are both\n        //  const or both non-const.\n        const isConst = !!(bindingType & BindingFlag.FLAG_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.has(name);\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & BindingFlag.FLAG_CLASS && scope.classes.has(name)) {\n      if (scope.lexical.has(name)) {\n        // Classes can be merged with interfaces\n        return !!(bindingType & BindingFlag.KIND_VALUE);\n      } else {\n        // Interface can be merged with other classes or interfaces\n        return false;\n      }\n    }\n    if (bindingType & BindingFlag.KIND_TYPE && scope.types.has(name)) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    const { name } = id;\n\n    if (this.hasImport(name)) return;\n\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      if (scope.types.has(name) || scope.exportOnlyBindings.has(name)) return;\n    }\n\n    super.checkLocalExport(id);\n  }\n}\n", "import * as charCodes from \"charcodes\";\nimport { tt, type TokenType } from \"../tokenizer/types.ts\";\nimport type {\n  AssignmentPattern,\n  TSParameterProperty,\n  Decorator,\n  Expression,\n  Identifier,\n  Node,\n  Pattern,\n  RestElement,\n  SpreadElement,\n  ObjectOrClassMember,\n  ClassMember,\n  ObjectMember,\n  TsNamedTypeElementBase,\n  PrivateName,\n  ObjectExpression,\n  ObjectPattern,\n  ArrayExpression,\n  ArrayPattern,\n} from \"../types.ts\";\nimport type { Pos, Position } from \"../util/location.ts\";\nimport {\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n} from \"../util/identifier.ts\";\nimport { NodeUtils, type Undone } from \"./node.ts\";\nimport { type BindingTypes, BindingFlag } from \"../util/scopeflags.ts\";\nimport type { ExpressionErrors } from \"./util.ts\";\nimport { Errors, type LValAncestor } from \"../parse-error.ts\";\nimport type Parser from \"./index.ts\";\n\nconst getOwn = <T extends {}>(object: T, key: keyof T) =>\n  Object.hasOwnProperty.call(object, key) && object[key];\n\nconst unwrapParenthesizedExpression = (node: Node): Node => {\n  return node.type === \"ParenthesizedExpression\"\n    ? unwrapParenthesizedExpression(node.expression)\n    : node;\n};\n\nexport const enum ParseBindingListFlags {\n  ALLOW_EMPTY = 1 << 0,\n  IS_FUNCTION_PARAMS = 1 << 1,\n  IS_CONSTRUCTOR_PARAMS = 1 << 2,\n}\n\nexport default abstract class LValParser extends NodeUtils {\n  // Forward-declaration: defined in expression.js\n  abstract parseIdentifier(liberal?: boolean): Identifier;\n  abstract parseMaybeAssign(\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: Pos | null,\n  ): Expression;\n\n  abstract parseMaybeAssignAllowIn(\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: Pos | null,\n  ): Expression;\n\n  abstract parseObjectLike<T extends ObjectPattern | ObjectExpression>(\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): T;\n  abstract parseObjPropValue(\n    prop: any,\n    startLoc: Position | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void;\n  abstract parsePropertyName(\n    prop: ObjectOrClassMember | ClassMember | TsNamedTypeElementBase,\n  ): Expression | Identifier;\n  abstract parsePrivateName(): PrivateName;\n  // Forward-declaration: defined in statement.js\n  abstract parseDecorator(): Decorator;\n\n  /**\n   * Convert existing expression atom to assignable pattern\n   * if possible. Also checks invalid destructuring targets:\n   *\n   * - Parenthesized Destructuring patterns\n   * - RestElement is not the last element\n   * - Missing `=` in assignment pattern\n   *\n   * NOTE: There is a corresponding \"isAssignable\" method.\n   * When this one is updated, please check if also that one needs to be updated.\n   *\n   * @param node The expression atom\n   * @param isLHS Whether we are parsing a LeftHandSideExpression.\n   *              If isLHS is `true`, the following cases are allowed: `[(a)] = [0]`, `[(a.b)] = [0]`\n   *              If isLHS is `false`, we are in an arrow function parameters list.\n   */\n  toAssignable(node: Node, isLHS: boolean = false): void {\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || node.extra?.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        // an LHS can be reinterpreted to a binding pattern but not vice versa.\n        // therefore a parenthesized identifier is ambiguous until we are sure it is an assignment expression\n        // i.e. `([(a) = []] = []) => {}`\n        // see also `recordArrowParameterBindingError` signature in packages/babel-parser/src/util/expression-scope.js\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(\n            Errors.InvalidParenthesizedAssignment,\n            { at: node },\n          );\n        } else if (\n          parenthesized.type !== \"MemberExpression\" &&\n          !this.isOptionalMemberExpression(parenthesized)\n        ) {\n          // A parenthesized member expression can be in LHS but not in pattern.\n          // If the LHS is later interpreted as a pattern, `checkLVal` will throw for member expression binding\n          // i.e. `([(a.b) = []] = []) => {}`\n          this.raise(Errors.InvalidParenthesizedAssignment, { at: node });\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, { at: node });\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (\n          let i = 0, length = node.properties.length, last = length - 1;\n          i < length;\n          i++\n        ) {\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (\n            isLast &&\n            prop.type === \"RestElement\" &&\n            node.extra?.trailingCommaLoc\n          ) {\n            this.raise(Errors.RestTrailingComma, {\n              at: node.extra.trailingCommaLoc,\n            });\n          }\n        }\n        break;\n\n      case \"ObjectProperty\": {\n        const { key, value } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(\n            this.getPrivateNameSV(key),\n            key.loc.start,\n          );\n        }\n        this.toAssignable(value, isLHS);\n        break;\n      }\n\n      case \"SpreadElement\": {\n        throw new Error(\n          \"Internal @babel/parser error (this is a bug, please report it).\" +\n            \" SpreadElement should be converted by .toAssignable's caller.\",\n        );\n      }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(\n          node.elements,\n          node.extra?.trailingCommaLoc,\n          isLHS,\n        );\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, { at: node.left.loc.end });\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        /*::invariant (parenthesized !== undefined) */\n        this.toAssignable(parenthesized, isLHS);\n        break;\n\n      default:\n      // We don't know how to deal with this node. It will\n      // be reported by a later call to checkLVal\n    }\n  }\n\n  toAssignableObjectExpressionProp(\n    prop: Node,\n    isLast: boolean,\n    isLHS: boolean,\n  ) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(\n        prop.kind === \"get\" || prop.kind === \"set\"\n          ? Errors.PatternHasAccessor\n          : Errors.PatternHasMethod,\n        { at: prop.key },\n      );\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, /* allowPattern */ false);\n      this.toAssignable(arg, isLHS);\n\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, { at: prop });\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  // Convert list of expression atoms to binding list.\n\n  toAssignableList(\n    exprList: Expression[],\n    trailingCommaLoc: Position | undefined | null,\n    isLHS: boolean,\n  ): void {\n    const end = exprList.length - 1;\n\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, /* allowPattern */ true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, { at: elt });\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, { at: trailingCommaLoc });\n        }\n      }\n    }\n  }\n\n  isAssignable(node: Node, isBinding?: boolean): boolean {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n\n      case \"ObjectExpression\": {\n        const last = node.properties.length - 1;\n        return (node.properties as ObjectExpression[\"properties\"]).every(\n          (prop, i) => {\n            return (\n              prop.type !== \"ObjectMethod\" &&\n              (i === last || prop.type !== \"SpreadElement\") &&\n              this.isAssignable(prop)\n            );\n          },\n        );\n      }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return (node as ArrayExpression).elements.every(\n          element => element === null || this.isAssignable(element),\n        );\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  // Convert list of expression atoms to a list of\n\n  toReferencedList(\n    exprList: ReadonlyArray<Expression | undefined | null>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isParenthesizedExpr?: boolean,\n  ): ReadonlyArray<Expression | undefined | null> {\n    return exprList;\n  }\n\n  toReferencedListDeep(\n    exprList: ReadonlyArray<Expression | undefined | null>,\n    isParenthesizedExpr?: boolean,\n  ): void {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if (expr?.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  // Parses spread element.\n\n  parseSpread(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): SpreadElement {\n    const node = this.startNode<SpreadElement>();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(\n      refExpressionErrors,\n      undefined,\n    );\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  // https://tc39.es/ecma262/#prod-BindingRestElement\n  parseRestBinding(this: Parser): RestElement {\n    const node = this.startNode<RestElement>();\n    this.next(); // eat `...`\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  // Parses lvalue (assignable) atom.\n  parseBindingAtom(this: Parser): Pattern {\n    // https://tc39.es/ecma262/#prod-BindingPattern\n    switch (this.state.type) {\n      case tt.bracketL: {\n        const node = this.startNode<ArrayPattern>();\n        this.next();\n        // @ts-expect-error: Fixme: TSParameterProperty can not be assigned to node.elements\n        node.elements = this.parseBindingList(\n          tt.bracketR,\n          charCodes.rightSquareBracket,\n          ParseBindingListFlags.ALLOW_EMPTY,\n        );\n        return this.finishNode(node, \"ArrayPattern\");\n      }\n\n      case tt.braceL:\n        return this.parseObjectLike(tt.braceR, true);\n    }\n\n    // https://tc39.es/ecma262/#prod-BindingIdentifier\n    return this.parseIdentifier();\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingElementList\n  parseBindingList(\n    this: Parser,\n    close: TokenType,\n    closeCharCode: (typeof charCodes)[keyof typeof charCodes],\n    flags: ParseBindingListFlags,\n  ): Array<Pattern | TSParameterProperty> {\n    const allowEmpty = flags & ParseBindingListFlags.ALLOW_EMPTY;\n\n    const elts: Array<Pattern | TSParameterProperty> = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n      }\n      if (allowEmpty && this.match(tt.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(tt.ellipsis)) {\n        elts.push(\n          this.parseAssignableListItemTypes(this.parseRestBinding(), flags),\n        );\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(tt.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, {\n            at: this.state.startLoc,\n          });\n        }\n        // invariant: hasPlugin(\"decorators-legacy\")\n        while (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(flags, decorators));\n      }\n    }\n    return elts;\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  parseBindingRestProperty(\n    this: Parser,\n    prop: Undone<RestElement>,\n  ): RestElement {\n    this.next(); // eat '...'\n    // Don't use parseRestBinding() as we only allow Identifier here.\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(charCodes.rightCurlyBrace);\n    return this.finishNode(prop, \"RestElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingProperty\n  parseBindingProperty(this: Parser): ObjectMember | RestElement {\n    const prop = this.startNode<ObjectMember | RestElement>();\n    const { type, startLoc } = this.state;\n    if (type === tt.ellipsis) {\n      return this.parseBindingRestProperty(prop as Undone<RestElement>);\n    } else if (type === tt.privateName) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      (prop as Undone<ObjectMember>).key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop as Undone<ObjectMember>);\n    }\n    (prop as Undone<ObjectMember>).method = false;\n    return this.parseObjPropValue(\n      prop as Undone<ObjectMember>,\n      startLoc,\n      false /* isGenerator */,\n      false /* isAsync */,\n      true /* isPattern */,\n      false /* isAccessor */,\n    );\n  }\n\n  parseAssignableListItem(\n    this: Parser,\n    flags: ParseBindingListFlags,\n    decorators: Decorator[],\n  ): Pattern | TSParameterProperty {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left, flags);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n\n  // Used by flow/typescript plugin to add type annotations to binding elements\n  parseAssignableListItemTypes(\n    param: Pattern,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    flags: ParseBindingListFlags,\n  ): Pattern {\n    return param;\n  }\n\n  // Parses assignment pattern around given atom if possible.\n  // https://tc39.es/ecma262/#prod-BindingElement\n  parseMaybeDefault(\n    this: Parser,\n    startLoc?: Position | null,\n    left?: Pattern | null,\n  ): Pattern {\n    startLoc ??= this.state.startLoc;\n    left = left ?? this.parseBindingAtom();\n    if (!this.eat(tt.eq)) return left;\n\n    const node = this.startNodeAt<AssignmentPattern>(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  /**\n   * Return information use in determining whether a Node of a given type is an LVal,\n   * possibly given certain additional context information.\n   *\n   * Subclasser notes: This method has kind of a lot of mixed, but related,\n   * responsibilities. If we can definitively determine with the information\n   * provided that this either *is* or *isn't* a valid `LVal`, then the return\n   * value is easy: just return `true` or `false`. However, if it is a valid\n   * LVal *ancestor*, and thus its descendants must be subsequently visited to\n   * continue the \"investigation\", then this method should return the relevant\n   * child key as a `string`. In some special cases, you additionally want to\n   * convey that this node should be treated as if it were parenthesized. In\n   * that case, a tuple of [key: string, parenthesized: boolean] is returned.\n   * The `string`-only return option is actually just a shorthand for:\n   * `[key: string, parenthesized: false]`.\n   *\n   * @param type A Node `type` string\n   * @param isUnparenthesizedInAssign\n   *        Whether the node in question is unparenthesized and its parent\n   *        is either an assignment pattern or an assignment expression.\n   * @param binding\n   *        The binding operation that is being considered for this potential\n   *        LVal.\n   * @returns `true` or `false` if we can immediately determine whether the node\n   *          type in question can be treated as an `LVal`.\n   *          A `string` key to traverse if we must check this child.\n   *          A `[string, boolean]` tuple if we need to check this child and\n   *          treat is as parenthesized.\n   */\n  isValidLVal(\n    type: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isUnparenthesizedInAssign: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    binding: BindingTypes,\n  ): string | boolean {\n    return getOwn(\n      {\n        AssignmentPattern: \"left\",\n        RestElement: \"argument\",\n        ObjectProperty: \"value\",\n        ParenthesizedExpression: \"expression\",\n        ArrayPattern: \"elements\",\n        ObjectPattern: \"properties\",\n      },\n      // @ts-expect-error refine string to enum\n      type,\n    );\n  }\n\n  // Overridden by the estree plugin\n  isOptionalMemberExpression(expression: Node) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n\n  /**\n   * Verify that a target expression is an lval (something that can be assigned to).\n   *\n   * @param expression The expression in question to check.\n   * @param options A set of options described below.\n   * @param options.in\n   *        The relevant ancestor to provide context information for the error\n   *        if the check fails.\n   * @param options.binding\n   *        The desired binding type. If the given expression is an identifier\n   *        and `binding` is not `BindingFlag.TYPE_NONE`, `checkLVal` will register binding\n   *        to the parser scope See also `src/util/scopeflags.js`\n   * @param options.checkClashes\n   *        An optional string set to check if an identifier name is included.\n   *        `checkLVal` will add checked identifier name to `checkClashes` It is\n   *        used in tracking duplicates in function parameter lists. If it is\n   *        false, `checkLVal` will skip duplicate checks\n   * @param options.strictModeChanged\n   *        Whether an identifier has been parsed in a sloppy context but should\n   *        be reinterpreted as strict-mode. e.g. `(arguments) => { \"use strict \"}`\n   * @param options.hasParenthesizedAncestor\n   *        This is only used internally during recursive calls, and you should\n   *        not have to set it yourself.\n   */\n\n  checkLVal(\n    expression: Expression | ObjectMember | RestElement,\n    {\n      in: ancestor,\n      binding = BindingFlag.TYPE_NONE,\n      checkClashes = false,\n      strictModeChanged = false,\n      hasParenthesizedAncestor = false,\n    }: {\n      in: LValAncestor;\n      binding?: BindingTypes;\n      checkClashes?: Set<string> | false;\n      strictModeChanged?: boolean;\n      hasParenthesizedAncestor?: boolean;\n    },\n  ): void {\n    const type = expression.type;\n\n    // If we find here an ObjectMethod, it's because this was originally\n    // an ObjectExpression which has then been converted.\n    // toAssignable already reported this error with a nicer message.\n    if (this.isObjectMethod(expression)) return;\n\n    const isOptionalMemberExpression =\n      this.isOptionalMemberExpression(expression);\n\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, {\n            at: expression,\n            ancestor,\n          });\n        }\n      }\n\n      if (binding !== BindingFlag.TYPE_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, { at: expression });\n      }\n      return;\n    }\n\n    if (type === \"Identifier\") {\n      this.checkIdentifier(\n        expression as Identifier,\n        binding,\n        strictModeChanged,\n      );\n\n      const { name } = expression as Identifier;\n\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, { at: expression });\n        } else {\n          checkClashes.add(name);\n        }\n      }\n\n      return;\n    }\n\n    const validity = this.isValidLVal(\n      type,\n      !(hasParenthesizedAncestor || expression.extra?.parenthesized) &&\n        ancestor.type === \"AssignmentExpression\",\n      binding,\n    );\n\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass =\n        binding === BindingFlag.TYPE_NONE\n          ? Errors.InvalidLhs\n          : Errors.InvalidLhsBinding;\n\n      this.raise(ParseErrorClass, { at: expression, ancestor });\n      return;\n    }\n\n    const [key, isParenthesizedExpression] = Array.isArray(validity)\n      ? validity\n      : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor =\n      type === \"ArrayPattern\" || type === \"ObjectPattern\"\n        ? ({ type } as const)\n        : ancestor;\n\n    // @ts-expect-error key may not index expression.\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression,\n        });\n      }\n    }\n  }\n\n  checkIdentifier(\n    at: Identifier,\n    bindingType: BindingTypes,\n    strictModeChanged: boolean = false,\n  ) {\n    if (\n      this.state.strict &&\n      (strictModeChanged\n        ? isStrictBindReservedWord(at.name, this.inModule)\n        : isStrictBindOnlyReservedWord(at.name))\n    ) {\n      if (bindingType === BindingFlag.TYPE_NONE) {\n        this.raise(Errors.StrictEvalArguments, { at, referenceName: at.name });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, {\n          at,\n          bindingName: at.name,\n        });\n      }\n    }\n\n    if (bindingType & BindingFlag.FLAG_NO_LET_IN_LEXICAL && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, { at });\n    }\n\n    if (!(bindingType & BindingFlag.TYPE_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n\n  declareNameFromIdentifier(identifier: Identifier, binding: BindingTypes) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n\n  checkToRestConversion(node: Node, allowPattern: boolean): void {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      /* falls through */\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, { at: node });\n    }\n  }\n\n  checkCommaAfterRest(\n    close: (typeof charCodes)[keyof typeof charCodes],\n  ): boolean {\n    if (!this.match(tt.comma)) {\n      return false;\n    }\n\n    this.raise(\n      this.lookaheadCharCode() === close\n        ? Errors.RestTrailingComma\n        : Errors.ElementAfterRest,\n      { at: this.state.startLoc },\n    );\n\n    return true;\n  }\n}\n", "/*:: declare var invariant; */\n\nimport type State from \"../../tokenizer/state.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsTSDeclarationStart,\n  tokenIsTSTypeOperator,\n  tokenOperatorPrecedence,\n  tokenIsKeywordOrIdentifier,\n  tt,\n  type TokenType,\n  tokenIsTemplate,\n  tokenCanStartExpression,\n} from \"../../tokenizer/types.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport type * as N from \"../../types.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { createPositionWithColumnOffset } from \"../../util/location.ts\";\nimport type Parser from \"../../parser/index.ts\";\nimport {\n  type BindingTypes,\n  ScopeFlag,\n  BindingFlag,\n} from \"../../util/scopeflags.ts\";\nimport TypeScriptScopeHandler from \"./scope.ts\";\nimport * as charCodes from \"charcodes\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport type { ParseStatementFlag } from \"../../parser/statement.ts\";\nimport { ParamKind } from \"../../util/production-parameter.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node.ts\";\nimport type { Pattern } from \"../../types.ts\";\nimport type { Expression } from \"../../types.ts\";\nimport type { IJSXParserMixin } from \"../jsx/index.ts\";\nimport { ParseBindingListFlags } from \"../../parser/lval.ts\";\n\nconst getOwn = <T extends {}>(object: T, key: keyof T) =>\n  Object.hasOwnProperty.call(object, key) && object[key];\n\ntype TsModifier =\n  | \"readonly\"\n  | \"abstract\"\n  | \"declare\"\n  | \"static\"\n  | \"override\"\n  | \"const\"\n  | N.Accessibility\n  | N.VarianceAnnotations;\n\nfunction nonNull<T>(x?: T | null): T {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\n\nfunction assert(x: boolean): void {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\ntype ParsingContext =\n  | \"EnumMembers\"\n  | \"HeritageClauseElement\"\n  | \"TupleElementTypes\"\n  | \"TypeMembers\"\n  | \"TypeParametersOrArguments\";\n\ntype ModifierBase = {\n  accessibility?: N.Accessibility;\n} & {\n  [key in TsModifier]?: boolean | undefined | null;\n};\n\n/* eslint sort-keys: \"error\" */\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({ methodName }: { methodName: string }) =>\n    `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName,\n  }: {\n    propertyName: string;\n  }) =>\n    `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  // TODO: Accesor -> Accessor\n  AccesorCannotDeclareThisParameter:\n    \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  AccessorCannotBeOptional:\n    \"An 'accessor' property cannot be declared optional.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:\n    \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters:\n    \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({ kind }: { kind: \"get\" | \"set\" }) =>\n    `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer:\n    \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation:\n    \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier:\n    // `Accessibility modifier already seen: ${modifier}` would be more helpful.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ({ modifier }: { modifier: N.Accessibility }) =>\n      `Accessibility modifier already seen.`,\n  DuplicateModifier: ({ modifier }: { modifier: TsModifier }) =>\n    `Duplicate modifier: '${modifier}'.`,\n  // `token` matches the terminology used by typescript:\n  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915\n  EmptyHeritageClauseType: ({ token }: { token: \"extends\" | \"implements\" }) =>\n    `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare:\n    \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType:\n    \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers,\n  }: {\n    modifiers: [TsModifier, TsModifier];\n  }) =>\n    `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract:\n    \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier,\n  }: {\n    modifier: N.Accessibility;\n  }) =>\n    `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare:\n    \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride:\n    \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic:\n    \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext:\n    \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({ modifier }: { modifier: TsModifier }) =>\n    `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({ modifier }: { modifier: TsModifier }) =>\n    `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier,\n  }: {\n    modifier: TsModifier;\n  }) =>\n    `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers,\n  }: {\n    orderedModifiers: [TsModifier, TsModifier];\n  }) =>\n    `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression:\n    \"Invalid property access after an instantiation expression. \" +\n    \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel:\n    \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName:\n    \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod:\n    \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer:\n    \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired:\n    \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass:\n    \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional:\n    \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract:\n    \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier,\n  }: {\n    modifier: N.Accessibility;\n  }) =>\n    `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature:\n    \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam:\n    \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion:\n    \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  // TODO: Accesor -> Accessor\n  SetAccesorCannotHaveOptionalParameter:\n    \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter:\n    \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType:\n    \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName,\n  }: {\n    typeParameterName: string;\n  }) =>\n    `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier:\n    \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType:\n    \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed:\n    \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports:\n    \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports:\n    \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier:\n    \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly:\n    \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument:\n    \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind:\n    \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({ type }: { type: string }) =>\n    `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,\n});\n\n/* eslint-disable sort-keys */\n\n// Doesn't handle \"void\" or \"null\" because those are keywords, not identifiers.\n// It also doesn't handle \"intrinsic\", since usually it's not a keyword.\nfunction keywordTypeFromName(value: string): N.TsKeywordTypeType | undefined {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier: string): modifier is N.Accessibility {\n  return (\n    modifier === \"private\" || modifier === \"public\" || modifier === \"protected\"\n  );\n}\n\nfunction tsIsVarianceAnnotations(\n  modifier: string,\n): modifier is N.VarianceAnnotations {\n  return modifier === \"in\" || modifier === \"out\";\n}\n\ntype ClassWithMixin<\n  T extends new (...args: any) => any,\n  M extends object,\n> = T extends new (...args: infer P) => infer I\n  ? new (...args: P) => I & M\n  : never;\n\nexport default (superClass: ClassWithMixin<typeof Parser, IJSXParserMixin>) =>\n  class TypeScriptParserMixin extends superClass implements Parser {\n    getScopeHandler(): {\n      new (...args: any): TypeScriptScopeHandler;\n    } {\n      return TypeScriptScopeHandler;\n    }\n\n    tsIsIdentifier(): boolean {\n      // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n      // See https://github.com/Microsoft/TypeScript/issues/15008\n      return tokenIsIdentifier(this.state.type);\n    }\n\n    tsTokenCanFollowModifier() {\n      return (\n        (this.match(tt.bracketL) ||\n          this.match(tt.braceL) ||\n          this.match(tt.star) ||\n          this.match(tt.ellipsis) ||\n          this.match(tt.privateName) ||\n          this.isLiteralPropertyName()) &&\n        !this.hasPrecedingLineBreak()\n      );\n    }\n\n    tsNextTokenCanFollowModifier() {\n      // Note: TypeScript's implementation is much more complicated because\n      // more things are considered modifiers there.\n      // This implementation only handles modifiers not handled by @babel/parser itself. And \"static\".\n      // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n\n    /** Parses a modifier matching one the given modifier names. */\n    tsParseModifier<T extends TsModifier>(\n      allowedModifiers: T[],\n      stopOnStartOfClassStaticBlock?: boolean,\n    ): T | undefined | null {\n      if (\n        !tokenIsIdentifier(this.state.type) &&\n        this.state.type !== tt._in &&\n        this.state.type !== tt._const\n      ) {\n        return undefined;\n      }\n\n      const modifier = this.state.value;\n      if (allowedModifiers.indexOf(modifier) !== -1) {\n        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n          return undefined;\n        }\n        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n          return modifier;\n        }\n      }\n      return undefined;\n    }\n\n    /** Parses a list of modifiers, in any order.\n     *  If you need a specific order, you must call this function multiple times:\n     *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"public\"] });\n     *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"abstract\", \"readonly\"] });\n     */\n    tsParseModifiers<N extends ModifierBase>(\n      {\n        allowedModifiers,\n        disallowedModifiers,\n        stopOnStartOfClassStaticBlock,\n        errorTemplate = TSErrors.InvalidModifierOnTypeMember,\n      }: {\n        allowedModifiers: readonly TsModifier[];\n        disallowedModifiers?: TsModifier[];\n        stopOnStartOfClassStaticBlock?: boolean;\n        errorTemplate?: typeof TSErrors.InvalidModifierOnTypeMember;\n      },\n      modified: N,\n    ): void {\n      const enforceOrder = (\n        loc: Position,\n        modifier: TsModifier,\n        before: TsModifier,\n        after: TsModifier,\n      ) => {\n        if (modifier === before && modified[after]) {\n          this.raise(TSErrors.InvalidModifiersOrder, {\n            at: loc,\n            orderedModifiers: [before, after],\n          });\n        }\n      };\n      const incompatible = (\n        loc: Position,\n        modifier: TsModifier,\n        mod1: TsModifier,\n        mod2: TsModifier,\n      ) => {\n        if (\n          (modified[mod1] && modifier === mod2) ||\n          (modified[mod2] && modifier === mod1)\n        ) {\n          this.raise(TSErrors.IncompatibleModifiers, {\n            at: loc,\n            modifiers: [mod1, mod2],\n          });\n        }\n      };\n\n      for (;;) {\n        const { startLoc } = this.state;\n        const modifier: TsModifier | undefined | null = this.tsParseModifier(\n          allowedModifiers.concat(disallowedModifiers ?? []),\n          stopOnStartOfClassStaticBlock,\n        );\n\n        if (!modifier) break;\n\n        if (tsIsAccessModifier(modifier)) {\n          if (modified.accessibility) {\n            this.raise(TSErrors.DuplicateAccessibilityModifier, {\n              at: startLoc,\n              modifier,\n            });\n          } else {\n            enforceOrder(startLoc, modifier, modifier, \"override\");\n            enforceOrder(startLoc, modifier, modifier, \"static\");\n            enforceOrder(startLoc, modifier, modifier, \"readonly\");\n\n            modified.accessibility = modifier;\n          }\n        } else if (tsIsVarianceAnnotations(modifier)) {\n          if (modified[modifier]) {\n            this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier });\n          }\n          modified[modifier] = true;\n\n          enforceOrder(startLoc, modifier, \"in\", \"out\");\n        } else {\n          if (Object.hasOwnProperty.call(modified, modifier)) {\n            this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier });\n          } else {\n            enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n            enforceOrder(startLoc, modifier, \"static\", \"override\");\n            enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n            enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n\n            incompatible(startLoc, modifier, \"declare\", \"override\");\n            incompatible(startLoc, modifier, \"static\", \"abstract\");\n          }\n          modified[modifier] = true;\n        }\n\n        if (disallowedModifiers?.includes(modifier)) {\n          this.raise(errorTemplate, {\n            at: startLoc,\n            modifier,\n          });\n        }\n      }\n    }\n\n    tsIsListTerminator(kind: ParsingContext): boolean {\n      switch (kind) {\n        case \"EnumMembers\":\n        case \"TypeMembers\":\n          return this.match(tt.braceR);\n        case \"HeritageClauseElement\":\n          return this.match(tt.braceL);\n        case \"TupleElementTypes\":\n          return this.match(tt.bracketR);\n        case \"TypeParametersOrArguments\":\n          return this.match(tt.gt);\n      }\n    }\n\n    tsParseList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n    ): T[] {\n      const result: T[] = [];\n      while (!this.tsIsListTerminator(kind)) {\n        // Skipping \"parseListElement\" from the TS source since that's just for error handling.\n        result.push(parseElement());\n      }\n      return result;\n    }\n\n    tsParseDelimitedList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] {\n      return nonNull(\n        this.tsParseDelimitedListWorker(\n          kind,\n          parseElement,\n          /* expectSuccess */ true,\n          refTrailingCommaPos,\n        ),\n      );\n    }\n\n    /**\n     * If !expectSuccess, returns undefined instead of failing to parse.\n     * If expectSuccess, parseElement should always return a defined value.\n     */\n    tsParseDelimitedListWorker<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T | undefined | null,\n      expectSuccess: boolean,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] | undefined | null {\n      const result = [];\n      let trailingCommaPos = -1;\n\n      for (;;) {\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n        trailingCommaPos = -1;\n\n        const element = parseElement();\n        if (element == null) {\n          return undefined;\n        }\n        result.push(element);\n\n        if (this.eat(tt.comma)) {\n          trailingCommaPos = this.state.lastTokStart;\n          continue;\n        }\n\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        if (expectSuccess) {\n          // This will fail with an error about a missing comma\n          this.expect(tt.comma);\n        }\n        return undefined;\n      }\n\n      if (refTrailingCommaPos) {\n        refTrailingCommaPos.value = trailingCommaPos;\n      }\n\n      return result;\n    }\n\n    tsParseBracketedList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      bracket: boolean,\n      skipFirstToken: boolean,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] {\n      if (!skipFirstToken) {\n        if (bracket) {\n          this.expect(tt.bracketL);\n        } else {\n          this.expect(tt.lt);\n        }\n      }\n\n      const result = this.tsParseDelimitedList(\n        kind,\n        parseElement,\n        refTrailingCommaPos,\n      );\n\n      if (bracket) {\n        this.expect(tt.bracketR);\n      } else {\n        this.expect(tt.gt);\n      }\n\n      return result;\n    }\n\n    tsParseImportType(): N.TsImportType {\n      const node = this.startNode<N.TsImportType>();\n      this.expect(tt._import);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.raise(TSErrors.UnsupportedImportTypeArgument, {\n          at: this.state.startLoc,\n        });\n      }\n\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.argument = super.parseExprAtom() as N.StringLiteral;\n      this.expect(tt.parenR);\n\n      if (this.eat(tt.dot)) {\n        // In this instance, the entity name will actually itself be a\n        // qualifier, so allow it to be a reserved word as well.\n        node.qualifier = this.tsParseEntityName();\n      }\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSImportType\");\n    }\n\n    tsParseEntityName(allowReservedWords: boolean = true): N.TsEntityName {\n      let entity: N.TsEntityName = this.parseIdentifier(allowReservedWords);\n      while (this.eat(tt.dot)) {\n        const node: Undone<N.TsQualifiedName> =\n          this.startNodeAtNode<N.TsQualifiedName>(entity);\n        node.left = entity;\n        node.right = this.parseIdentifier(allowReservedWords);\n        entity = this.finishNode(node, \"TSQualifiedName\");\n      }\n      return entity;\n    }\n\n    tsParseTypeReference(): N.TsTypeReference {\n      const node = this.startNode<N.TsTypeReference>();\n      node.typeName = this.tsParseEntityName();\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSTypeReference\");\n    }\n\n    tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {\n      this.next();\n      const node = this.startNodeAtNode<N.TsTypePredicate>(lhs);\n      node.parameterName = lhs;\n      node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);\n      node.asserts = false;\n      return this.finishNode(node, \"TSTypePredicate\");\n    }\n\n    tsParseThisTypeNode(): N.TsThisType {\n      const node = this.startNode<N.TsThisType>();\n      this.next();\n      return this.finishNode(node, \"TSThisType\");\n    }\n\n    tsParseTypeQuery(): N.TsTypeQuery {\n      const node = this.startNode<N.TsTypeQuery>();\n      this.expect(tt._typeof);\n      if (this.match(tt._import)) {\n        node.exprName = this.tsParseImportType();\n      } else {\n        node.exprName = this.tsParseEntityName();\n      }\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSTypeQuery\");\n    }\n\n    tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\n        \"const\",\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"readonly\",\n        \"declare\",\n        \"abstract\",\n        \"override\",\n      ],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter,\n    });\n\n    tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      // for better error recovery\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,\n    });\n\n    tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"readonly\",\n        \"declare\",\n        \"abstract\",\n        \"override\",\n      ],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter,\n    });\n\n    tsParseTypeParameter(\n      parseModifiers: (node: Undone<N.TsTypeParameter>) => void,\n    ): N.TsTypeParameter {\n      const node = this.startNode<N.TsTypeParameter>();\n\n      parseModifiers(node);\n\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsEatThenParseType(tt._extends);\n      node.default = this.tsEatThenParseType(tt.eq);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsTryParseTypeParameters(\n      parseModifiers: (node: N.TsTypeParameter) => void,\n    ): N.TsTypeParameterDeclaration | undefined | null {\n      if (this.match(tt.lt)) {\n        return this.tsParseTypeParameters(parseModifiers);\n      }\n    }\n\n    tsParseTypeParameters(parseModifiers: (node: N.TsTypeParameter) => void) {\n      const node = this.startNode<N.TsTypeParameterDeclaration>();\n\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      const refTrailingCommaPos = { value: -1 };\n\n      node.params = this.tsParseBracketedList(\n        \"TypeParametersOrArguments\",\n        // @ts-expect-error refine typings\n        this.tsParseTypeParameter.bind(this, parseModifiers),\n        /* bracket */ false,\n        /* skipFirstToken */ true,\n        refTrailingCommaPos,\n      );\n      if (node.params.length === 0) {\n        this.raise(TSErrors.EmptyTypeParameters, { at: node });\n      }\n      if (refTrailingCommaPos.value !== -1) {\n        this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n      }\n      return this.finishNode(node, \"TSTypeParameterDeclaration\");\n    }\n\n    // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n    // but here it's always false, because this is only used for types.\n    tsFillSignature(\n      returnToken: TokenType,\n      signature: Undone<N.TsSignatureDeclaration>,\n    ): void {\n      // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n      const returnTokenRequired = returnToken === tt.arrow;\n\n      // https://github.com/babel/babel/issues/9231\n      const paramsKey = process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\";\n      const returnTypeKey = process.env.BABEL_8_BREAKING\n        ? \"returnType\"\n        : \"typeAnnotation\";\n\n      signature.typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      this.expect(tt.parenL);\n      signature[paramsKey] = this.tsParseBindingListForSignature();\n      if (returnTokenRequired) {\n        signature[returnTypeKey] =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      } else if (this.match(returnToken)) {\n        signature[returnTypeKey] =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      }\n    }\n\n    tsParseBindingListForSignature(): Array<\n      N.Identifier | N.RestElement | N.ObjectPattern | N.ArrayPattern\n    > {\n      const list = super.parseBindingList(\n        tt.parenR,\n        charCodes.rightParenthesis,\n        ParseBindingListFlags.IS_FUNCTION_PARAMS,\n      );\n      for (const pattern of list) {\n        const { type } = pattern;\n        if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n          this.raise(TSErrors.UnsupportedSignatureParameterKind, {\n            at: pattern,\n            type,\n          });\n        }\n      }\n      return list as Exclude<\n        (typeof list)[0],\n        N.AssignmentPattern | N.TSParameterProperty\n      >[];\n    }\n\n    tsParseTypeMemberSemicolon(): void {\n      if (!this.eat(tt.comma) && !this.isLineTerminator()) {\n        this.expect(tt.semi);\n      }\n    }\n\n    tsParseSignatureMember(\n      kind: \"TSCallSignatureDeclaration\" | \"TSConstructSignatureDeclaration\",\n      node: Undone<\n        N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration\n      >,\n    ): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {\n      this.tsFillSignature(tt.colon, node);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, kind);\n    }\n\n    tsIsUnambiguouslyIndexSignature() {\n      this.next(); // Skip '{'\n      if (tokenIsIdentifier(this.state.type)) {\n        this.next();\n        return this.match(tt.colon);\n      }\n      return false;\n    }\n\n    tsTryParseIndexSignature(\n      node: Undone<N.TsIndexSignature>,\n    ): N.TsIndexSignature | undefined {\n      if (\n        !(\n          this.match(tt.bracketL) &&\n          this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))\n        )\n      ) {\n        return;\n      }\n\n      this.expect(tt.bracketL);\n      const id = this.parseIdentifier();\n      id.typeAnnotation = this.tsParseTypeAnnotation();\n      this.resetEndLocation(id); // set end position to end of type\n\n      this.expect(tt.bracketR);\n      node.parameters = [id];\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, \"TSIndexSignature\");\n    }\n\n    tsParsePropertyOrMethodSignature(\n      node: N.TsPropertySignature | N.TsMethodSignature,\n      readonly: boolean,\n    ): N.TsPropertySignature | N.TsMethodSignature {\n      if (this.eat(tt.question)) node.optional = true;\n      const nodeAny: any = node;\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        if (readonly) {\n          this.raise(TSErrors.ReadonlyForMethodSignature, { at: node });\n        }\n        const method: N.TsMethodSignature = nodeAny;\n        if (method.kind && this.match(tt.lt)) {\n          this.raise(TSErrors.AccesorCannotHaveTypeParameters, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.tsFillSignature(tt.colon, method);\n        this.tsParseTypeMemberSemicolon();\n        const paramsKey = process.env.BABEL_8_BREAKING\n          ? \"params\"\n          : \"parameters\";\n        const returnTypeKey = process.env.BABEL_8_BREAKING\n          ? \"returnType\"\n          : \"typeAnnotation\";\n        if (method.kind === \"get\") {\n          if (method[paramsKey].length > 0) {\n            this.raise(Errors.BadGetterArity, { at: this.state.curPosition() });\n            if (this.isThisParam(method[paramsKey][0])) {\n              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n          }\n        } else if (method.kind === \"set\") {\n          if (method[paramsKey].length !== 1) {\n            this.raise(Errors.BadSetterArity, { at: this.state.curPosition() });\n          } else {\n            const firstParameter = method[paramsKey][0];\n            if (this.isThisParam(firstParameter)) {\n              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n            if (\n              firstParameter.type === \"Identifier\" &&\n              firstParameter.optional\n            ) {\n              this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n            if (firstParameter.type === \"RestElement\") {\n              this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n          }\n          if (method[returnTypeKey]) {\n            this.raise(TSErrors.SetAccesorCannotHaveReturnType, {\n              at: method[returnTypeKey],\n            });\n          }\n        } else {\n          method.kind = \"method\";\n        }\n        return this.finishNode(method, \"TSMethodSignature\");\n      } else {\n        const property: N.TsPropertySignature = nodeAny;\n        if (readonly) property.readonly = true;\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) property.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(property, \"TSPropertySignature\");\n      }\n    }\n\n    tsParseTypeMember(): N.TsTypeElement {\n      const node: any = this.startNode();\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n      }\n\n      if (this.match(tt._new)) {\n        const id = this.startNode<N.Identifier>();\n        this.next();\n        if (this.match(tt.parenL) || this.match(tt.lt)) {\n          return this.tsParseSignatureMember(\n            \"TSConstructSignatureDeclaration\",\n            node,\n          );\n        } else {\n          node.key = this.createIdentifier(id, \"new\");\n          return this.tsParsePropertyOrMethodSignature(node, false);\n        }\n      }\n\n      this.tsParseModifiers(\n        {\n          allowedModifiers: [\"readonly\"],\n          disallowedModifiers: [\n            \"declare\",\n            \"abstract\",\n            \"private\",\n            \"protected\",\n            \"public\",\n            \"static\",\n            \"override\",\n          ],\n        },\n        node,\n      );\n\n      const idx = this.tsTryParseIndexSignature(node);\n      if (idx) {\n        return idx;\n      }\n\n      super.parsePropertyName(node);\n      if (\n        !node.computed &&\n        node.key.type === \"Identifier\" &&\n        (node.key.name === \"get\" || node.key.name === \"set\") &&\n        this.tsTokenCanFollowModifier()\n      ) {\n        node.kind = node.key.name;\n        super.parsePropertyName(node);\n      }\n      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n    }\n\n    tsParseTypeLiteral(): N.TsTypeLiteral {\n      const node = this.startNode<N.TsTypeLiteral>();\n      node.members = this.tsParseObjectTypeMembers();\n      return this.finishNode(node, \"TSTypeLiteral\");\n    }\n\n    tsParseObjectTypeMembers(): Array<N.TsTypeElement> {\n      this.expect(tt.braceL);\n      const members = this.tsParseList(\n        \"TypeMembers\",\n        this.tsParseTypeMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return members;\n    }\n\n    tsIsStartOfMappedType(): boolean {\n      this.next();\n      if (this.eat(tt.plusMin)) {\n        return this.isContextual(tt._readonly);\n      }\n      if (this.isContextual(tt._readonly)) {\n        this.next();\n      }\n      if (!this.match(tt.bracketL)) {\n        return false;\n      }\n      this.next();\n      if (!this.tsIsIdentifier()) {\n        return false;\n      }\n      this.next();\n      return this.match(tt._in);\n    }\n\n    tsParseMappedTypeParameter(): N.TsTypeParameter {\n      const node = this.startNode<N.TsTypeParameter>();\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsExpectThenParseType(tt._in);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsParseMappedType(): N.TsMappedType {\n      const node = this.startNode<N.TsMappedType>();\n\n      this.expect(tt.braceL);\n\n      if (this.match(tt.plusMin)) {\n        node.readonly = this.state.value;\n        this.next();\n        this.expectContextual(tt._readonly);\n      } else if (this.eatContextual(tt._readonly)) {\n        node.readonly = true;\n      }\n\n      this.expect(tt.bracketL);\n      node.typeParameter = this.tsParseMappedTypeParameter();\n      node.nameType = this.eatContextual(tt._as) ? this.tsParseType() : null;\n\n      this.expect(tt.bracketR);\n\n      if (this.match(tt.plusMin)) {\n        node.optional = this.state.value;\n        this.next();\n        this.expect(tt.question);\n      } else if (this.eat(tt.question)) {\n        node.optional = true;\n      }\n\n      node.typeAnnotation = this.tsTryParseType();\n      this.semicolon();\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"TSMappedType\");\n    }\n\n    tsParseTupleType(): N.TsTupleType {\n      const node = this.startNode<N.TsTupleType>();\n      node.elementTypes = this.tsParseBracketedList(\n        \"TupleElementTypes\",\n        this.tsParseTupleElementType.bind(this),\n        /* bracket */ true,\n        /* skipFirstToken */ false,\n      );\n\n      // Validate the elementTypes to ensure that no mandatory elements\n      // follow optional elements\n      let seenOptionalElement = false;\n      node.elementTypes.forEach(elementNode => {\n        const { type } = elementNode;\n\n        if (\n          seenOptionalElement &&\n          type !== \"TSRestType\" &&\n          type !== \"TSOptionalType\" &&\n          !(type === \"TSNamedTupleMember\" && elementNode.optional)\n        ) {\n          this.raise(TSErrors.OptionalTypeBeforeRequired, {\n            at: elementNode,\n          });\n        }\n\n        seenOptionalElement ||=\n          (type === \"TSNamedTupleMember\" && elementNode.optional) ||\n          type === \"TSOptionalType\";\n      });\n\n      return this.finishNode(node, \"TSTupleType\");\n    }\n\n    tsParseTupleElementType(): N.TsNamedTupleMember | N.TsType {\n      // parses `...TsType[]`\n\n      const { startLoc } = this.state;\n\n      const rest = this.eat(tt.ellipsis);\n\n      let labeled: boolean;\n      let label: N.Identifier;\n      let optional: boolean;\n      let type: N.TsNamedTupleMember | N.TsType;\n\n      const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n      const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n      if (chAfterWord === charCodes.colon) {\n        labeled = true;\n        optional = false;\n        label = this.parseIdentifier(true);\n        this.expect(tt.colon);\n        type = this.tsParseType();\n      } else if (chAfterWord === charCodes.questionMark) {\n        optional = true;\n        const startLoc = this.state.startLoc;\n        const wordName = this.state.value;\n        const typeOrLabel = this.tsParseNonArrayType();\n\n        if (this.lookaheadCharCode() === charCodes.colon) {\n          labeled = true;\n          label = this.createIdentifier(\n            this.startNodeAt<N.Identifier>(startLoc),\n            wordName,\n          );\n          this.expect(tt.question);\n          this.expect(tt.colon);\n          type = this.tsParseType();\n        } else {\n          labeled = false;\n          type = typeOrLabel;\n          this.expect(tt.question);\n        }\n      } else {\n        type = this.tsParseType();\n        optional = this.eat(tt.question);\n        // In this case (labeled === true) could be only in invalid label.\n        // E.g. [x.y:type]\n        // An error is raised while processing node.\n        labeled = this.eat(tt.colon);\n      }\n\n      if (labeled) {\n        let labeledNode: Undone<N.TsNamedTupleMember>;\n        if (label) {\n          labeledNode = this.startNodeAtNode<N.TsNamedTupleMember>(label);\n          labeledNode.optional = optional;\n          labeledNode.label = label;\n          labeledNode.elementType = type;\n\n          if (this.eat(tt.question)) {\n            labeledNode.optional = true;\n            this.raise(TSErrors.TupleOptionalAfterType, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n        } else {\n          labeledNode = this.startNodeAtNode<N.TsNamedTupleMember>(type);\n          labeledNode.optional = optional;\n          this.raise(TSErrors.InvalidTupleMemberLabel, { at: type });\n          // @ts-expect-error This produces an invalid AST, but at least we don't drop\n          // nodes representing the invalid source.\n          labeledNode.label = type;\n          labeledNode.elementType = this.tsParseType();\n        }\n        type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n      } else if (optional) {\n        const optionalTypeNode = this.startNodeAtNode<N.TsOptionalType>(type);\n        optionalTypeNode.typeAnnotation = type;\n        type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n      }\n\n      if (rest) {\n        const restNode = this.startNodeAt<N.TsRestType>(startLoc);\n        restNode.typeAnnotation = type;\n        type = this.finishNode(restNode, \"TSRestType\");\n      }\n\n      return type;\n    }\n\n    tsParseParenthesizedType(): N.TsParenthesizedType {\n      const node = this.startNode<N.TsParenthesizedType>();\n      this.expect(tt.parenL);\n      node.typeAnnotation = this.tsParseType();\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSParenthesizedType\");\n    }\n\n    tsParseFunctionOrConstructorType(\n      type: \"TSFunctionType\" | \"TSConstructorType\",\n      abstract?: boolean,\n    ): N.TsFunctionOrConstructorType {\n      const node = this.startNode<\n        N.TsFunctionOrConstructorType | N.TsConstructorType\n      >();\n      if (type === \"TSConstructorType\") {\n        (node as Undone<N.TsConstructorType>).abstract = !!abstract;\n        if (abstract) this.next();\n        this.next(); // eat `new`\n      }\n      this.tsInAllowConditionalTypesContext(() =>\n        this.tsFillSignature(tt.arrow, node),\n      );\n      return this.finishNode(node, type);\n    }\n\n    tsParseLiteralTypeNode(): N.TsLiteralType {\n      const node = this.startNode<N.TsLiteralType>();\n      switch (this.state.type) {\n        case tt.num:\n        case tt.bigint:\n        case tt.string:\n        case tt._true:\n        case tt._false:\n          // For compatibility to estree we cannot call parseLiteral directly here\n          // @ts-expect-error refine typings\n          node.literal = super.parseExprAtom();\n          break;\n        default:\n          this.unexpected();\n      }\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    tsParseTemplateLiteralType(): N.TsType {\n      const node = this.startNode<N.TsLiteralType>();\n      node.literal = super.parseTemplate(false);\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    parseTemplateSubstitution(): N.TsType | N.Node {\n      if (this.state.inType) return this.tsParseType();\n      return super.parseTemplateSubstitution();\n    }\n\n    tsParseThisTypeOrThisTypePredicate(): N.TsThisType | N.TsTypePredicate {\n      const thisKeyword = this.tsParseThisTypeNode();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        return this.tsParseThisTypePredicate(thisKeyword);\n      } else {\n        return thisKeyword;\n      }\n    }\n\n    tsParseNonArrayType(): N.TsType {\n      switch (this.state.type) {\n        case tt.string:\n        case tt.num:\n        case tt.bigint:\n        case tt._true:\n        case tt._false:\n          return this.tsParseLiteralTypeNode();\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            const node = this.startNode<N.TsLiteralType>();\n            const nextToken = this.lookahead();\n            if (nextToken.type !== tt.num && nextToken.type !== tt.bigint) {\n              this.unexpected();\n            }\n            // @ts-expect-error: parseMaybeUnary must returns unary expression\n            node.literal = this.parseMaybeUnary();\n            return this.finishNode(node, \"TSLiteralType\");\n          }\n          break;\n        case tt._this:\n          return this.tsParseThisTypeOrThisTypePredicate();\n        case tt._typeof:\n          return this.tsParseTypeQuery();\n        case tt._import:\n          return this.tsParseImportType();\n        case tt.braceL:\n          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))\n            ? this.tsParseMappedType()\n            : this.tsParseTypeLiteral();\n        case tt.bracketL:\n          return this.tsParseTupleType();\n        case tt.parenL:\n          if (process.env.BABEL_8_BREAKING) {\n            if (!this.options.createParenthesizedExpressions) {\n              const startLoc = this.state.startLoc;\n              this.next();\n              const type = this.tsParseType();\n              this.expect(tt.parenR);\n              this.addExtra(type, \"parenthesized\", true);\n              this.addExtra(type, \"parenStart\", startLoc.index);\n              return type;\n            }\n          }\n\n          return this.tsParseParenthesizedType();\n        case tt.templateNonTail:\n        case tt.templateTail:\n          return this.tsParseTemplateLiteralType();\n        default: {\n          const { type } = this.state;\n          if (\n            tokenIsIdentifier(type) ||\n            type === tt._void ||\n            type === tt._null\n          ) {\n            const nodeType =\n              type === tt._void\n                ? \"TSVoidKeyword\"\n                : type === tt._null\n                  ? \"TSNullKeyword\"\n                  : keywordTypeFromName(this.state.value);\n            if (\n              nodeType !== undefined &&\n              this.lookaheadCharCode() !== charCodes.dot\n            ) {\n              const node = this.startNode<N.TsKeywordType>();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n      }\n\n      this.unexpected();\n    }\n\n    tsParseArrayTypeOrHigher(): N.TsType {\n      let type = this.tsParseNonArrayType();\n      while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {\n        if (this.match(tt.bracketR)) {\n          const node = this.startNodeAtNode<N.TsArrayType>(type);\n          node.elementType = type;\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSArrayType\");\n        } else {\n          const node = this.startNodeAtNode<N.TsIndexedAccessType>(type);\n          node.objectType = type;\n          node.indexType = this.tsParseType();\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSIndexedAccessType\");\n        }\n      }\n      return type;\n    }\n\n    tsParseTypeOperator(): N.TsTypeOperator {\n      const node = this.startNode<N.TsTypeOperator>();\n      const operator = this.state.value;\n      this.next(); // eat operator\n      node.operator = operator;\n      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n      if (operator === \"readonly\") {\n        this.tsCheckTypeAnnotationForReadOnly(\n          // @ts-expect-error todo(flow->ts)\n          node,\n        );\n      }\n\n      return this.finishNode(node, \"TSTypeOperator\");\n    }\n\n    tsCheckTypeAnnotationForReadOnly(node: N.Node) {\n      switch (node.typeAnnotation.type) {\n        case \"TSTupleType\":\n        case \"TSArrayType\":\n          return;\n        default:\n          this.raise(TSErrors.UnexpectedReadonly, { at: node });\n      }\n    }\n\n    tsParseInferType(): N.TsInferType {\n      const node = this.startNode<N.TsInferType>();\n      this.expectContextual(tt._infer);\n      const typeParameter = this.startNode<N.TsTypeParameter>();\n      typeParameter.name = this.tsParseTypeParameterName();\n      typeParameter.constraint = this.tsTryParse(() =>\n        this.tsParseConstraintForInferType(),\n      );\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n      return this.finishNode(node, \"TSInferType\");\n    }\n\n    tsParseConstraintForInferType() {\n      if (this.eat(tt._extends)) {\n        const constraint = this.tsInDisallowConditionalTypesContext(() =>\n          this.tsParseType(),\n        );\n        if (\n          this.state.inDisallowConditionalTypesContext ||\n          !this.match(tt.question)\n        ) {\n          return constraint;\n        }\n      }\n    }\n\n    tsParseTypeOperatorOrHigher(): N.TsType {\n      const isTypeOperator =\n        tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n      return isTypeOperator\n        ? this.tsParseTypeOperator()\n        : this.isContextual(tt._infer)\n          ? this.tsParseInferType()\n          : this.tsInAllowConditionalTypesContext(() =>\n              this.tsParseArrayTypeOrHigher(),\n            );\n    }\n\n    tsParseUnionOrIntersectionType(\n      kind: \"TSUnionType\" | \"TSIntersectionType\",\n      parseConstituentType: () => N.TsType,\n      operator: TokenType,\n    ): N.TsType {\n      const node = this.startNode<N.TsUnionType | N.TsIntersectionType>();\n      const hasLeadingOperator = this.eat(operator);\n      const types = [];\n      do {\n        types.push(parseConstituentType());\n      } while (this.eat(operator));\n      if (types.length === 1 && !hasLeadingOperator) {\n        return types[0];\n      }\n      node.types = types;\n      return this.finishNode(node, kind);\n    }\n\n    tsParseIntersectionTypeOrHigher(): N.TsType {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSIntersectionType\",\n        this.tsParseTypeOperatorOrHigher.bind(this),\n        tt.bitwiseAND,\n      );\n    }\n\n    tsParseUnionTypeOrHigher() {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSUnionType\",\n        this.tsParseIntersectionTypeOrHigher.bind(this),\n        tt.bitwiseOR,\n      );\n    }\n\n    tsIsStartOfFunctionType() {\n      if (this.match(tt.lt)) {\n        return true;\n      }\n      return (\n        this.match(tt.parenL) &&\n        this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))\n      );\n    }\n\n    tsSkipParameterStart(): boolean {\n      if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n        this.next();\n        return true;\n      }\n\n      if (this.match(tt.braceL)) {\n        // Return true if we can parse an object pattern without errors\n        const { errors } = this.state;\n        const previousErrorCount = errors.length;\n        try {\n          this.parseObjectLike(tt.braceR, true);\n          return errors.length === previousErrorCount;\n        } catch {\n          return false;\n        }\n      }\n\n      if (this.match(tt.bracketL)) {\n        this.next();\n        // Return true if we can parse an array pattern without errors\n        const { errors } = this.state;\n        const previousErrorCount = errors.length;\n        try {\n          super.parseBindingList(\n            tt.bracketR,\n            charCodes.rightSquareBracket,\n            ParseBindingListFlags.ALLOW_EMPTY,\n          );\n          return errors.length === previousErrorCount;\n        } catch {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    tsIsUnambiguouslyStartOfFunctionType(): boolean {\n      this.next();\n      if (this.match(tt.parenR) || this.match(tt.ellipsis)) {\n        // ( )\n        // ( ...\n        return true;\n      }\n      if (this.tsSkipParameterStart()) {\n        if (\n          this.match(tt.colon) ||\n          this.match(tt.comma) ||\n          this.match(tt.question) ||\n          this.match(tt.eq)\n        ) {\n          // ( xxx :\n          // ( xxx ,\n          // ( xxx ?\n          // ( xxx =\n          return true;\n        }\n        if (this.match(tt.parenR)) {\n          this.next();\n          if (this.match(tt.arrow)) {\n            // ( xxx ) =>\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    tsParseTypeOrTypePredicateAnnotation(\n      returnToken: TokenType,\n    ): N.TsTypeAnnotation {\n      return this.tsInType(() => {\n        const t = this.startNode<N.TsTypeAnnotation>();\n        this.expect(returnToken);\n\n        const node = this.startNode<N.TsTypePredicate>();\n\n        const asserts = !!this.tsTryParse(\n          this.tsParseTypePredicateAsserts.bind(this),\n        );\n\n        if (asserts && this.match(tt._this)) {\n          // When asserts is false, thisKeyword is handled by tsParseNonArrayType\n          // : asserts this is type\n          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n          // if it turns out to be a `TSThisType`, wrap it with `TSTypePredicate`\n          // : asserts this\n          if (thisTypePredicate.type === \"TSThisType\") {\n            node.parameterName = thisTypePredicate;\n            node.asserts = true;\n            (node as N.TsTypePredicate).typeAnnotation = null;\n            thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n          } else {\n            this.resetStartLocationFromNode(thisTypePredicate, node);\n            thisTypePredicate.asserts = true;\n          }\n          t.typeAnnotation = thisTypePredicate;\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        const typePredicateVariable =\n          this.tsIsIdentifier() &&\n          this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n        if (!typePredicateVariable) {\n          if (!asserts) {\n            // : type\n            return this.tsParseTypeAnnotation(/* eatColon */ false, t);\n          }\n\n          // : asserts foo\n          node.parameterName = this.parseIdentifier();\n          node.asserts = asserts;\n          (node as N.TsTypePredicate).typeAnnotation = null;\n          t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        // : asserts foo is type\n        const type = this.tsParseTypeAnnotation(/* eatColon */ false);\n        node.parameterName = typePredicateVariable;\n        node.typeAnnotation = type;\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      });\n    }\n\n    tsTryParseTypeOrTypePredicateAnnotation(): N.TsTypeAnnotation | undefined {\n      if (this.match(tt.colon)) {\n        return this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n    }\n\n    tsTryParseTypeAnnotation(): N.TsTypeAnnotation | undefined {\n      if (this.match(tt.colon)) {\n        return this.tsParseTypeAnnotation();\n      }\n    }\n\n    tsTryParseType(): N.TsType | undefined {\n      return this.tsEatThenParseType(tt.colon);\n    }\n\n    tsParseTypePredicatePrefix(): N.Identifier | undefined {\n      const id = this.parseIdentifier();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        this.next();\n        return id;\n      }\n    }\n\n    tsParseTypePredicateAsserts(): boolean {\n      if (this.state.type !== tt._asserts) {\n        return false;\n      }\n      const containsEsc = this.state.containsEsc;\n      this.next();\n      if (!tokenIsIdentifier(this.state.type) && !this.match(tt._this)) {\n        return false;\n      }\n\n      if (containsEsc) {\n        this.raise(Errors.InvalidEscapedReservedWord, {\n          at: this.state.lastTokStartLoc,\n          reservedWord: \"asserts\",\n        });\n      }\n\n      return true;\n    }\n\n    tsParseTypeAnnotation(\n      eatColon = true,\n      t: Undone<N.TsTypeAnnotation> = this.startNode<N.TsTypeAnnotation>(),\n    ): N.TsTypeAnnotation {\n      this.tsInType(() => {\n        if (eatColon) this.expect(tt.colon);\n        t.typeAnnotation = this.tsParseType();\n      });\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    }\n\n    /** Be sure to be in a type context before calling this, using `tsInType`. */\n    tsParseType(): N.TsType {\n      // Need to set `state.inType` so that we don't parse JSX in a type context.\n      assert(this.state.inType);\n      const type = this.tsParseNonConditionalType();\n\n      if (\n        this.state.inDisallowConditionalTypesContext ||\n        this.hasPrecedingLineBreak() ||\n        !this.eat(tt._extends)\n      ) {\n        return type;\n      }\n      const node = this.startNodeAtNode<N.TsConditionalType>(type);\n      node.checkType = type;\n\n      node.extendsType = this.tsInDisallowConditionalTypesContext(() =>\n        this.tsParseNonConditionalType(),\n      );\n\n      this.expect(tt.question);\n      node.trueType = this.tsInAllowConditionalTypesContext(() =>\n        this.tsParseType(),\n      );\n\n      this.expect(tt.colon);\n      node.falseType = this.tsInAllowConditionalTypesContext(() =>\n        this.tsParseType(),\n      );\n\n      return this.finishNode(node, \"TSConditionalType\");\n    }\n\n    isAbstractConstructorSignature(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._new\n      );\n    }\n\n    tsParseNonConditionalType(): N.TsType {\n      if (this.tsIsStartOfFunctionType()) {\n        return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n      }\n      if (this.match(tt._new)) {\n        // As in `new () => Date`\n        return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n      } else if (this.isAbstractConstructorSignature()) {\n        // As in `abstract new () => Date`\n        return this.tsParseFunctionOrConstructorType(\n          \"TSConstructorType\",\n          /* abstract */ true,\n        );\n      }\n      return this.tsParseUnionTypeOrHigher();\n    }\n\n    tsParseTypeAssertion(): N.TsTypeAssertion {\n      if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n        this.raise(TSErrors.ReservedTypeAssertion, { at: this.state.startLoc });\n      }\n\n      const node = this.startNode<N.TsTypeAssertion>();\n      node.typeAnnotation = this.tsInType(() => {\n        this.next(); // \"<\"\n        return this.match(tt._const)\n          ? this.tsParseTypeReference()\n          : this.tsParseType();\n      });\n      this.expect(tt.gt);\n      node.expression = this.parseMaybeUnary();\n      return this.finishNode(node, \"TSTypeAssertion\");\n    }\n\n    tsParseHeritageClause(\n      token: \"extends\" | \"implements\",\n    ): Array<N.TsExpressionWithTypeArguments> {\n      const originalStartLoc = this.state.startLoc;\n\n      const delimitedList = this.tsParseDelimitedList(\n        \"HeritageClauseElement\",\n        () => {\n          const node = this.startNode<N.TsExpressionWithTypeArguments>();\n          node.expression = this.tsParseEntityName();\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.tsParseTypeArguments();\n          }\n\n          return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n        },\n      );\n\n      if (!delimitedList.length) {\n        this.raise(TSErrors.EmptyHeritageClauseType, {\n          at: originalStartLoc,\n          token,\n        });\n      }\n\n      return delimitedList;\n    }\n\n    tsParseInterfaceDeclaration(\n      node: Undone<N.TsInterfaceDeclaration>,\n      properties: {\n        declare?: true;\n      } = {},\n    ): N.TsInterfaceDeclaration | null {\n      if (this.hasFollowingLineBreak()) return null;\n      this.expectContextual(tt._interface);\n      if (properties.declare) node.declare = true;\n      if (tokenIsIdentifier(this.state.type)) {\n        node.id = this.parseIdentifier();\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_INTERFACE);\n      } else {\n        node.id = null;\n        this.raise(TSErrors.MissingInterfaceName, { at: this.state.startLoc });\n      }\n\n      node.typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseInOutConstModifiers,\n      );\n      if (this.eat(tt._extends)) {\n        node.extends = this.tsParseHeritageClause(\"extends\");\n      }\n      const body = this.startNode<N.TSInterfaceBody>();\n      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n      node.body = this.finishNode(body, \"TSInterfaceBody\");\n      return this.finishNode(node, \"TSInterfaceDeclaration\");\n    }\n\n    tsParseTypeAliasDeclaration(\n      node: N.TsTypeAliasDeclaration,\n    ): N.TsTypeAliasDeclaration {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BindingFlag.TYPE_TS_TYPE);\n\n      node.typeAnnotation = this.tsInType(() => {\n        node.typeParameters = this.tsTryParseTypeParameters(\n          this.tsParseInOutModifiers,\n        );\n\n        this.expect(tt.eq);\n\n        if (\n          this.isContextual(tt._intrinsic) &&\n          this.lookahead().type !== tt.dot\n        ) {\n          const node = this.startNode<N.TsKeywordType>();\n          this.next();\n          return this.finishNode(node, \"TSIntrinsicKeyword\");\n        }\n\n        return this.tsParseType();\n      });\n\n      this.semicolon();\n      return this.finishNode(node, \"TSTypeAliasDeclaration\");\n    }\n\n    tsInNoContext<T>(cb: () => T): T {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    }\n\n    /**\n     * Runs `cb` in a type context.\n     * This should be called one token *before* the first type token,\n     * so that the call to `next()` is run in type context.\n     */\n    tsInType<T>(cb: () => T): T {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inType = oldInType;\n      }\n    }\n\n    tsInDisallowConditionalTypesContext<T>(cb: () => T): T {\n      const oldInDisallowConditionalTypesContext =\n        this.state.inDisallowConditionalTypesContext;\n      this.state.inDisallowConditionalTypesContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inDisallowConditionalTypesContext =\n          oldInDisallowConditionalTypesContext;\n      }\n    }\n\n    tsInAllowConditionalTypesContext<T>(cb: () => T): T {\n      const oldInDisallowConditionalTypesContext =\n        this.state.inDisallowConditionalTypesContext;\n      this.state.inDisallowConditionalTypesContext = false;\n      try {\n        return cb();\n      } finally {\n        this.state.inDisallowConditionalTypesContext =\n          oldInDisallowConditionalTypesContext;\n      }\n    }\n\n    tsEatThenParseType(token: TokenType): N.TsType | undefined {\n      if (this.match(token)) {\n        return this.tsNextThenParseType();\n      }\n    }\n\n    tsExpectThenParseType(token: TokenType): N.TsType {\n      return this.tsInType(() => {\n        this.expect(token);\n        return this.tsParseType();\n      });\n    }\n\n    tsNextThenParseType(): N.TsType {\n      return this.tsInType(() => {\n        this.next();\n        return this.tsParseType();\n      });\n    }\n\n    tsParseEnumMember(): N.TsEnumMember {\n      const node = this.startNode<N.TsEnumMember>();\n      // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n      node.id = this.match(tt.string)\n        ? super.parseStringLiteral(this.state.value)\n        : this.parseIdentifier(/* liberal */ true);\n      if (this.eat(tt.eq)) {\n        node.initializer = super.parseMaybeAssignAllowIn();\n      }\n      return this.finishNode(node, \"TSEnumMember\");\n    }\n\n    tsParseEnumDeclaration(\n      node: Undone<N.TsEnumDeclaration>,\n      properties: {\n        const?: true;\n        declare?: true;\n      } = {},\n    ): N.TsEnumDeclaration {\n      if (properties.const) node.const = true;\n      if (properties.declare) node.declare = true;\n      this.expectContextual(tt._enum);\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(\n        node.id,\n        node.const ? BindingFlag.TYPE_TS_CONST_ENUM : BindingFlag.TYPE_TS_ENUM,\n      );\n\n      this.expect(tt.braceL);\n      node.members = this.tsParseDelimitedList(\n        \"EnumMembers\",\n        this.tsParseEnumMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return this.finishNode(node, \"TSEnumDeclaration\");\n    }\n\n    tsParseModuleBlock(): N.TsModuleBlock {\n      const node = this.startNode<N.TsModuleBlock>();\n      this.scope.enter(ScopeFlag.OTHER);\n\n      this.expect(tt.braceL);\n      // Inside of a module block is considered \"top-level\", meaning it can have imports and exports.\n      super.parseBlockOrModuleBlockBody(\n        (node.body = []),\n        /* directives */ undefined,\n        /* topLevel */ true,\n        /* end */ tt.braceR,\n      );\n      this.scope.exit();\n      return this.finishNode(node, \"TSModuleBlock\");\n    }\n\n    tsParseModuleOrNamespaceDeclaration(\n      node: Undone<N.TsModuleDeclaration>,\n      nested: boolean = false,\n    ): N.TsModuleDeclaration {\n      node.id = this.parseIdentifier();\n\n      if (!nested) {\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_NAMESPACE);\n      }\n\n      if (this.eat(tt.dot)) {\n        const inner = this.startNode<N.TsModuleDeclaration>();\n        this.tsParseModuleOrNamespaceDeclaration(inner, true);\n        // @ts-expect-error Fixme: refine typings\n        node.body = inner;\n      } else {\n        this.scope.enter(ScopeFlag.TS_MODULE);\n        this.prodParam.enter(ParamKind.PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      }\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseAmbientExternalModuleDeclaration(\n      node: N.TsModuleDeclaration,\n    ): N.TsModuleDeclaration {\n      if (this.isContextual(tt._global)) {\n        node.global = true;\n        node.id = this.parseIdentifier();\n      } else if (this.match(tt.string)) {\n        node.id = super.parseStringLiteral(this.state.value);\n      } else {\n        this.unexpected();\n      }\n      if (this.match(tt.braceL)) {\n        this.scope.enter(ScopeFlag.TS_MODULE);\n        this.prodParam.enter(ParamKind.PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      } else {\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseImportEqualsDeclaration(\n      node: Undone<N.TsImportEqualsDeclaration>,\n      maybeDefaultIdentifier?: N.Identifier | null,\n      isExport?: boolean,\n    ): N.TsImportEqualsDeclaration {\n      node.isExport = isExport || false;\n      node.id = maybeDefaultIdentifier || this.parseIdentifier();\n      this.checkIdentifier(node.id, BindingFlag.TYPE_TS_VALUE_IMPORT);\n      this.expect(tt.eq);\n      const moduleReference = this.tsParseModuleReference();\n      if (\n        node.importKind === \"type\" &&\n        moduleReference.type !== \"TSExternalModuleReference\"\n      ) {\n        this.raise(TSErrors.ImportAliasHasImportType, {\n          at: moduleReference,\n        });\n      }\n      node.moduleReference = moduleReference;\n      this.semicolon();\n      return this.finishNode(node, \"TSImportEqualsDeclaration\");\n    }\n\n    tsIsExternalModuleReference(): boolean {\n      return (\n        this.isContextual(tt._require) &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      );\n    }\n\n    tsParseModuleReference(): N.TsModuleReference {\n      return this.tsIsExternalModuleReference()\n        ? this.tsParseExternalModuleReference()\n        : this.tsParseEntityName(/* allowReservedWords */ false);\n    }\n\n    tsParseExternalModuleReference(): N.TsExternalModuleReference {\n      const node = this.startNode<N.TsExternalModuleReference>();\n      this.expectContextual(tt._require);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.unexpected();\n      }\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.expression = super.parseExprAtom() as N.StringLiteral;\n      this.expect(tt.parenR);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node, \"TSExternalModuleReference\");\n    }\n\n    // Utilities\n\n    tsLookAhead<T>(f: () => T): T {\n      const state = this.state.clone();\n      const res = f();\n      this.state = state;\n      return res;\n    }\n\n    tsTryParseAndCatch<T extends N.NodeBase | undefined | null>(\n      f: () => T,\n    ): T | undefined | null {\n      const result = this.tryParse(\n        abort =>\n          // @ts-expect-error todo(flow->ts)\n          f() || abort(),\n      );\n\n      if (result.aborted || !result.node) return;\n      if (result.error) this.state = result.failState;\n      // @ts-expect-error refine typings\n      return result.node;\n    }\n\n    tsTryParse<T>(f: () => T | undefined | false): T | undefined {\n      const state = this.state.clone();\n      const result = f();\n      if (result !== undefined && result !== false) {\n        return result;\n      }\n      this.state = state;\n    }\n\n    tsTryParseDeclare(nany: any): N.Declaration | undefined {\n      if (this.isLineTerminator()) {\n        return;\n      }\n      let startType = this.state.type;\n      let kind: \"let\" | null;\n\n      if (this.isContextual(tt._let)) {\n        startType = tt._var;\n        kind = \"let\";\n      }\n\n      // @ts-expect-error refine typings\n      return this.tsInAmbientContext(() => {\n        switch (startType) {\n          case tt._function:\n            nany.declare = true;\n            return super.parseFunctionStatement(\n              nany,\n              /* async */ false,\n              /* isHangingDeclaration */ false,\n            );\n          case tt._class:\n            // While this is also set by tsParseExpressionStatement, we need to set it\n            // before parsing the class declaration to know how to register it in the scope.\n            nany.declare = true;\n            return this.parseClass(\n              nany,\n              /* isStatement */ true,\n              /* optionalId */ false,\n            );\n          case tt._enum:\n            return this.tsParseEnumDeclaration(nany, { declare: true });\n          case tt._global:\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\n          case tt._const:\n          case tt._var:\n            if (!this.match(tt._const) || !this.isLookaheadContextual(\"enum\")) {\n              nany.declare = true;\n              return this.parseVarStatement(\n                nany,\n                kind || this.state.value,\n                true,\n              );\n            }\n\n            // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n            this.expect(tt._const);\n            return this.tsParseEnumDeclaration(nany, {\n              const: true,\n              declare: true,\n            });\n          case tt._interface: {\n            const result = this.tsParseInterfaceDeclaration(nany, {\n              declare: true,\n            });\n            if (result) return result;\n          }\n          // fallthrough\n          default:\n            if (tokenIsIdentifier(startType)) {\n              return this.tsParseDeclaration(\n                nany,\n                this.state.value,\n                /* next */ true,\n                /* decorators */ null,\n              );\n            }\n        }\n      });\n    }\n\n    // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n    tsTryParseExportDeclaration(): N.Declaration | undefined {\n      return this.tsParseDeclaration(\n        this.startNode(),\n        this.state.value,\n        /* next */ true,\n        /* decorators */ null,\n      );\n    }\n\n    tsParseExpressionStatement(\n      node: Undone<N.TsModuleDeclaration>,\n      expr: N.Identifier,\n      decorators: N.Decorator[] | null,\n    ): N.Declaration | undefined {\n      switch (expr.name) {\n        case \"declare\": {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n          }\n          return declaration;\n        }\n        case \"global\":\n          // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n          // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n          if (this.match(tt.braceL)) {\n            this.scope.enter(ScopeFlag.TS_MODULE);\n            this.prodParam.enter(ParamKind.PARAM);\n            const mod = node;\n            mod.global = true;\n            mod.id = expr;\n            mod.body = this.tsParseModuleBlock();\n            this.scope.exit();\n            this.prodParam.exit();\n            return this.finishNode(mod, \"TSModuleDeclaration\");\n          }\n          break;\n\n        default:\n          return this.tsParseDeclaration(\n            node,\n            expr.name,\n            /* next */ false,\n            decorators,\n          );\n      }\n    }\n\n    // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n    tsParseDeclaration(\n      node: any,\n      value: string,\n      next: boolean,\n      decorators: N.Decorator[] | null,\n    ): N.Declaration | undefined | null {\n      // no declaration apart from enum can be followed by a line break.\n      switch (value) {\n        case \"abstract\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            (this.match(tt._class) || tokenIsIdentifier(this.state.type))\n          ) {\n            return this.tsParseAbstractDeclaration(node, decorators);\n          }\n          break;\n\n        case \"module\":\n          if (this.tsCheckLineTerminator(next)) {\n            if (this.match(tt.string)) {\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            } else if (tokenIsIdentifier(this.state.type)) {\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n          }\n          break;\n\n        case \"namespace\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n          break;\n\n        case \"type\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseTypeAliasDeclaration(node);\n          }\n          break;\n      }\n    }\n\n    tsCheckLineTerminator(next: boolean) {\n      if (next) {\n        if (this.hasFollowingLineBreak()) return false;\n        this.next();\n        return true;\n      }\n      return !this.isLineTerminator();\n    }\n\n    tsTryParseGenericAsyncArrowFunction(\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined {\n      if (!this.match(tt.lt)) return;\n\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      this.state.maybeInArrowParameters = true;\n\n      const res: Undone<N.ArrowFunctionExpression> | undefined =\n        this.tsTryParseAndCatch(() => {\n          const node = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n          node.typeParameters = this.tsParseTypeParameters(\n            this.tsParseConstModifier,\n          );\n          // Don't use overloaded parseFunctionParams which would look for \"<\" again.\n          super.parseFunctionParams(node);\n          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n          this.expect(tt.arrow);\n          return node;\n        });\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n      if (!res) return;\n\n      return super.parseArrowExpression(\n        res,\n        /* params are already set */ null,\n        /* async */ true,\n      );\n    }\n\n    // Used when parsing type arguments from ES productions, where the first token\n    // has been created without state.inType. Thus we need to rescan the lt token.\n    tsParseTypeArgumentsInExpression(): N.TsTypeParameterInstantiation | void {\n      if (this.reScan_lt() !== tt.lt) return;\n      return this.tsParseTypeArguments();\n    }\n\n    tsParseTypeArguments(): N.TsTypeParameterInstantiation {\n      const node = this.startNode<N.TsTypeParameterInstantiation>();\n      node.params = this.tsInType(() =>\n        // Temporarily remove a JSX parsing context, which makes us scan different tokens.\n        this.tsInNoContext(() => {\n          this.expect(tt.lt);\n          return this.tsParseDelimitedList(\n            \"TypeParametersOrArguments\",\n            this.tsParseType.bind(this),\n          );\n        }),\n      );\n      if (node.params.length === 0) {\n        this.raise(TSErrors.EmptyTypeArguments, { at: node });\n      } else if (!this.state.inType && this.curContext() === tc.brace) {\n        // rescan `>` when we are no longer in type context and JSX parsing context\n        // since it was tokenized when `inType` is `true`.\n        this.reScan_lt_gt();\n      }\n      this.expect(tt.gt);\n      return this.finishNode(node, \"TSTypeParameterInstantiation\");\n    }\n\n    tsIsDeclarationStart(): boolean {\n      return tokenIsTSDeclarationStart(this.state.type);\n    }\n\n    // ======================================================\n    // OVERRIDES\n    // ======================================================\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.tsIsDeclarationStart()) return false;\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseAssignableListItem(\n      flags: ParseBindingListFlags,\n      decorators: N.Decorator[],\n    ): N.Pattern | N.TSParameterProperty {\n      // Store original location to include modifiers in range\n      const startLoc = this.state.startLoc;\n\n      const modified: ModifierBase = {};\n      this.tsParseModifiers(\n        {\n          allowedModifiers: [\n            \"public\",\n            \"private\",\n            \"protected\",\n            \"override\",\n            \"readonly\",\n          ],\n        },\n        modified,\n      );\n      const accessibility = modified.accessibility;\n      const override = modified.override;\n      const readonly = modified.readonly;\n      if (\n        !(flags & ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS) &&\n        (accessibility || readonly || override)\n      ) {\n        this.raise(TSErrors.UnexpectedParameterModifier, { at: startLoc });\n      }\n\n      const left = this.parseMaybeDefault();\n      this.parseAssignableListItemTypes(left, flags);\n      const elt = this.parseMaybeDefault(left.loc.start, left);\n      if (accessibility || readonly || override) {\n        const pp = this.startNodeAt<N.TSParameterProperty>(startLoc);\n        if (decorators.length) {\n          pp.decorators = decorators;\n        }\n        if (accessibility) pp.accessibility = accessibility;\n        if (readonly) pp.readonly = readonly;\n        if (override) pp.override = override;\n        if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n          this.raise(TSErrors.UnsupportedParameterPropertyKind, { at: pp });\n        }\n        pp.parameter = elt as any as N.Identifier | N.AssignmentPattern;\n        return this.finishNode(pp, \"TSParameterProperty\");\n      }\n\n      if (decorators.length) {\n        left.decorators = decorators;\n      }\n\n      return elt;\n    }\n\n    isSimpleParameter(node: N.Pattern | N.TSParameterProperty) {\n      return (\n        (node.type === \"TSParameterProperty\" &&\n          super.isSimpleParameter(node.parameter)) ||\n        super.isSimpleParameter(node)\n      );\n    }\n\n    tsDisallowOptionalPattern(node: Undone<N.Function>) {\n      for (const param of node.params) {\n        if (\n          param.type !== \"Identifier\" &&\n          (param as any).optional &&\n          !this.state.isAmbientContext\n        ) {\n          this.raise(TSErrors.PatternIsOptional, { at: param });\n        }\n      }\n    }\n\n    setArrowFunctionParameters(\n      node: Undone<N.ArrowFunctionExpression>,\n      params: N.Expression[],\n      trailingCommaLoc?: Position | null,\n    ): void {\n      super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n      this.tsDisallowOptionalPattern(node);\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n\n      const bodilessType =\n        type === \"FunctionDeclaration\"\n          ? \"TSDeclareFunction\"\n          : type === \"ClassMethod\" || type === \"ClassPrivateMethod\"\n            ? \"TSDeclareMethod\"\n            : undefined;\n      if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {\n        return this.finishNode(node, bodilessType);\n      }\n      if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n        this.raise(TSErrors.DeclareFunctionHasImplementation, { at: node });\n        if ((node as Undone<N.FunctionDeclaration>).declare) {\n          return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        }\n      }\n      this.tsDisallowOptionalPattern(node);\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    registerFunctionStatementId(node: N.Function): void {\n      if (!node.body && node.id) {\n        // Function ids are validated after parsing their body.\n        // For bodiless function, we need to do it here.\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_AMBIENT);\n      } else {\n        super.registerFunctionStatementId(node);\n      }\n    }\n\n    tsCheckForInvalidTypeCasts(items: Array<N.Expression | undefined | null>) {\n      items.forEach(node => {\n        if (node?.type === \"TSTypeCastExpression\") {\n          this.raise(TSErrors.UnexpectedTypeAnnotation, {\n            at: node.typeAnnotation,\n          });\n        }\n      });\n    }\n\n    toReferencedList(\n      exprList: Array<N.Expression | undefined | null>,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isInParens?: boolean,\n    ): Array<N.Expression | undefined | null> {\n      // Handles invalid scenarios like: `f(a:b)`, `(a:b);`, and `(a:b,c:d)`.\n      //\n      // Note that `f<T>(a:b)` goes through a different path and is handled\n      // in `parseSubscript` directly.\n      this.tsCheckForInvalidTypeCasts(exprList);\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      if (node.type === \"ArrayExpression\") {\n        this.tsCheckForInvalidTypeCasts(node.elements);\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      state: N.ParseSubscriptState,\n    ): N.Expression {\n      if (!this.hasPrecedingLineBreak() && this.match(tt.bang)) {\n        // When ! is consumed as a postfix operator (non-null assertion),\n        // disallow JSX tag forming after. e.g. When parsing `p! < n.p!`\n        // `<n.p` can not be a start of JSX tag\n        this.state.canStartJSXElement = false;\n        this.next();\n\n        const nonNullExpression =\n          this.startNodeAt<N.TsNonNullExpression>(startLoc);\n        nonNullExpression.expression = base;\n        return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n      }\n\n      let isOptionalCall = false;\n      if (\n        this.match(tt.questionDot) &&\n        this.lookaheadCharCode() === charCodes.lessThan\n      ) {\n        if (noCalls) {\n          state.stop = true;\n          return base;\n        }\n        state.optionalChainMember = isOptionalCall = true;\n        this.next();\n      }\n\n      // handles 'f<<T>'\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        let missingParenErrorLoc;\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\n        // There are number of things we are going to \"maybe\" parse, like type arguments on\n        // tagged template expressions. If any of them fail, walk it back and continue.\n        const result = this.tsTryParseAndCatch(() => {\n          if (!noCalls && this.atPossibleAsyncArrow(base)) {\n            // Almost certainly this is a generic async function `async <T>() => ...\n            // But it might be a call with a type argument `async<T>();`\n            const asyncArrowFn =\n              this.tsTryParseGenericAsyncArrowFunction(startLoc);\n            if (asyncArrowFn) {\n              return asyncArrowFn;\n            }\n          }\n\n          const typeArguments = this.tsParseTypeArgumentsInExpression();\n          if (!typeArguments) return;\n\n          if (isOptionalCall && !this.match(tt.parenL)) {\n            missingParenErrorLoc = this.state.curPosition();\n            return;\n          }\n\n          if (tokenIsTemplate(this.state.type)) {\n            const result = super.parseTaggedTemplateExpression(\n              base,\n\n              startLoc,\n              state,\n            );\n            result.typeParameters = typeArguments;\n            return result;\n          }\n\n          if (!noCalls && this.eat(tt.parenL)) {\n            const node = this.startNodeAt<\n              N.CallExpression | N.OptionalCallExpression\n            >(startLoc);\n            node.callee = base;\n            // possibleAsync always false here, because we would have handled it above.\n            // @ts-expect-error (won't be any undefined arguments)\n            node.arguments = this.parseCallExpressionArguments(\n              tt.parenR,\n              /* possibleAsync */ false,\n            );\n\n            // Handles invalid case: `f<T>(a:b)`\n            this.tsCheckForInvalidTypeCasts(node.arguments);\n\n            node.typeParameters = typeArguments;\n            if (state.optionalChainMember) {\n              (node as Undone<N.OptionalCallExpression>).optional =\n                isOptionalCall;\n            }\n\n            return this.finishCallExpression(node, state.optionalChainMember);\n          }\n\n          const tokenType = this.state.type;\n          if (\n            // a<b>>c is not (a<b>)>c, but a<(b>>c)\n            tokenType === tt.gt ||\n            // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)\n            tokenType === tt.bitShiftR ||\n            // a<b>c is (a<b)>c\n            (tokenType !== tt.parenL &&\n              tokenCanStartExpression(tokenType) &&\n              !this.hasPrecedingLineBreak())\n          ) {\n            // Bail out.\n            return;\n          }\n\n          const node = this.startNodeAt<N.TsInstantiationExpression>(startLoc);\n          node.expression = base;\n          node.typeParameters = typeArguments;\n          return this.finishNode(node, \"TSInstantiationExpression\");\n        });\n\n        if (missingParenErrorLoc) {\n          this.unexpected(missingParenErrorLoc, tt.parenL);\n        }\n\n        if (result) {\n          if (\n            result.type === \"TSInstantiationExpression\" &&\n            (this.match(tt.dot) ||\n              (this.match(tt.questionDot) &&\n                this.lookaheadCharCode() !== charCodes.leftParenthesis))\n          ) {\n            this.raise(\n              TSErrors.InvalidPropertyAccessAfterInstantiationExpression,\n              { at: this.state.startLoc },\n            );\n          }\n          return result;\n        }\n      }\n\n      return super.parseSubscript(base, startLoc, noCalls, state);\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      const { callee } = node;\n      if (\n        callee.type === \"TSInstantiationExpression\" &&\n        !callee.extra?.parenthesized\n      ) {\n        node.typeParameters = callee.typeParameters;\n        node.callee = callee.expression;\n      }\n    }\n\n    parseExprOp(\n      left: N.Expression,\n      leftStartLoc: Position,\n      minPrec: number,\n    ): N.Expression {\n      let isSatisfies: boolean;\n      if (\n        tokenOperatorPrecedence(tt._in) > minPrec &&\n        !this.hasPrecedingLineBreak() &&\n        (this.isContextual(tt._as) ||\n          (isSatisfies = this.isContextual(tt._satisfies)))\n      ) {\n        const node = this.startNodeAt<\n          N.TsAsExpression | N.TsSatisfiesExpression\n        >(leftStartLoc);\n        node.expression = left;\n        node.typeAnnotation = this.tsInType(() => {\n          this.next(); // \"as\" or \"satisfies\"\n          if (this.match(tt._const)) {\n            if (isSatisfies) {\n              this.raise(Errors.UnexpectedKeyword, {\n                at: this.state.startLoc,\n                keyword: \"const\",\n              });\n            }\n            return this.tsParseTypeReference();\n          }\n\n          return this.tsParseType();\n        });\n        this.finishNode(\n          node,\n          isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\",\n        );\n        // rescan `<`, `>` because they were scanned when this.state.inType was true\n        this.reScan_lt_gt();\n        return this.parseExprOp(\n          // @ts-expect-error todo(flow->ts)\n          node,\n          leftStartLoc,\n          minPrec,\n        );\n      }\n\n      return super.parseExprOp(left, leftStartLoc, minPrec);\n    }\n\n    checkReservedWord(\n      word: string,\n      startLoc: Position,\n      checkKeywords: boolean,\n      isBinding: boolean,\n    ): void {\n      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.\n      // And we have a type checker anyway, so don't bother having the parser do it.\n      if (!this.state.isAmbientContext) {\n        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n      }\n    }\n\n    checkImportReflection(node: Undone<N.ImportDeclaration>) {\n      super.checkImportReflection(node);\n      if (node.module && node.importKind !== \"value\") {\n        this.raise(TSErrors.ImportReflectionHasImportType, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n    }\n\n    /*\n    Don't bother doing this check in TypeScript code because:\n    1. We may have a nested export statement with the same name:\n      export const x = 0;\n      export namespace N {\n        export const x = 1;\n      }\n    2. We have a type checker to warn us about this sort of thing.\n    */\n    checkDuplicateExports() {}\n\n    isPotentialImportPhase(isExport: boolean): boolean {\n      if (super.isPotentialImportPhase(isExport)) return true;\n      if (this.isContextual(tt._type)) {\n        const ch = this.lookaheadCharCode();\n        return isExport\n          ? ch === charCodes.leftCurlyBrace || ch === charCodes.asterisk\n          : ch !== charCodes.equalsTo;\n      }\n      return !isExport && this.isContextual(tt._typeof);\n    }\n\n    applyImportPhase(\n      node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n      isExport: boolean,\n      phase: string | null,\n      loc?: Position,\n    ): void {\n      super.applyImportPhase(node, isExport, phase, loc);\n      if (isExport) {\n        (node as N.ExportNamedDeclaration).exportKind =\n          phase === \"type\" ? \"type\" : \"value\";\n      } else {\n        (node as N.ImportDeclaration).importKind =\n          phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n      }\n    }\n\n    parseImport(\n      node: Undone<N.ImportDeclaration | N.TsImportEqualsDeclaration>,\n    ): N.AnyImport {\n      if (this.match(tt.string)) {\n        node.importKind = \"value\";\n        return super.parseImport(node as Undone<N.ImportDeclaration>);\n      }\n\n      let importNode;\n      if (\n        tokenIsIdentifier(this.state.type) &&\n        this.lookaheadCharCode() === charCodes.equalsTo\n      ) {\n        node.importKind = \"value\";\n        return this.tsParseImportEqualsDeclaration(\n          node as Undone<N.TsImportEqualsDeclaration>,\n        );\n      } else if (this.isContextual(tt._type)) {\n        const maybeDefaultIdentifier = this.parseMaybeImportPhase(\n          node as Undone<N.ImportDeclaration>,\n          /* isExport */ false,\n        );\n        if (this.lookaheadCharCode() === charCodes.equalsTo) {\n          return this.tsParseImportEqualsDeclaration(\n            node as Undone<N.TsImportEqualsDeclaration>,\n            maybeDefaultIdentifier,\n          );\n        } else {\n          importNode = super.parseImportSpecifiersAndAfter(\n            node as Undone<N.ImportDeclaration>,\n            maybeDefaultIdentifier,\n          );\n        }\n      } else {\n        importNode = super.parseImport(node as Undone<N.ImportDeclaration>);\n      }\n\n      // `import type` can only be used on imports with named imports or with a\n      // default import - but not both\n      if (\n        importNode.importKind === \"type\" &&\n        // @ts-expect-error refine typings\n        importNode.specifiers.length > 1 &&\n        // @ts-expect-error refine typings\n        importNode.specifiers[0].type === \"ImportDefaultSpecifier\"\n      ) {\n        this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {\n          at: importNode,\n        });\n      }\n\n      return importNode;\n    }\n\n    parseExport(\n      node: Undone<N.Node>,\n      decorators: N.Decorator[] | null,\n    ): N.AnyExport {\n      if (this.match(tt._import)) {\n        // `export import A = B;`\n        this.next(); // eat `tt._import`\n        let maybeDefaultIdentifier: N.Identifier | null = null;\n        if (\n          this.isContextual(tt._type) &&\n          // We pass false here, because we are parsing an `import ... =`\n          this.isPotentialImportPhase(/* isExport */ false)\n        ) {\n          maybeDefaultIdentifier = this.parseMaybeImportPhase(\n            node as Undone<N.TsImportEqualsDeclaration>,\n            /* isExport */ false,\n          );\n        } else {\n          node.importKind = \"value\";\n        }\n        return this.tsParseImportEqualsDeclaration(\n          node as Undone<N.TsImportEqualsDeclaration>,\n          maybeDefaultIdentifier,\n          /* isExport */ true,\n        );\n      } else if (this.eat(tt.eq)) {\n        // `export = x;`\n        const assign = node as Undone<N.TsExportAssignment>;\n        assign.expression = super.parseExpression();\n        this.semicolon();\n        this.sawUnambiguousESM = true;\n        return this.finishNode(assign, \"TSExportAssignment\");\n      } else if (this.eatContextual(tt._as)) {\n        // `export as namespace A;`\n        const decl = node as Undone<N.TsNamespaceExportDeclaration>;\n        // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n        this.expectContextual(tt._namespace);\n        decl.id = this.parseIdentifier();\n        this.semicolon();\n        return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n      } else {\n        return super.parseExport(\n          node as Undone<N.ExportAllDeclaration | N.ExportDefaultDeclaration>,\n          decorators,\n        );\n      }\n    }\n\n    isAbstractClass(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._class\n      );\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.isAbstractClass()) {\n        const cls = this.startNode<N.Class>();\n        this.next(); // Skip \"abstract\"\n        cls.abstract = true;\n        return this.parseClass(cls, true, true);\n      }\n\n      // export default interface allowed in:\n      // https://github.com/Microsoft/TypeScript/pull/16040\n      if (this.match(tt._interface)) {\n        const result = this.tsParseInterfaceDeclaration(\n          this.startNode<N.TsInterfaceDeclaration>(),\n        );\n        if (result) return result;\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseVarStatement(\n      node: N.VariableDeclaration,\n      kind: \"var\" | \"let\" | \"const\" | \"using\",\n      allowMissingInitializer: boolean = false,\n    ) {\n      const { isAmbientContext } = this.state;\n      const declaration = super.parseVarStatement(\n        node,\n        kind,\n        allowMissingInitializer || isAmbientContext,\n      );\n\n      if (!isAmbientContext) return declaration;\n\n      for (const { id, init } of declaration.declarations) {\n        // Empty initializer is the easy case that we want.\n        if (!init) continue;\n\n        // var and let aren't ever allowed initializers.\n        if (kind !== \"const\" || !!id.typeAnnotation) {\n          this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {\n            at: init,\n          });\n        } else if (\n          !isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))\n        ) {\n          this.raise(\n            TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,\n            { at: init },\n          );\n        }\n      }\n\n      return declaration;\n    }\n\n    parseStatementContent(\n      flags: ParseStatementFlag,\n      decorators?: N.Decorator[] | null,\n    ): N.Statement {\n      if (this.match(tt._const) && this.isLookaheadContextual(\"enum\")) {\n        const node = this.startNode<N.TsEnumDeclaration>();\n        this.expect(tt._const); // eat 'const'\n        return this.tsParseEnumDeclaration(node, { const: true });\n      }\n\n      if (this.isContextual(tt._enum)) {\n        return this.tsParseEnumDeclaration(\n          this.startNode<N.TsEnumDeclaration>(),\n        );\n      }\n\n      if (this.isContextual(tt._interface)) {\n        const result = this.tsParseInterfaceDeclaration(this.startNode());\n        if (result) return result;\n      }\n\n      return super.parseStatementContent(flags, decorators);\n    }\n\n    parseAccessModifier(): N.Accessibility | undefined | null {\n      return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n    }\n\n    tsHasSomeModifiers(member: any, modifiers: readonly TsModifier[]): boolean {\n      return modifiers.some(modifier => {\n        if (tsIsAccessModifier(modifier)) {\n          return member.accessibility === modifier;\n        }\n        return !!member[modifier];\n      });\n    }\n\n    tsIsStartOfStaticBlocks() {\n      return (\n        this.isContextual(tt._static) &&\n        this.lookaheadCharCode() === charCodes.leftCurlyBrace\n      );\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const modifiers = [\n        \"declare\",\n        \"private\",\n        \"public\",\n        \"protected\",\n        \"override\",\n        \"abstract\",\n        \"readonly\",\n        \"static\",\n      ] as const;\n      this.tsParseModifiers(\n        {\n          allowedModifiers: modifiers,\n          disallowedModifiers: [\"in\", \"out\"],\n          stopOnStartOfClassStaticBlock: true,\n          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,\n        },\n        member,\n      );\n\n      const callParseClassMemberWithIsStatic = () => {\n        if (this.tsIsStartOfStaticBlocks()) {\n          this.next(); // eat \"static\"\n          this.next(); // eat \"{\"\n          if (this.tsHasSomeModifiers(member, modifiers)) {\n            this.raise(TSErrors.StaticBlockCannotHaveModifier, {\n              at: this.state.curPosition(),\n            });\n          }\n          super.parseClassStaticBlock(classBody, member as N.StaticBlock);\n        } else {\n          this.parseClassMemberWithIsStatic(\n            classBody,\n            member,\n            state,\n            !!member.static,\n          );\n        }\n      };\n      if (member.declare) {\n        this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n      } else {\n        callParseClassMemberWithIsStatic();\n      }\n    }\n\n    parseClassMemberWithIsStatic(\n      classBody: N.ClassBody,\n      member: Undone<N.ClassMember | N.TsIndexSignature>,\n      state: N.ParseClassMemberState,\n      isStatic: boolean,\n    ): void {\n      const idx = this.tsTryParseIndexSignature(\n        member as Undone<N.TsIndexSignature>,\n      );\n      if (idx) {\n        classBody.body.push(idx);\n\n        if ((member as any).abstract) {\n          this.raise(TSErrors.IndexSignatureHasAbstract, { at: member });\n        }\n        if ((member as any).accessibility) {\n          this.raise(TSErrors.IndexSignatureHasAccessibility, {\n            at: member,\n            modifier: (member as any).accessibility,\n          });\n        }\n        if ((member as any).declare) {\n          this.raise(TSErrors.IndexSignatureHasDeclare, { at: member });\n        }\n        if ((member as any).override) {\n          this.raise(TSErrors.IndexSignatureHasOverride, { at: member });\n        }\n\n        return;\n      }\n\n      if (!this.state.inAbstractClass && (member as any).abstract) {\n        this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {\n          at: member,\n        });\n      }\n\n      if ((member as any).override) {\n        if (!state.hadSuperClass) {\n          this.raise(TSErrors.OverrideNotInSubClass, { at: member });\n        }\n      }\n\n      /*:: invariant(member.type !== \"TSIndexSignature\") */\n\n      super.parseClassMemberWithIsStatic(\n        classBody,\n        member as Undone<N.ClassMember>,\n        state,\n        isStatic,\n      );\n    }\n\n    parsePostMemberNameModifiers(\n      methodOrProp: N.ClassMethod | N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      const optional = this.eat(tt.question);\n      if (optional) methodOrProp.optional = true;\n\n      if ((methodOrProp as any).readonly && this.match(tt.parenL)) {\n        this.raise(TSErrors.ClassMethodHasReadonly, { at: methodOrProp });\n      }\n\n      if ((methodOrProp as any).declare && this.match(tt.parenL)) {\n        this.raise(TSErrors.ClassMethodHasDeclare, { at: methodOrProp });\n      }\n    }\n\n    // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\n    // is that e.g. `type()` is valid JS, so we must try parsing that first.\n    // If it's really a type, we will parse `type` as the statement, and can correct it here\n    // by parsing the rest.\n    // @ts-expect-error plugin overrides interfaces\n    parseExpressionStatement(\n      node: Undone<N.ExpressionStatement>,\n      expr: N.Expression,\n      decorators: N.Decorator[] | null,\n    ): N.Statement {\n      const decl =\n        expr.type === \"Identifier\"\n          ? // @ts-expect-error refine typings\n            this.tsParseExpressionStatement(node, expr, decorators)\n          : undefined;\n      return decl || super.parseExpressionStatement(node, expr, decorators);\n    }\n\n    // export type\n    // Should be true for anything parsed by `tsTryParseExportDeclaration`.\n    shouldParseExportDeclaration(): boolean {\n      if (this.tsIsDeclarationStart()) return true;\n      return super.shouldParseExportDeclaration();\n    }\n\n    // An apparent conditional expression could actually be an optional parameter in an arrow function.\n    parseConditional(\n      expr: N.Expression,\n\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      // only do the expensive clone if there is a question mark\n      // and if we come from inside parens\n      if (!this.state.maybeInArrowParameters || !this.match(tt.question)) {\n        return super.parseConditional(\n          expr,\n\n          startLoc,\n          refExpressionErrors,\n        );\n      }\n\n      const result = this.tryParse(() =>\n        super.parseConditional(expr, startLoc),\n      );\n\n      if (!result.node) {\n        if (result.error) {\n          /*:: invariant(refExpressionErrors != null) */\n          super.setOptionalParametersError(refExpressionErrors, result.error);\n        }\n\n        return expr;\n      }\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    // Note: These \"type casts\" are *not* valid TS expressions.\n    // But we parse them here and change them when completing the arrow function.\n    parseParenItem(\n      node: N.Expression,\n\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt<N.TsTypeCastExpression>(startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (!this.state.isAmbientContext && this.isContextual(tt._declare)) {\n        return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n      }\n\n      // Store original location\n      const startLoc = this.state.startLoc;\n\n      const isDeclare = this.eatContextual(tt._declare);\n\n      if (\n        isDeclare &&\n        (this.isContextual(tt._declare) || !this.shouldParseExportDeclaration())\n      ) {\n        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {\n          at: this.state.startLoc,\n        });\n      }\n\n      const isIdentifier = tokenIsIdentifier(this.state.type);\n      const declaration: N.Declaration | undefined | null =\n        (isIdentifier && this.tsTryParseExportDeclaration()) ||\n        super.parseExportDeclaration(node);\n\n      if (!declaration) return null;\n\n      if (\n        declaration.type === \"TSInterfaceDeclaration\" ||\n        declaration.type === \"TSTypeAliasDeclaration\" ||\n        isDeclare\n      ) {\n        node.exportKind = \"type\";\n      }\n\n      if (isDeclare) {\n        // Reset location to include `declare` in range\n        this.resetStartLocation(declaration, startLoc);\n\n        declaration.declare = true;\n      }\n\n      return declaration;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType?: BindingTypes,\n    ): void {\n      if ((!isStatement || optionalId) && this.isContextual(tt._implements)) {\n        return;\n      }\n\n      super.parseClassId(\n        node,\n        isStatement,\n        optionalId,\n        (node as any).declare\n          ? BindingFlag.TYPE_TS_AMBIENT\n          : BindingFlag.TYPE_CLASS,\n      );\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseInOutConstModifiers,\n      );\n      if (typeParameters) node.typeParameters = typeParameters;\n    }\n\n    parseClassPropertyAnnotation(\n      node: N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty,\n    ): void {\n      if (!node.optional) {\n        if (this.eat(tt.bang)) {\n          node.definite = true;\n        } else if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n    }\n\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      this.parseClassPropertyAnnotation(node);\n\n      if (\n        this.state.isAmbientContext &&\n        !(node.readonly && !node.typeAnnotation) &&\n        this.match(tt.eq)\n      ) {\n        this.raise(TSErrors.DeclareClassFieldHasInitializer, {\n          at: this.state.startLoc,\n        });\n      }\n      if (node.abstract && this.match(tt.eq)) {\n        const { key } = node;\n        this.raise(TSErrors.AbstractPropertyHasInitializer, {\n          at: this.state.startLoc,\n          propertyName:\n            key.type === \"Identifier\" && !node.computed\n              ? key.name\n              : `[${this.input.slice(key.start, key.end)}]`,\n        });\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      // @ts-expect-error abstract may not index node\n      if (node.abstract) {\n        this.raise(TSErrors.PrivateElementHasAbstract, { at: node });\n      }\n\n      // @ts-expect-error accessibility may not index node\n      if (node.accessibility) {\n        this.raise(TSErrors.PrivateElementHasAccessibility, {\n          at: node,\n          // @ts-expect-error refine typings\n          modifier: node.accessibility,\n        });\n      }\n\n      this.parseClassPropertyAnnotation(node);\n      return super.parseClassPrivateProperty(node);\n    }\n\n    parseClassAccessorProperty(\n      node: N.ClassAccessorProperty,\n    ): N.ClassAccessorProperty {\n      this.parseClassPropertyAnnotation(node);\n      if (node.optional) {\n        this.raise(TSErrors.AccessorCannotBeOptional, { at: node });\n      }\n      return super.parseClassAccessorProperty(node);\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters && isConstructor) {\n        this.raise(TSErrors.ConstructorHasTypeParameters, {\n          at: typeParameters,\n        });\n      }\n\n      // @ts-expect-error declare does not exist in ClassMethod\n      const { declare = false, kind } = method;\n\n      if (declare && (kind === \"get\" || kind === \"set\")) {\n        this.raise(TSErrors.DeclareAccessor, { at: method, kind });\n      }\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    declareClassPrivateMethodInScope(\n      node: N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod,\n      kind: number,\n    ) {\n      if (node.type === \"TSDeclareMethod\") return;\n      // This happens when using the \"estree\" plugin.\n      if (node.type === \"MethodDefinition\" && !node.value.body) return;\n\n      super.declareClassPrivateMethodInScope(node, kind);\n    }\n\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      // handle `extends f<<T>\n      if (node.superClass && (this.match(tt.lt) || this.match(tt.bitShiftL))) {\n        // @ts-expect-error refine typings\n        node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n      }\n      if (this.eatContextual(tt._implements)) {\n        node.implements = this.tsParseHeritageClause(\"implements\");\n      }\n    }\n\n    parseObjPropValue(\n      prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ) {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) prop.typeParameters = typeParameters;\n\n      return super.parseObjPropValue(\n        prop,\n\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n    }\n\n    parseFunctionParams(node: N.Function, isConstructor: boolean): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) node.typeParameters = typeParameters;\n      super.parseFunctionParams(node, isConstructor);\n    }\n\n    // `let x: number;`\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\" | \"using\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (\n        decl.id.type === \"Identifier\" &&\n        !this.hasPrecedingLineBreak() &&\n        this.eat(tt.bang)\n      ) {\n        decl.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) {\n        decl.id.typeAnnotation = type;\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeAnnotation();\n      }\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n\n      let state: State | undefined | null;\n      let jsx;\n      let typeCast;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        // Prefer to parse JSX if possible. But may be an arrow fn.\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` or `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (!jsx?.error && !this.match(tt.lt)) {\n        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      }\n\n      // Either way, we're looking at a '<': tt.jsxTagStart or relational.\n\n      // If the state was cloned in the JSX parsing branch above but there\n      // have been any error in the tryParse call, this.state is set to state\n      // so we still need to clone it.\n      if (!state || state === this.state) state = this.state.clone();\n\n      let typeParameters: N.TsTypeParameterDeclaration | undefined | null;\n      const arrow = this.tryParse(abort => {\n        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n        typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n        const expr = super.parseMaybeAssign(\n          refExpressionErrors,\n          afterLeftParse,\n        );\n\n        if (\n          expr.type !== \"ArrowFunctionExpression\" ||\n          expr.extra?.parenthesized\n        ) {\n          abort();\n        }\n\n        // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.\n        if (typeParameters?.params.length !== 0) {\n          this.resetStartLocationFromNode(expr, typeParameters);\n        }\n        expr.typeParameters = typeParameters;\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            this.hasPlugin(\"jsx\") &&\n            expr.typeParameters.params.length === 1 &&\n            !expr.typeParameters.extra?.trailingComma\n          ) {\n            // report error if single type parameter used without trailing comma.\n            const parameter = expr.typeParameters.params[0];\n            if (!parameter.constraint) {\n              // A single type parameter must either have constraints\n              // or a trailing comma, otherwise it's ambiguous with JSX.\n              this.raise(TSErrors.SingleTypeParameterWithoutTrailingComma, {\n                at: createPositionWithColumnOffset(parameter.loc.end, 1),\n                typeParameterName: parameter.name.name,\n              });\n            }\n          }\n        }\n\n        return expr;\n      }, state);\n\n      /*:: invariant(arrow.node != null) */\n      if (!arrow.error && !arrow.aborted) {\n        // This error is reported outside of the this.tryParse call so that\n        // in case of <T>(x) => 2, we don't consider <T>(x) as a type assertion\n        // because of this error.\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        // @ts-expect-error refine typings\n        return arrow.node;\n      }\n\n      if (!jsx) {\n        // Try parsing a type cast instead of an arrow function.\n        // This will never happen outside of JSX.\n        // (Because in JSX the '<' should be a jsxTagStart and not a relational.\n        assert(!this.hasPlugin(\"jsx\"));\n\n        // This will start with a type assertion (via parseMaybeUnary).\n        // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.\n        typeCast = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n        /*:: invariant(!typeCast.aborted) */\n        /*:: invariant(typeCast.node != null) */\n        if (!typeCast.error) return typeCast.node;\n      }\n\n      if (jsx?.node) {\n        /*:: invariant(jsx.failState) */\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrow.node) {\n        /*:: invariant(arrow.failState) */\n        this.state = arrow.failState;\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        // @ts-expect-error refine typings\n        return arrow.node;\n      }\n\n      if (typeCast?.node) {\n        /*:: invariant(typeCast.failState) */\n        this.state = typeCast.failState;\n        return typeCast.node;\n      }\n\n      throw jsx?.error || arrow.error || typeCast?.error;\n    }\n\n    reportReservedArrowTypeParam(node: any) {\n      if (\n        node.params.length === 1 &&\n        !node.params[0].constraint &&\n        !node.extra?.trailingComma &&\n        this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")\n      ) {\n        this.raise(TSErrors.ReservedArrowTypeParam, { at: node });\n      }\n    }\n\n    // Handle type assertions\n    parseMaybeUnary(\n      refExpressionErrors?: ExpressionErrors | null,\n      sawUnary?: boolean,\n    ): N.Expression {\n      if (!this.hasPlugin(\"jsx\") && this.match(tt.lt)) {\n        return this.tsParseTypeAssertion();\n      }\n      return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n    }\n\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // This is different from how the TS parser does it.\n        // TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.\n\n        const result = this.tryParse(abort => {\n          const returnType = this.tsParseTypeOrTypePredicateAnnotation(\n            tt.colon,\n          );\n          if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();\n          return returnType;\n        });\n\n        if (result.aborted) return;\n\n        if (!result.thrown) {\n          if (result.error) this.state = result.failState;\n          // @ts-expect-error refine typings\n          node.returnType = result.node;\n        }\n      }\n\n      return super.parseArrow(node);\n    }\n\n    // Allow type annotations inside of a parameter list.\n    parseAssignableListItemTypes(\n      param: N.Pattern,\n      flags: ParseBindingListFlags,\n    ) {\n      if (!(flags & ParseBindingListFlags.IS_FUNCTION_PARAMS)) return param;\n\n      if (this.eat(tt.question)) {\n        (param as any as N.Identifier).optional = true;\n      }\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) param.typeAnnotation = type;\n      this.resetEndLocation(param);\n\n      return param;\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      switch (node.type) {\n        case \"TSTypeCastExpression\":\n          return this.isAssignable(node.expression, isBinding);\n        case \"TSParameterProperty\":\n          return true;\n        default:\n          return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      switch (node.type) {\n        case \"ParenthesizedExpression\":\n          this.toAssignableParenthesizedExpression(node, isLHS);\n          break;\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n          if (isLHS) {\n            this.expressionScope.recordArrowParameterBindingError(\n              TSErrors.UnexpectedTypeCastInParameter,\n              { at: node },\n            );\n          } else {\n            this.raise(TSErrors.UnexpectedTypeCastInParameter, { at: node });\n          }\n          this.toAssignable(node.expression, isLHS);\n          break;\n        case \"AssignmentExpression\":\n          if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n            node.left = this.typeCastToParameter(node.left);\n          }\n        /* fall through */\n        default:\n          super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableParenthesizedExpression(node: N.Node, isLHS: boolean): void {\n      switch (node.expression.type) {\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n        case \"ParenthesizedExpression\":\n          this.toAssignable(node.expression, isLHS);\n          break;\n        default:\n          super.toAssignable(node, isLHS);\n      }\n    }\n\n    checkToRestConversion(node: N.Node, allowPattern: boolean): void {\n      switch (node.type) {\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSTypeAssertion\":\n        case \"TSNonNullExpression\":\n          this.checkToRestConversion(node.expression, false);\n          break;\n        default:\n          super.checkToRestConversion(node, allowPattern);\n      }\n    }\n\n    // @ts-expect-error plugin overrides interfaces\n    isValidLVal(\n      type:\n        | \"TSTypeCastExpression\"\n        | \"TSParameterProperty\"\n        | \"TSNonNullExpression\"\n        | \"TSAsExpression\"\n        | \"TSSatisfiesExpression\"\n        | \"TSTypeAssertion\",\n      isUnparenthesizedInAssign: boolean,\n      binding: BindingTypes,\n    ) {\n      return (\n        getOwn(\n          {\n            // Allow \"typecasts\" to appear on the left of assignment expressions,\n            // because it may be in an arrow function.\n            // e.g. `const f = (foo: number = 0) => foo;`\n            TSTypeCastExpression: true,\n            TSParameterProperty: \"parameter\",\n            TSNonNullExpression: \"expression\",\n            TSAsExpression: (binding !== BindingFlag.TYPE_NONE ||\n              !isUnparenthesizedInAssign) && [\"expression\", true],\n            TSSatisfiesExpression: (binding !== BindingFlag.TYPE_NONE ||\n              !isUnparenthesizedInAssign) && [\"expression\", true],\n            TSTypeAssertion: (binding !== BindingFlag.TYPE_NONE ||\n              !isUnparenthesizedInAssign) && [\"expression\", true],\n          },\n          type,\n        ) || super.isValidLVal(type, isUnparenthesizedInAssign, binding)\n      );\n    }\n\n    parseBindingAtom(): N.Pattern {\n      if (this.state.type === tt._this) {\n        return this.parseIdentifier(/* liberal */ true);\n      }\n      return super.parseBindingAtom();\n    }\n\n    parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\n      // handles `@f<<T>`\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n\n        if (this.match(tt.parenL)) {\n          const call = super.parseMaybeDecoratorArguments(expr);\n          call.typeParameters = typeArguments;\n          return call;\n        }\n\n        this.unexpected(null, tt.parenL);\n      }\n\n      return super.parseMaybeDecoratorArguments(expr);\n    }\n\n    checkCommaAfterRest(\n      close: (typeof charCodes)[keyof typeof charCodes],\n    ): boolean {\n      if (\n        this.state.isAmbientContext &&\n        this.match(tt.comma) &&\n        this.lookaheadCharCode() === close\n      ) {\n        this.next();\n        return false;\n      }\n      return super.checkCommaAfterRest(close);\n    }\n\n    // === === === === === === === === === === === === === === === ===\n    // Note: All below methods are duplicates of something in flow.js.\n    // Not sure what the best way to combine these is.\n    // === === === === === === === === === === === === === === === ===\n\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    isClassProperty(): boolean {\n      return (\n        this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()\n      );\n    }\n\n    parseMaybeDefault(\n      startLoc?: Position | null,\n      left?: Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(TSErrors.TypeAnnotationAfterAssign, {\n          at: node.typeAnnotation,\n        });\n      }\n\n      return node;\n    }\n\n    // ensure that inside types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      if (this.state.inType) {\n        if (code === charCodes.greaterThan) {\n          this.finishOp(tt.gt, 1);\n          return;\n        }\n        if (code === charCodes.lessThan) {\n          this.finishOp(tt.lt, 1);\n          return;\n        }\n      }\n      super.getTokenFromCode(code);\n    }\n\n    // used after we have finished parsing types\n    reScan_lt_gt() {\n      const { type } = this.state;\n      if (type === tt.lt) {\n        this.state.pos -= 1;\n        this.readToken_lt();\n      } else if (type === tt.gt) {\n        this.state.pos -= 1;\n        this.readToken_gt();\n      }\n    }\n\n    reScan_lt() {\n      const { type } = this.state;\n      if (type === tt.bitShiftL) {\n        this.state.pos -= 2;\n        this.finishOp(tt.lt, 1);\n        return tt.lt;\n      }\n      return type;\n    }\n\n    toAssignableList(\n      exprList: Expression[],\n      trailingCommaLoc: Position | undefined | null,\n      isLHS: boolean,\n    ): void {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TSTypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(\n            expr as N.TsTypeCastExpression,\n          );\n        }\n      }\n      super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n    }\n\n    typeCastToParameter(node: N.TsTypeCastExpression): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    shouldParseArrow(params: Array<N.Node>) {\n      if (this.match(tt.colon)) {\n        return params.every(expr => this.isAssignable(expr, true));\n      }\n      return super.shouldParseArrow(params);\n    }\n\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    canHaveLeadingDecorator() {\n      // Avoid unnecessary lookahead in checking for abstract class unless needed!\n      return super.canHaveLeadingDecorator() || this.isAbstractClass();\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      // handles `<Component<<T>`\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        const typeArguments = this.tsTryParseAndCatch(() =>\n          // @ts-expect-error: refine typings\n          this.tsParseTypeArgumentsInExpression(),\n        );\n        // @ts-expect-error: refine typings\n        if (typeArguments) node.typeParameters = typeArguments;\n      }\n      return super.jsxParseOpeningElementAfterName(node);\n    }\n\n    getGetterSetterExpectedParamCount(\n      method: N.ObjectMethod | N.ClassMethod,\n    ): number {\n      const baseCount = super.getGetterSetterExpectedParamCount(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      const firstParam = params[0];\n      const hasContextParam = firstParam && this.isThisParam(firstParam);\n\n      return hasContextParam ? baseCount + 1 : baseCount;\n    }\n\n    parseCatchClauseParam(): N.Pattern {\n      const param = super.parseCatchClauseParam();\n      const type = this.tsTryParseTypeAnnotation();\n\n      if (type) {\n        param.typeAnnotation = type;\n        this.resetEndLocation(param);\n      }\n\n      return param;\n    }\n\n    tsInAmbientContext<T>(cb: () => T): T {\n      const oldIsAmbientContext = this.state.isAmbientContext;\n      this.state.isAmbientContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.isAmbientContext = oldIsAmbientContext;\n      }\n    }\n\n    parseClass<T extends N.Class>(\n      node: Undone<T>,\n      isStatement: boolean,\n      optionalId?: boolean,\n    ): T {\n      const oldInAbstractClass = this.state.inAbstractClass;\n      this.state.inAbstractClass = !!(node as any).abstract;\n      try {\n        return super.parseClass(node, isStatement, optionalId);\n      } finally {\n        this.state.inAbstractClass = oldInAbstractClass;\n      }\n    }\n\n    tsParseAbstractDeclaration(\n      node: any,\n      decorators: N.Decorator[] | null,\n    ): N.ClassDeclaration | N.TsInterfaceDeclaration | undefined | null {\n      if (this.match(tt._class)) {\n        node.abstract = true;\n        return this.maybeTakeDecorators(\n          decorators,\n          this.parseClass<N.ClassDeclaration>(\n            node as N.ClassDeclaration,\n            /* isStatement */ true,\n            /* optionalId */ false,\n          ),\n        );\n      } else if (this.isContextual(tt._interface)) {\n        // for invalid abstract interface\n\n        // To avoid\n        //   abstract interface\n        //   Foo {}\n        if (!this.hasFollowingLineBreak()) {\n          node.abstract = true;\n          this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {\n            at: node,\n          });\n          return this.tsParseInterfaceDeclaration(\n            node as N.TsInterfaceDeclaration,\n          );\n        }\n      } else {\n        this.unexpected(null, tt._class);\n      }\n    }\n\n    parseMethod<\n      T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod,\n    >(\n      node: Undone<T>,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: T[\"type\"],\n      inClassScope?: boolean,\n    ) {\n      const method = super.parseMethod<T>(\n        node,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      // @ts-expect-error todo(flow->ts) property not defined for all types in union\n      if (method.abstract) {\n        const hasBody = this.hasPlugin(\"estree\")\n          ? // @ts-expect-error estree typings\n            !!method.value.body\n          : !!method.body;\n        if (hasBody) {\n          const { key } = method;\n          this.raise(TSErrors.AbstractMethodHasImplementation, {\n            at: method,\n            methodName:\n              key.type === \"Identifier\" && !method.computed\n                ? key.name\n                : `[${this.input.slice(key.start, key.end)}]`,\n          });\n        }\n      }\n      return method;\n    }\n\n    tsParseTypeParameterName(): N.Identifier | string {\n      const typeName: N.Identifier = this.parseIdentifier();\n      return process.env.BABEL_8_BREAKING ? typeName : typeName.name;\n    }\n\n    shouldParseAsAmbientContext(): boolean {\n      return !!this.getPluginOption(\"typescript\", \"dts\");\n    }\n\n    parse() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.parse();\n    }\n\n    getExpression() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.getExpression();\n    }\n\n    parseExportSpecifier(\n      node: Undone<N.ExportSpecifier>,\n      isString: boolean,\n      isInTypeExport: boolean,\n      isMaybeTypeOnly: boolean,\n    ) {\n      if (!isString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          node,\n          /* isImport */ false,\n          isInTypeExport,\n        );\n        return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n      }\n      node.exportKind = \"value\";\n      return super.parseExportSpecifier(\n        node,\n        isString,\n        isInTypeExport,\n        isMaybeTypeOnly,\n      );\n    }\n\n    parseImportSpecifier(\n      specifier: Undone<N.ImportSpecifier>,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      isMaybeTypeOnly: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType: BindingTypes | undefined,\n    ): N.ImportSpecifier {\n      if (!importedIsString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          specifier,\n          /* isImport */ true,\n          isInTypeOnlyImport,\n        );\n        return this.finishNode<N.ImportSpecifier>(specifier, \"ImportSpecifier\");\n      }\n      specifier.importKind = \"value\";\n      return super.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        isInTypeOnlyImport,\n        isMaybeTypeOnly,\n        isInTypeOnlyImport\n          ? BindingFlag.TYPE_TS_TYPE_IMPORT\n          : BindingFlag.TYPE_TS_VALUE_IMPORT,\n      );\n    }\n\n    parseTypeOnlyImportExportSpecifier(\n      node: any,\n      isImport: boolean,\n      isInTypeOnlyImportExport: boolean,\n    ): void {\n      const leftOfAsKey = isImport ? \"imported\" : \"local\";\n      const rightOfAsKey = isImport ? \"local\" : \"exported\";\n\n      let leftOfAs = node[leftOfAsKey];\n      let rightOfAs;\n\n      let hasTypeSpecifier = false;\n      let canParseAsKeyword = true;\n\n      const loc = leftOfAs.loc.start;\n\n      // https://github.com/microsoft/TypeScript/blob/fc4f9d83d5939047aa6bb2a43965c6e9bbfbc35b/src/compiler/parser.ts#L7411-L7456\n      // import { type } from \"mod\";          - hasTypeSpecifier: false, leftOfAs: type\n      // import { type as } from \"mod\";       - hasTypeSpecifier: true,  leftOfAs: as\n      // import { type as as } from \"mod\";    - hasTypeSpecifier: false, leftOfAs: type, rightOfAs: as\n      // import { type as as as } from \"mod\"; - hasTypeSpecifier: true,  leftOfAs: as,   rightOfAs: as\n      if (this.isContextual(tt._as)) {\n        // { type as ...? }\n        const firstAs = this.parseIdentifier();\n        if (this.isContextual(tt._as)) {\n          // { type as as ...? }\n          const secondAs = this.parseIdentifier();\n          if (tokenIsKeywordOrIdentifier(this.state.type)) {\n            // { type as as something }\n            hasTypeSpecifier = true;\n            leftOfAs = firstAs;\n            rightOfAs = isImport\n              ? this.parseIdentifier()\n              : this.parseModuleExportName();\n            canParseAsKeyword = false;\n          } else {\n            // { type as as }\n            rightOfAs = secondAs;\n            canParseAsKeyword = false;\n          }\n        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          // { type as something }\n          canParseAsKeyword = false;\n          rightOfAs = isImport\n            ? this.parseIdentifier()\n            : this.parseModuleExportName();\n        } else {\n          // { type as }\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        // { type something ...? }\n        hasTypeSpecifier = true;\n        if (isImport) {\n          leftOfAs = this.parseIdentifier(true);\n          if (!this.isContextual(tt._as)) {\n            this.checkReservedWord(\n              leftOfAs.name,\n              leftOfAs.loc.start,\n              true,\n              true,\n            );\n          }\n        } else {\n          leftOfAs = this.parseModuleExportName();\n        }\n      }\n      if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n        this.raise(\n          isImport\n            ? TSErrors.TypeModifierIsUsedInTypeImports\n            : TSErrors.TypeModifierIsUsedInTypeExports,\n          { at: loc },\n        );\n      }\n\n      node[leftOfAsKey] = leftOfAs;\n      node[rightOfAsKey] = rightOfAs;\n\n      const kindKey = isImport ? \"importKind\" : \"exportKind\";\n      node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n\n      if (canParseAsKeyword && this.eatContextual(tt._as)) {\n        node[rightOfAsKey] = isImport\n          ? this.parseIdentifier()\n          : this.parseModuleExportName();\n      }\n      if (!node[rightOfAsKey]) {\n        node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n      }\n      if (isImport) {\n        this.checkIdentifier(\n          node[rightOfAsKey],\n          hasTypeSpecifier\n            ? BindingFlag.TYPE_TS_TYPE_IMPORT\n            : BindingFlag.TYPE_TS_VALUE_IMPORT,\n        );\n      }\n    }\n  };\n\nfunction isPossiblyLiteralEnum(expression: N.Expression): boolean {\n  if (expression.type !== \"MemberExpression\") return false;\n\n  const { computed, property } = expression;\n\n  if (\n    computed &&\n    property.type !== \"StringLiteral\" &&\n    (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)\n  ) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\n// If a const declaration has no type annotation and is initialized to\n// a string literal, numeric literal, or enum reference, then it is\n// allowed. In an ideal world, we'd check whether init was *actually* an\n// enum reference, but we allow anything that \"could be\" a literal enum\n// in `isPossiblyLiteralEnum` since we don't have all the information\n// that the typescript compiler has.\nfunction isValidAmbientConstInitializer(\n  expression: N.Expression,\n  estree: boolean,\n): boolean {\n  const { type } = expression;\n  if (expression.extra?.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === \"Literal\") {\n      const { value } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\n\nfunction isNumber(expression: N.Expression, estree: boolean): boolean {\n  if (estree) {\n    return (\n      expression.type === \"Literal\" &&\n      (typeof expression.value === \"number\" || \"bigint\" in expression)\n    );\n  }\n  return (\n    expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\"\n  );\n}\n\nfunction isNegativeNumber(expression: N.Expression, estree: boolean): boolean {\n  if (expression.type === \"UnaryExpression\") {\n    const { operator, argument } = expression as N.UnaryExpression;\n    if (operator === \"-\" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isUncomputedMemberExpressionChain(expression: N.Expression): boolean {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n", "import * as charCodes from \"charcodes\";\n\nimport { tokenLabelName, tt } from \"../tokenizer/types.ts\";\nimport type Parser from \"../parser/index.ts\";\nimport type * as N from \"../types.ts\";\nimport { ParseErrorEnum } from \"../parse-error.ts\";\nimport type { Undone } from \"../parser/node.ts\";\nimport type { ExpressionErrors } from \"../parser/util.ts\";\nimport type { BindingTypes } from \"../util/scopeflags.ts\";\nimport type { Position } from \"../util/location.ts\";\n\ntype PossiblePlaceholders = {\n  Identifier: N.Identifier;\n  StringLiteral: N.StringLiteral;\n  Expression: N.Expression;\n  Statement: N.Statement;\n  Declaration: N.Declaration;\n  BlockStatement: N.BlockStatement;\n  ClassBody: N.ClassBody;\n  Pattern: N.Pattern;\n};\nexport type PlaceholderTypes = keyof PossiblePlaceholders;\n\ntype NodeOf<T extends keyof PossiblePlaceholders> = PossiblePlaceholders[T];\n// todo: when there  is proper union type for Node\n// type NodeOf<T extends PlaceholderTypes> = Extract<N.Node, { type: T }>;\n\n// todo: Placeholder<T> breaks everything, because its type is incompatible with\n// the substituted nodes.\ntype MaybePlaceholder<T extends PlaceholderTypes> = NodeOf<T>; // | Placeholder<T>\n\n/* eslint sort-keys: \"error\" */\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\",\n});\n\n/* eslint-disable sort-keys */\n\nexport default (superClass: typeof Parser) =>\n  class PlaceholdersParserMixin extends superClass implements Parser {\n    parsePlaceholder<T extends PlaceholderTypes>(\n      expectedNode: T,\n    ): /*?N.Placeholder<T>*/ MaybePlaceholder<T> | undefined | null {\n      if (this.match(tt.placeholder)) {\n        const node = this.startNode();\n        this.next();\n        this.assertNoSpace();\n\n        // We can't use this.parseIdentifier because\n        // we don't want nested placeholders.\n        node.name = super.parseIdentifier(/* liberal */ true);\n\n        this.assertNoSpace();\n        this.expect(tt.placeholder);\n        // @ts-expect-error placeholder typings\n        return this.finishPlaceholder(node, expectedNode);\n      }\n    }\n\n    finishPlaceholder<T extends PlaceholderTypes>(\n      node: N.Node,\n      expectedNode: T,\n    ): /*N.Placeholder<T>*/ MaybePlaceholder<T> {\n      const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n      node.expectedNode = expectedNode;\n\n      // @ts-expect-error todo(flow->ts)\n      return isFinished ? node : this.finishNode(node, \"Placeholder\");\n    }\n\n    /* ============================================================ *\n     * tokenizer/index.js                                           *\n     * ============================================================ */\n\n    getTokenFromCode(code: number) {\n      if (\n        code === charCodes.percentSign &&\n        this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign\n      ) {\n        this.finishOp(tt.placeholder, 2);\n      } else {\n        super.getTokenFromCode(code);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(\n      refExpressionErrors?: ExpressionErrors | null,\n    ): MaybePlaceholder<\"Expression\"> {\n      return (\n        this.parsePlaceholder(\"Expression\") ||\n        super.parseExprAtom(refExpressionErrors)\n      );\n    }\n\n    parseIdentifier(liberal?: boolean): MaybePlaceholder<\"Identifier\"> {\n      // NOTE: This function only handles identifiers outside of\n      // expressions and binding patterns, since they are already\n      // handled by the parseExprAtom and parseBindingAtom functions.\n      // This is needed, for example, to parse \"class %%NAME%% {}\".\n      return (\n        this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal)\n      );\n    }\n\n    checkReservedWord(\n      word: string,\n      startLoc: Position,\n      checkKeywords: boolean,\n      isBinding: boolean,\n    ) {\n      // Sometimes we call #checkReservedWord(node.name), expecting\n      // that node is an Identifier. If it is a Placeholder, name\n      // will be undefined.\n      if (word !== undefined) {\n        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/lval.js                                               *\n     * ============================================================ */\n\n    parseBindingAtom(): MaybePlaceholder<\"Pattern\"> {\n      return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingTypes) {\n      return (\n        type === \"Placeholder\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean): void {\n      if (\n        node &&\n        node.type === \"Placeholder\" &&\n        node.expectedNode === \"Expression\"\n      ) {\n        node.expectedNode = \"Pattern\";\n      } else {\n        super.toAssignable(node, isLHS);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/statement.js                                          *\n     * ============================================================ */\n\n    chStartsBindingIdentifier(ch: number, pos: number): boolean {\n      if (super.chStartsBindingIdentifier(ch, pos)) {\n        return true;\n      }\n\n      // Accept \"let %%\" as the start of \"let %%placeholder%%\", as though the\n      // placeholder were an identifier.\n      const nextToken = this.lookahead();\n      if (nextToken.type === tt.placeholder) {\n        return true;\n      }\n\n      return false;\n    }\n\n    verifyBreakContinue(\n      node: N.BreakStatement | N.ContinueStatement,\n      isBreak: boolean,\n    ) {\n      // @ts-expect-error: node.label could be Placeholder\n      if (node.label && node.label.type === \"Placeholder\") return;\n      super.verifyBreakContinue(node, isBreak);\n    }\n\n    // @ts-expect-error Plugin will override parser interface\n    parseExpressionStatement(\n      node: MaybePlaceholder<\"Statement\">,\n      expr: N.Expression,\n    ): MaybePlaceholder<\"Statement\"> {\n      if (expr.type !== \"Placeholder\" || expr.extra?.parenthesized) {\n        // @ts-expect-error placeholder typings\n        return super.parseExpressionStatement(node, expr);\n      }\n\n      if (this.match(tt.colon)) {\n        // @ts-expect-error placeholder typings\n        const stmt: N.LabeledStatement = node;\n        stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n        this.next();\n        stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n        return this.finishNode(stmt, \"LabeledStatement\");\n      }\n\n      this.semicolon();\n      node.name = expr.name;\n      return this.finishPlaceholder(node, \"Statement\");\n    }\n\n    parseBlock(\n      allowDirectives?: boolean,\n      createNewLexicalScope?: boolean,\n      afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n    ): MaybePlaceholder<\"BlockStatement\"> {\n      return (\n        this.parsePlaceholder(\"BlockStatement\") ||\n        super.parseBlock(\n          allowDirectives,\n          createNewLexicalScope,\n          afterBlockParse,\n        )\n      );\n    }\n\n    parseFunctionId(\n      requireId?: boolean,\n    ): MaybePlaceholder<\"Identifier\"> | undefined | null {\n      return (\n        this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId)\n      );\n    }\n    // @ts-expect-error Plugin will override parser interface\n    parseClass<T extends N.Class>(\n      node: T,\n      isStatement: /* T === ClassDeclaration */ boolean,\n      optionalId?: boolean,\n    ): T {\n      const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n\n      this.next();\n      const oldStrict = this.state.strict;\n\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (placeholder) {\n        if (\n          this.match(tt._extends) ||\n          this.match(tt.placeholder) ||\n          this.match(tt.braceL)\n        ) {\n          node.id = placeholder;\n        } else if (optionalId || !isStatement) {\n          node.id = null;\n          node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n          return this.finishNode(node, type);\n        } else {\n          throw this.raise(PlaceholderErrors.ClassNameIsRequired, {\n            at: this.state.startLoc,\n          });\n        }\n      } else {\n        this.parseClassId(node, isStatement, optionalId);\n      }\n\n      super.parseClassSuper(node);\n      node.body =\n        this.parsePlaceholder(\"ClassBody\") ||\n        super.parseClassBody(!!node.superClass, oldStrict);\n      return this.finishNode(node, type);\n    }\n\n    parseExport(node: N.Node, decorators: N.Decorator[] | null): N.AnyExport {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseExport(node, decorators);\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // export %%DECL%%;\n        node.specifiers = [];\n        node.source = null;\n        node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n      }\n\n      // export %%NAME%% from \"foo\";\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = placeholder;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n\n      return super.parseExport(node, decorators);\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.match(tt._default)) {\n        const next = this.nextTokenStart();\n        if (this.isUnparsedContextual(next, \"from\")) {\n          if (\n            this.input.startsWith(\n              tokenLabelName(tt.placeholder),\n              this.nextTokenStartSince(next + 4),\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n      return super.isExportDefaultSpecifier();\n    }\n\n    maybeParseExportDefaultSpecifier(\n      node: Undone<\n        | N.ExportDefaultDeclaration\n        | N.ExportAllDeclaration\n        | N.ExportNamedDeclaration\n      >,\n      maybeDefaultIdentifier: N.Identifier | null,\n    ): node is Undone<N.ExportNamedDeclaration> {\n      if ((node as N.ExportNamedDeclaration).specifiers?.length) {\n        // \"export %%NAME%%\" has already been parsed by #parseExport.\n        return true;\n      }\n      return super.maybeParseExportDefaultSpecifier(\n        node,\n        maybeDefaultIdentifier,\n      );\n    }\n\n    checkExport(node: N.ExportNamedDeclaration): void {\n      const { specifiers } = node;\n      if (specifiers?.length) {\n        node.specifiers = specifiers.filter(\n          // @ts-expect-error placeholder typings\n          node => node.exported.type === \"Placeholder\",\n        );\n      }\n      super.checkExport(node);\n      node.specifiers = specifiers;\n    }\n\n    parseImport(\n      node: Undone<N.ImportDeclaration>,\n    ): N.ImportDeclaration | N.TsImportEqualsDeclaration {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseImport(node);\n\n      node.specifiers = [];\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // import %%STRING%%;\n        node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n      }\n\n      // import %%DEFAULT%% ...\n      const specifier =\n        this.startNodeAtNode<N.ImportDefaultSpecifier>(placeholder);\n      specifier.local = placeholder;\n      node.specifiers.push(\n        this.finishNode(specifier, \"ImportDefaultSpecifier\"),\n      );\n\n      if (this.eat(tt.comma)) {\n        // import %%DEFAULT%%, * as ...\n        const hasStarImport = this.maybeParseStarImportSpecifier(node);\n\n        // import %%DEFAULT%%, { ...\n        if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n      }\n\n      this.expectContextual(tt._from);\n      node.source = this.parseImportSource();\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportSource(): MaybePlaceholder<\"StringLiteral\"> {\n      // import ... from %%STRING%%;\n\n      return (\n        this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource()\n      );\n    }\n\n    // Throws if the current token and the prev one are separated by a space.\n    assertNoSpace(): void {\n      if (this.state.start > this.state.lastTokEndLoc.index) {\n        this.raise(PlaceholderErrors.UnexpectedSpace, {\n          at: this.state.lastTokEndLoc,\n        });\n      }\n    }\n  };\n", "import type Parser from \"../parser/index.ts\";\nimport { tokenIsIdentifier, tt } from \"../tokenizer/types.ts\";\nimport type * as N from \"../types.ts\";\nimport type { ExpressionErrors } from \"../parser/util.ts\";\n\nexport default (superClass: typeof Parser) =>\n  class V8IntrinsicMixin extends superClass implements Parser {\n    parseV8Intrinsic(): N.Expression {\n      if (this.match(tt.modulo)) {\n        const v8IntrinsicStartLoc = this.state.startLoc;\n        // let the `loc` of Identifier starts from `%`\n        const node = this.startNode<N.Identifier>();\n        this.next(); // eat '%'\n        if (tokenIsIdentifier(this.state.type)) {\n          const name = this.parseIdentifierName();\n          const identifier = this.createIdentifier(node, name);\n          // @ts-expect-error: avoid mutating AST types\n          identifier.type = \"V8IntrinsicIdentifier\";\n          if (this.match(tt.parenL)) {\n            return identifier;\n          }\n        }\n        this.unexpected(v8IntrinsicStartLoc);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(refExpressionErrors?: ExpressionErrors | null): N.Expression {\n      return (\n        this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors)\n      );\n    }\n  };\n", "import type Parser from \"./parser/index.ts\";\nimport type {\n  ParserPluginWithOptions,\n  PluginConfig,\n  PluginOptions,\n} from \"./typings.ts\";\n\nexport type Plugin = PluginConfig;\n\nexport type PluginList = PluginConfig[];\n\nexport type MixinPlugin = (superClass: { new (...args: any): Parser }) => {\n  new (...args: any): Parser;\n};\n\n// This function\u2019s second parameter accepts either a string (plugin name) or an\n// array pair (plugin name and options object). If an options object is given,\n// then each value is non-recursively checked for identity with the actual\n// option value of each plugin in the first argument (which is an array of\n// plugin names or array pairs).\nexport function hasPlugin(\n  plugins: PluginList,\n  expectedConfig: PluginConfig,\n): boolean {\n  // The expectedOptions object is by default an empty object if the given\n  // expectedConfig argument does not give an options object (i.e., if it is a\n  // string).\n  const [expectedName, expectedOptions] =\n    typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n\n  const expectedKeys = Object.keys(expectedOptions);\n\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n\n  return plugins.some(p => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n      if (pluginName !== expectedName) {\n        return false;\n      }\n      for (const key of expectedKeys) {\n        // @ts-expect-error key may not exist in plugin options\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n}\n\nexport function getPluginOption<\n  PluginName extends ParserPluginWithOptions[0],\n  OptionName extends keyof PluginOptions<PluginName>,\n>(plugins: PluginList, name: PluginName, option: OptionName) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin) && plugin.length > 1) {\n    return (plugin[1] as PluginOptions<PluginName>)[option];\n  }\n\n  return null;\n}\n\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\n\nexport function validatePlugins(plugins: PluginList) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\n        \"Cannot use the decorators and decorators-legacy plugin together\",\n      );\n    }\n\n    const decoratorsBeforeExport = getPluginOption(\n      plugins,\n      \"decorators\",\n      \"decoratorsBeforeExport\",\n    );\n    if (\n      decoratorsBeforeExport != null &&\n      typeof decoratorsBeforeExport !== \"boolean\"\n    ) {\n      throw new Error(\n        \"'decoratorsBeforeExport' must be a boolean, if specified.\",\n      );\n    }\n\n    const allowCallParenthesized = getPluginOption(\n      plugins,\n      \"decorators\",\n      \"allowCallParenthesized\",\n    );\n    if (\n      allowCallParenthesized != null &&\n      typeof allowCallParenthesized !== \"boolean\"\n    ) {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(\n        `\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`,\n      );\n    }\n\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\n      \"recordAndTuple\",\n      { syntaxType: \"hash\" },\n    ]);\n\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\n          \"Cannot combine placeholders plugin and Hack-style pipes.\",\n        );\n      }\n\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\n          \"Cannot combine v8intrinsic plugin and Hack-style pipes.\",\n        );\n      }\n\n      const topicToken = getPluginOption(\n        plugins,\n        \"pipelineOperator\",\n        \"topicToken\",\n      );\n\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n\n        throw new Error(\n          `\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`,\n        );\n      }\n\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error(\n          'Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.',\n        );\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error(\n        'Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.',\n      );\n    }\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    if (process.env.BABEL_8_BREAKING) {\n      throw new Error(\n        \"`moduleAttributes` has been removed in Babel 8, please use `importAttributes` parser plugin, or `@babel/plugin-syntax-import-attributes`.\",\n      );\n    } else {\n      if (\n        hasPlugin(plugins, \"importAssertions\") ||\n        hasPlugin(plugins, \"importAttributes\")\n      ) {\n        throw new Error(\n          \"Cannot combine importAssertions, importAttributes and moduleAttributes plugins.\",\n        );\n      }\n      const moduleAttributesVersionPluginOption = getPluginOption(\n        plugins,\n        \"moduleAttributes\",\n        \"version\",\n      );\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\n          \"The 'moduleAttributes' plugin requires a 'version' option,\" +\n            \" representing the last proposal update. Currently, the\" +\n            \" only supported value is 'may-2020'.\",\n        );\n      }\n    }\n  }\n  if (\n    hasPlugin(plugins, \"importAssertions\") &&\n    hasPlugin(plugins, \"importAttributes\")\n  ) {\n    throw new Error(\n      \"Cannot combine importAssertions and importAttributes plugins.\",\n    );\n  }\n\n  if (\n    hasPlugin(plugins, \"recordAndTuple\") &&\n    getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") != null &&\n    !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(\n      getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"),\n    )\n  ) {\n    throw new Error(\n      \"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" +\n        RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"),\n    );\n  }\n\n  if (\n    hasPlugin(plugins, \"asyncDoExpressions\") &&\n    !hasPlugin(plugins, \"doExpressions\")\n  ) {\n    const error = new Error(\n      \"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\",\n    );\n    // @ts-expect-error so @babel/core can provide better error message\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n\n  if (\n    hasPlugin(plugins, \"optionalChainingAssign\") &&\n    getPluginOption(plugins, \"optionalChainingAssign\", \"version\") !== \"2023-07\"\n  ) {\n    throw new Error(\n      \"The 'optionalChainingAssign' plugin requires a 'version' option,\" +\n        \" representing the last proposal update. Currently, the\" +\n        \" only supported value is '2023-07'.\",\n    );\n  }\n}\n\n// These plugins are defined using a mixin which extends the parser class.\n\nimport estree from \"./plugins/estree.ts\";\nimport flow from \"./plugins/flow/index.ts\";\nimport jsx from \"./plugins/jsx/index.ts\";\nimport typescript from \"./plugins/typescript/index.ts\";\nimport placeholders from \"./plugins/placeholders.ts\";\nimport v8intrinsic from \"./plugins/v8intrinsic.ts\";\n\n// NOTE: order is important. estree must come first; placeholders must come last.\nexport const mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders,\n};\n\nexport const mixinPluginNames = Object.keys(mixinPlugins) as ReadonlyArray<\n  \"estree\" | \"jsx\" | \"flow\" | \"typescript\" | \"v8intrinsic\" | \"placeholders\"\n>;\n", "import type { PluginList } from \"./plugin-utils.ts\";\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nexport type SourceType = \"script\" | \"module\" | \"unambiguous\";\n\nexport type Options = {\n  sourceType: SourceType;\n  sourceFilename?: string;\n  startColumn: number;\n  startLine: number;\n  allowAwaitOutsideFunction: boolean;\n  allowReturnOutsideFunction: boolean;\n  allowNewTargetOutsideFunction: boolean;\n  allowImportExportEverywhere: boolean;\n  allowSuperOutsideMethod: boolean;\n  allowUndeclaredExports: boolean;\n  plugins: PluginList;\n  strictMode: boolean | undefined | null;\n  ranges: boolean;\n  tokens: boolean;\n  createImportExpressions: boolean;\n  createParenthesizedExpressions: boolean;\n  errorRecovery: boolean;\n  attachComment: boolean;\n  annexB: boolean;\n};\n\nexport const defaultOptions: Options = {\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // Source filename.\n  sourceFilename: undefined,\n  // Column (0-based) from which to start counting source. Useful for\n  // integration with other tools.\n  startColumn: 0,\n  // Line (1-based) from which to start counting source. Useful for\n  // integration with other tools.\n  startLine: 1,\n  // When enabled, await at the top level is not considered an\n  // error.\n  allowAwaitOutsideFunction: false,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, new.target outside a function or class is not\n  // considered an error.\n  allowNewTargetOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // TODO\n  allowSuperOutsideMethod: false,\n  // When enabled, export statements can reference undeclared variables.\n  allowUndeclaredExports: false,\n  // An array of plugins to enable\n  plugins: [],\n  // TODO\n  strictMode: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // Adds all parsed tokens to a `tokens` property on the `File` node\n  tokens: false,\n  // Whether to create ImportExpression AST nodes (if false\n  // `import(foo)` will be parsed as CallExpression(Import, [Identifier(foo)])\n  createImportExpressions: false,\n  // Whether to create ParenthesizedExpression AST nodes (if false\n  // the parser sets extra.parenthesized on the expression nodes instead).\n  createParenthesizedExpressions: false,\n  // When enabled, errors are attached to the AST instead of being directly thrown.\n  // Some errors will still throw, because @babel/parser can't always recover.\n  errorRecovery: false,\n  // When enabled, comments will be attached to adjacent AST nodes as one of\n  // `leadingComments`, `trailingComments` and `innerComments`. The comment attachment\n  // is vital to preserve comments after transform. If you don't print AST back,\n  // consider set this option to `false` for performance\n  attachComment: true,\n  // When enabled, the parser will support Annex B syntax.\n  // https://tc39.es/ecma262/#sec-additional-ecmascript-features-for-web-browsers\n  annexB: true,\n};\n\n// Interpret and default an options object\n\nexport function getOptions(opts?: Options | null): Options {\n  if (opts == null) {\n    return { ...defaultOptions };\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n\n  const options: any = {};\n  for (const key of Object.keys(defaultOptions) as (keyof Options)[]) {\n    options[key] = opts[key] ?? defaultOptions[key];\n  }\n  return options;\n}\n", "// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts \u2014 that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  tokenCanStartExpression,\n  tokenIsAssignment,\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsOperator,\n  tokenIsPostfix,\n  tokenIsPrefix,\n  tokenIsRightAssociative,\n  tokenIsTemplate,\n  tokenKeywordOrIdentifierIsKeyword,\n  tokenLabelName,\n  tokenOperatorPrecedence,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types.ts\";\nimport type * as N from \"../types.ts\";\nimport LValParser from \"./lval.ts\";\nimport {\n  isKeyword,\n  isReservedWord,\n  isStrictReservedWord,\n  isStrictBindReservedWord,\n  isIdentifierStart,\n  canBeReservedWord,\n} from \"../util/identifier.ts\";\nimport {\n  type Position,\n  createPositionWithColumnOffset,\n} from \"../util/location.ts\";\nimport * as charCodes from \"charcodes\";\nimport { ScopeFlag, BindingFlag } from \"../util/scopeflags.ts\";\nimport { ExpressionErrors } from \"./util.ts\";\nimport { ParamKind, functionFlags } from \"../util/production-parameter.ts\";\nimport {\n  newArrowHeadScope,\n  newAsyncArrowScope,\n  newExpressionScope,\n} from \"../util/expression-scope.ts\";\nimport { Errors, type ParseError } from \"../parse-error.ts\";\nimport { UnparenthesizedPipeBodyDescriptions } from \"../parse-error/pipeline-operator-errors.ts\";\nimport { setInnerComments } from \"./comments.ts\";\nimport { cloneIdentifier, type Undone } from \"./node.ts\";\nimport type Parser from \"./index.ts\";\n\nimport type { SourceType } from \"../options.ts\";\n\nexport default abstract class ExpressionParser extends LValParser {\n  // Forward-declaration: defined in statement.js\n  abstract parseBlock(\n    allowDirectives?: boolean,\n    createNewLexicalScope?: boolean,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement;\n  abstract parseClass(\n    node: N.Class,\n    isStatement: boolean,\n    optionalId?: boolean,\n  ): N.Class;\n  abstract parseDecorators(allowExport?: boolean): void;\n  abstract parseFunction<T extends N.NormalFunction>(\n    node: T,\n    statement?: number,\n    allowExpressionBody?: boolean,\n    isAsync?: boolean,\n  ): T;\n  abstract parseFunctionParams(node: N.Function, isConstructor?: boolean): void;\n  abstract parseBlockOrModuleBlockBody(\n    body: N.Statement[],\n    directives: N.Directive[] | null | undefined,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void;\n  abstract parseProgram(\n    program: N.Program,\n    end: TokenType,\n    sourceType?: SourceType,\n  ): N.Program;\n\n  // For object literal, check if property __proto__ has been used more than once.\n  // If the expression is a destructuring assignment, then __proto__ may appear\n  // multiple times. Otherwise, __proto__ is a duplicated key.\n\n  // For record expression, check if property __proto__ exists\n\n  checkProto(\n    prop: N.ObjectMember | N.SpreadElement,\n    isRecord: boolean | undefined | null,\n    protoRef: {\n      used: boolean;\n    },\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void {\n    if (\n      prop.type === \"SpreadElement\" ||\n      this.isObjectMethod(prop) ||\n      prop.computed ||\n      // @ts-expect-error prop must be an ObjectProperty\n      prop.shorthand\n    ) {\n      return;\n    }\n\n    const key = prop.key;\n    // It is either an Identifier or a String/NumericLiteral\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, { at: key });\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          // Store the first redefinition's position, otherwise ignore because\n          // we are parsing ambiguous pattern\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, { at: key });\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr: N.Expression, potentialArrowAt: number): boolean {\n    return (\n      expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt\n    );\n  }\n\n  // Convenience method to parse an Expression only\n  getExpression(this: Parser): N.Expression & N.ParserOutput {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(tt.eof)) {\n      this.unexpected();\n    }\n    // Unlike parseTopLevel, we need to drain remaining commentStacks\n    // because the top level node is _not_ Program.\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    // @ts-expect-error fixme: refine types\n    return expr;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function (s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression.\n  // - `disallowIn`\n  //   is used to forbid the `in` operator (in for loops initialization expressions)\n  //   When `disallowIn` is true, the production parameter [In] is not present.\n\n  // - `refExpressionErrors `\n  //   provides reference for storing '=' operator inside shorthand\n  //   property assignment in contexts where both object expression\n  //   and object pattern might appear (so it's possible to raise\n  //   delayed syntax error at correct position).\n\n  parseExpression(\n    this: Parser,\n    disallowIn?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    if (disallowIn) {\n      return this.disallowInAnd(() =>\n        this.parseExpressionBase(refExpressionErrors),\n      );\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  // https://tc39.es/ecma262/#prod-Expression\n  parseExpressionBase(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(tt.comma)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(tt.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Set [~In] parameter for assignment expression\n  parseMaybeAssignDisallowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.disallowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // Set [+In] parameter for assignment expression\n  parseMaybeAssignAllowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.allowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // This method is only used by\n  // the typescript and flow plugins.\n  setOptionalParametersError(\n    refExpressionErrors: ExpressionErrors,\n    resultError?: ParseError<any>,\n  ) {\n    refExpressionErrors.optionalParametersLoc =\n      resultError?.loc ?? this.state.startLoc;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n  // https://tc39.es/ecma262/#prod-AssignmentExpression\n  parseMaybeAssign(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(tt._yield)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const { type } = this.state;\n\n    if (type === tt.parenL || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt<N.AssignmentExpression>(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(tt.eq)) {\n        this.toAssignable(left, /* isLHS */ true);\n        node.left = left;\n\n        const startIndex = startLoc.index;\n        if (\n          refExpressionErrors.doubleProtoLoc != null &&\n          refExpressionErrors.doubleProtoLoc.index >= startIndex\n        ) {\n          refExpressionErrors.doubleProtoLoc = null; // reset because double __proto__ is valid in assignment expression\n        }\n        if (\n          refExpressionErrors.shorthandAssignLoc != null &&\n          refExpressionErrors.shorthandAssignLoc.index >= startIndex\n        ) {\n          refExpressionErrors.shorthandAssignLoc = null; // reset because shorthand default was used correctly\n        }\n        if (\n          refExpressionErrors.privateKeyLoc != null &&\n          refExpressionErrors.privateKeyLoc.index >= startIndex\n        ) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null; // reset because `({ #x: x })` is an assignable pattern\n        }\n      } else {\n        node.left = left;\n      }\n\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\"),\n      });\n      // @ts-expect-error todo(flow->ts) improve node types\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n  // https://tc39.es/ecma262/#prod-ConditionalExpression\n\n  parseMaybeConditional(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(\n    this: Parser,\n    expr: N.Expression,\n    startLoc: Position,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (this.eat(tt.question)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression | N.PrivateName {\n    return this.match(tt.privateName)\n      ? this.parsePrivateName()\n      : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  // Start the precedence parser.\n  // https://tc39.es/ecma262/#prod-ShortCircuitExpression\n\n  parseExprOps(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  parseExprOp(\n    this: Parser,\n    left: N.Expression | N.PrivateName,\n    leftStartLoc: Position,\n    minPrec: number,\n  ): N.Expression {\n    if (this.isPrivateName(left)) {\n      // https://tc39.es/ecma262/#prod-RelationalExpression\n      // RelationalExpression [In, Yield, Await]\n      //   [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]\n\n      const value = this.getPrivateNameSV(left);\n\n      if (\n        minPrec >= tokenOperatorPrecedence(tt._in) ||\n        !this.prodParam.hasIn ||\n        !this.match(tt._in)\n      ) {\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: left,\n          identifierName: value,\n        });\n      }\n\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(tt._in))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === tt.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt<N.LogicalExpression | N.BinaryExpression>(\n          leftStartLoc,\n        );\n        node.left = left;\n        node.operator = this.state.value;\n\n        const logical = op === tt.logicalOR || op === tt.logicalAND;\n        const coalesce = op === tt.nullishCoalescing;\n\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = tokenOperatorPrecedence(tt.logicalAND);\n        }\n\n        this.next();\n\n        if (\n          op === tt.pipeline &&\n          this.hasPlugin([\"pipelineOperator\", { proposal: \"minimal\" }])\n        ) {\n          if (this.state.type === tt._await && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {\n              at: this.state.startLoc,\n            });\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(\n          node,\n          logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\",\n        );\n        /* this check is for all ?? operators\n         * a ?? b && c for this example\n         * when op is coalesce and nextOp is logical (&&), throw at the pos of nextOp that it can not be mixed.\n         * Symmetrically it also throws when op is logical and nextOp is coalesce\n         */\n        const nextOp = this.state.type;\n        if (\n          (coalesce && (nextOp === tt.logicalOR || nextOp === tt.logicalAND)) ||\n          (logical && nextOp === tt.nullishCoalescing)\n        ) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, {\n            at: this.state.startLoc,\n          });\n        }\n\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n\n  // Helper function for `parseExprOp`. Parse the right-hand side of binary-\n  // operator expressions, then apply any operator-specific functions.\n\n  parseExprOpRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case tt.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(tt._yield)) {\n                throw this.raise(Errors.PipeBodyIsTighter, {\n                  at: this.state.startLoc,\n                });\n              }\n              return this.parseSmartPipelineBodyInStyle(\n                this.parseExprOpBaseRightExpr(op, prec),\n                startLoc,\n              );\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      // Falls through.\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  // Helper function for `parseExprOpRightExpr`. Parse the right-hand side of\n  // binary-operator expressions without applying any operator-specific functions.\n\n  parseExprOpBaseRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    return this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startLoc,\n      tokenIsRightAssociative(op) ? prec - 1 : prec,\n    );\n  }\n\n  parseHackPipeBody(this: Parser): N.Expression {\n    const { startLoc } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(\n      // @ts-expect-error TS2345: Argument of type 'string' is not assignable to parameter of type '\"ArrowFunctionExpression\" | \"YieldExpression\" | \"AssignmentExpression\" | \"ConditionalExpression\"'.\n      body.type,\n    );\n\n    // TODO: Check how to handle type casts in Flow and TS once they are supported\n    if (requiredParentheses && !body.extra?.parenthesized) {\n      this.raise(Errors.PipeUnparenthesizedBody, {\n        at: startLoc,\n        // @ts-expect-error TS2322: Type 'string' is not assignable to type '\"AssignmentExpression\" | \"ArrowFunctionExpression\" | \"ConditionalExpression\" | \"YieldExpression\"'.\n        type: body.type,\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      // A Hack pipe body must use the topic reference at least once.\n      this.raise(Errors.PipeTopicUnused, { at: startLoc });\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(\n    node: N.AwaitExpression | Undone<N.UnaryExpression>,\n  ) {\n    if (this.match(tt.exponent)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {\n        at: node.argument,\n      });\n    }\n  }\n\n  // Parse unary operators, both prefix and postfix.\n  // https://tc39.es/ecma262/#prod-UnaryExpression\n  parseMaybeUnary(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    sawUnary?: boolean,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(tt._await);\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(tt.incDec);\n    const node = this.startNode<N.UnaryExpression | N.UpdateExpression>();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(tt._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(tt._delete);\n      this.next();\n\n      node.argument = this.parseMaybeUnary(null, true);\n\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, { at: node });\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, { at: node });\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node as Undone<N.UnaryExpression>);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(\n      // @ts-expect-error using \"Undone\" node as \"done\"\n      node,\n      update,\n      refExpressionErrors,\n    );\n\n    if (isAwait) {\n      const { type } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\")\n        ? tokenCanStartExpression(type)\n        : tokenCanStartExpression(type) && !this.match(tt.modulo);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, { at: startLoc });\n        return this.parseAwait(startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  // https://tc39.es/ecma262/#prod-UpdateExpression\n  parseUpdate(\n    this: Parser,\n    node: N.Expression,\n    update: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (update) {\n      // @ts-expect-error Type 'Node' is missing the following properties from type 'Undone<UpdateExpression>': prefix, operator, argument\n      const updateExpressionNode = node as Undone<N.UpdateExpression>;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\"),\n      });\n      return node;\n    }\n\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt<N.UpdateExpression>(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: (expr = this.finishNode(node, \"UpdateExpression\")),\n      });\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n  // https://tc39.es/ecma262/#prod-LeftHandSideExpression\n  parseExprSubscripts(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startLoc);\n  }\n\n  parseSubscripts(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls?: boolean | null,\n  ): N.Expression {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false,\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n\n      // After parsing a subscript, this isn't \"async\" for sure.\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n\n  /**\n   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.\n   *   state.optionalChainMember to indicate that the member is currently in OptionalChain\n   */\n  parseSubscript(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const { type } = this.state;\n    if (!noCalls && type === tt.doubleColon) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (type === tt.questionDot) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, {\n          at: this.state.startLoc,\n        });\n        if (this.lookaheadCharCode() === charCodes.leftParenthesis) {\n          // stop at `?.` when parsing `new a?.()`\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(tt.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(\n        base,\n        startLoc,\n        state,\n        optional,\n      );\n    } else {\n      const computed = this.eat(tt.bracketL);\n      if (computed || optional || this.eat(tt.dot)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  // base[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]\n  // base[?Yield, ?Await] . IdentifierName\n  // base[?Yield, ?Await] . PrivateIdentifier\n  //   where `base` is one of CallExpression, MemberExpression and OptionalChain\n  parseMember(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    computed: boolean,\n    optional: boolean,\n  ): N.OptionalMemberExpression | N.MemberExpression {\n    const node = this.startNodeAt<\n      N.OptionalMemberExpression | N.MemberExpression\n    >(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(tt.bracketR);\n    } else if (this.match(tt.privateName)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, { at: startLoc });\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n\n    if (state.optionalChainMember) {\n      (node as N.OptionalMemberExpression).optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  // https://github.com/tc39/proposal-bind-operator#syntax\n  parseBind(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next(); // eat '::'\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(\n      this.finishNode(node, \"BindExpression\"),\n      startLoc,\n      noCalls,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverCallExpressionAndAsyncArrowHead\n  // CoverCallExpressionAndAsyncArrowHead\n  // CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n  // OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]\n  parseCoverCallAndAsyncArrowHead(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    optional: boolean,\n  ): N.Expression {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors: ExpressionErrors | null = null;\n\n    this.state.maybeInArrowParameters = true;\n    this.next(); // eat `(`\n\n    const node = this.startNodeAt<N.CallExpression | N.OptionalCallExpression>(\n      startLoc,\n    );\n    node.callee = base;\n    const { maybeAsyncArrow, optionalChainMember } = state;\n\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (optionalChainMember) {\n      // @ts-expect-error when optionalChainMember is true, node must be an optional call\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(tt.parenR);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(\n        tt.parenR,\n        base.type === \"Import\",\n        base.type !== \"Super\",\n        // @ts-expect-error todo(flow->ts)\n        node,\n        refExpressionErrors,\n      );\n    }\n    let finishedNode:\n      | N.CallExpression\n      | N.OptionalCallExpression\n      | N.ArrowFunctionExpression = this.finishCallExpression(\n      node,\n      optionalChainMember,\n    );\n\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      /*:: invariant(refExpressionErrors != null) */\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(\n        this.startNodeAt<N.ArrowFunctionExpression>(startLoc),\n        finishedNode as N.CallExpression,\n      );\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return finishedNode;\n  }\n\n  toReferencedArguments(\n    node: N.CallExpression | N.OptionalCallExpression,\n    isParenthesizedExpr?: boolean,\n  ) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  // MemberExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  // CallExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  parseTaggedTemplateExpression(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n  ): N.TaggedTemplateExpression {\n    const node = this.startNodeAt<N.TaggedTemplateExpression>(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, { at: startLoc });\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base: N.Expression): boolean {\n    return (\n      base.type === \"Identifier\" &&\n      base.name === \"async\" &&\n      this.state.lastTokEndLoc.index === base.end &&\n      !this.canInsertSemicolon() &&\n      // check there are no escape sequences, such as \\u{61}sync\n      base.end - base.start === 5 &&\n      base.start === this.state.potentialArrowAt\n    );\n  }\n\n  expectImportAttributesPlugin() {\n    if (!this.hasPlugin(\"importAssertions\")) {\n      this.expectPlugin(\"importAttributes\");\n    }\n  }\n\n  finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n    node: Undone<T>,\n    optional: boolean,\n  ): T {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        if (process.env.BABEL_8_BREAKING) {\n          this.expectImportAttributesPlugin();\n        } else {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectImportAttributesPlugin();\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, {\n          at: node,\n          maxArgumentCount:\n            this.hasPlugin(\"importAttributes\") ||\n            this.hasPlugin(\"importAssertions\") ||\n            this.hasPlugin(\"moduleAttributes\")\n              ? 2\n              : 1,\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, { at: arg });\n          }\n        }\n      }\n    }\n    return this.finishNode(\n      node,\n      optional ? \"OptionalCallExpression\" : \"CallExpression\",\n    );\n  }\n\n  parseCallExpressionArguments(\n    this: Parser,\n    close: TokenType,\n    dynamicImport?: boolean,\n    allowPlaceholder?: boolean,\n    nodeForExtra?: N.Node | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): Array<N.Expression | undefined | null> {\n    const elts: N.Expression[] = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (\n            dynamicImport &&\n            !this.hasPlugin(\"importAttributes\") &&\n            !this.hasPlugin(\"importAssertions\") &&\n            !this.hasPlugin(\"moduleAttributes\")\n          ) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(\n        this.parseExprListItem(false, refExpressionErrors, allowPlaceholder),\n      );\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return elts;\n  }\n\n  shouldParseAsyncArrow(): boolean {\n    return this.match(tt.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    call: N.CallExpression,\n  ): N.ArrowFunctionExpression {\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(tt.arrow);\n    this.parseArrowExpression(\n      node,\n      call.arguments,\n      true,\n      call.extra?.trailingCommaLoc,\n    );\n    // mark inner comments of `async()` as inner comments of `async () =>`\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    // mark trailing comments of `async` to be inner comments\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node as N.ArrowFunctionExpression;\n  }\n\n  // Parse a no-call expression (like argument of `new` or `::` operators).\n  // https://tc39.es/ecma262/#prod-MemberExpression\n  parseNoCallExpr(this: Parser): N.Expression {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n\n  // Parse an atomic expression \u2014 either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  // https://tc39.es/ecma262/#prod-PrimaryExpression\n  // https://tc39.es/ecma262/#prod-AsyncArrowFunction\n  // PrimaryExpression\n  // Super\n  // Import\n  // AsyncArrowFunction\n\n  parseExprAtom(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    let node;\n    let decorators: N.Decorator[] | null = null;\n\n    const { type } = this.state;\n    switch (type) {\n      case tt._super:\n        return this.parseSuper();\n\n      case tt._import:\n        node = this.startNode<N.MetaProperty | N.Import | N.ImportExpression>();\n        this.next();\n\n        if (this.match(tt.dot)) {\n          return this.parseImportMetaProperty(node as Undone<N.MetaProperty>);\n        }\n\n        if (this.match(tt.parenL)) {\n          if (this.options.createImportExpressions) {\n            return this.parseImportCall(node as Undone<N.ImportExpression>);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, {\n            at: this.state.lastTokStartLoc,\n          });\n          return this.finishNode(node, \"Import\");\n        }\n\n      case tt._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case tt._do: {\n        return this.parseDo(this.startNode(), false);\n      }\n\n      case tt.slash:\n      case tt.slashAssign: {\n        this.readRegexp();\n        return this.parseRegExpLiteral(this.state.value);\n      }\n\n      case tt.num:\n        return this.parseNumericLiteral(this.state.value);\n\n      case tt.bigint:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case tt.decimal:\n        return this.parseDecimalLiteral(this.state.value);\n\n      case tt.string:\n        return this.parseStringLiteral(this.state.value);\n\n      case tt._null:\n        return this.parseNullLiteral();\n\n      case tt._true:\n        return this.parseBooleanLiteral(true);\n      case tt._false:\n        return this.parseBooleanLiteral(false);\n\n      case tt.parenL: {\n        const canBeArrow = this.state.potentialArrowAt === this.state.start;\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n      }\n\n      case tt.bracketBarL:\n      case tt.bracketHashL: {\n        return this.parseArrayLike(\n          this.state.type === tt.bracketBarL ? tt.bracketBarR : tt.bracketR,\n          /* canBePattern */ false,\n          /* isTuple */ true,\n        );\n      }\n      case tt.bracketL: {\n        return this.parseArrayLike(\n          tt.bracketR,\n          /* canBePattern */ true,\n          /* isTuple */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt.braceBarL:\n      case tt.braceHashL: {\n        return this.parseObjectLike(\n          this.state.type === tt.braceBarL ? tt.braceBarR : tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ true,\n        );\n      }\n      case tt.braceL: {\n        return this.parseObjectLike(\n          tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case tt.at:\n        decorators = this.parseDecorators();\n      // fall through\n      case tt._class:\n        return this.parseClass(\n          this.maybeTakeDecorators(decorators, this.startNode()),\n          false,\n        );\n\n      case tt._new:\n        return this.parseNewOrNewTarget();\n\n      case tt.templateNonTail:\n      case tt.templateTail:\n        return this.parseTemplate(false);\n\n      // BindExpression[Yield]\n      //   :: MemberExpression[?Yield]\n      case tt.doubleColon: {\n        node = this.startNode();\n        this.next();\n        node.object = null;\n        const callee = (node.callee = this.parseNoCallExpr());\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(Errors.UnsupportedBind, { at: callee });\n        }\n      }\n\n      case tt.privateName: {\n        // Standalone private names are only allowed in \"#x in obj\"\n        // expressions, and they are directly handled by callers of\n        // parseExprOp. If we reach this, the input is always invalid.\n        // We can throw a better error message and recover, rather than\n        // just throwing \"Unexpected token\" (which is the default\n        // behavior of this big switch statement).\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: this.state.startLoc,\n          identifierName: this.state.value,\n        });\n        return this.parsePrivateName();\n      }\n\n      case tt.moduloAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.modulo, \"%\");\n      }\n\n      case tt.xorAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.bitwiseXOR, \"^\");\n      }\n\n      case tt.doubleCaret:\n      case tt.doubleAt: {\n        return this.parseTopicReference(\"hack\");\n      }\n\n      case tt.bitwiseXOR:\n      case tt.modulo:\n      case tt.hash: {\n        const pipeProposal = this.getPluginOption(\n          \"pipelineOperator\",\n          \"proposal\",\n        );\n\n        if (pipeProposal) {\n          return this.parseTopicReference(pipeProposal);\n        }\n        this.unexpected();\n        break;\n      }\n\n      case tt.lt: {\n        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n        if (\n          isIdentifierStart(lookaheadCh) || // Element/Type Parameter <foo>\n          lookaheadCh === charCodes.greaterThan // Fragment <>\n        ) {\n          this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n        } else {\n          this.unexpected();\n        }\n        break;\n      }\n\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (\n            this.isContextual(tt._module) &&\n            this.lookaheadInLineCharCode() === charCodes.leftCurlyBrace\n          ) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (\n            !containsEsc &&\n            id.name === \"async\" &&\n            !this.canInsertSemicolon()\n          ) {\n            const { type } = this.state;\n            if (type === tt._function) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(\n                this.startNodeAtNode(id),\n              );\n            } else if (tokenIsIdentifier(type)) {\n              // If the next token begins with \"=\", commit to parsing an async\n              // arrow function. (Peeking ahead for \"=\" lets us avoid a more\n              // expensive full-token lookahead on this common path.)\n              if (this.lookaheadCharCode() === charCodes.equalsTo) {\n                // although `id` is not used in async arrow unary function,\n                // we don't need to reset `async`'s trailing comments because\n                // it will be attached to the upcoming async arrow binding identifier\n                return this.parseAsyncArrowUnaryFunction(\n                  this.startNodeAtNode(id),\n                );\n              } else {\n                // Otherwise, treat \"async\" as an identifier and let calling code\n                // deal with the current tt.name token.\n                return id;\n              }\n            } else if (type === tt._do) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (\n            canBeArrow &&\n            this.match(tt.arrow) &&\n            !this.canInsertSemicolon()\n          ) {\n            this.next();\n            return this.parseArrowExpression(\n              this.startNodeAtNode(id),\n              [id],\n              false,\n            );\n          }\n\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n\n  // This helper method should only be called\n  // when the parser has reached a potential Hack pipe topic token\n  // that is followed by an equals sign.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  // If we find ^= or %= in an expression position\n  // (i.e., the tt.moduloAssign or tt.xorAssign token types), and if the\n  // Hack-pipes proposal is active with ^ or % as its topicToken, then the ^ or\n  // % could be the topic token (e.g., in x |> ^==y or x |> ^===y), and so we\n  // reparse the current token as ^ or %.\n  // Otherwise, this throws an unexpected-token error.\n  parseTopicReferenceThenEqualsSign(\n    topicTokenType: TokenType,\n    topicTokenValue: string,\n  ): N.Expression {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (pipeProposal) {\n      // Set the most-recent token to be a topic token\n      // given by the tokenType and tokenValue.\n      // Now the next readToken() call (in parseTopicReference)\n      // will consume that \u201Ctopic token\u201D.\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      // Rewind the tokenizer to the end of the \u201Ctopic token\u201D, so that the\n      // following token starts at the equals sign after that topic token.\n      this.state.pos--;\n      this.state.end--;\n      // This is safe to do since the preceding character was either ^ or %, and\n      // thus not a newline.\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      // Now actually consume the topic token.\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // This helper method should only be called\n  // when the proposal-pipeline-operator plugin is active,\n  // and when the parser has reached a potential Hack pipe topic token.\n  // Although a pipe-operator proposal is assumed to be active,\n  // its configuration might not match the current token\u2019s type.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  parseTopicReference(pipeProposal: string): N.Expression {\n    const node = this.startNode<N.TopicReference>();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n\n    // Consume the current token.\n    this.next();\n\n    // If the pipe-operator plugin\u2019s configuration matches the current token\u2019s type,\n    // then this will return `node`, will have been finished as a topic reference.\n    // Otherwise, this will throw a `PipeTopicUnconfiguredToken` error.\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n\n  // This helper method attempts to finish the given `node`\n  // into a topic-reference node for the given `pipeProposal`.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  //\n  // The method assumes that any topic token was consumed before it was called.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // and if the given `tokenType` matches the plugin\u2019s configuration,\n  // then this method will return the finished `node`.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // but if the given `tokenType` does not match the plugin\u2019s configuration,\n  // then this method will throw a `PipeTopicUnconfiguredToken` error.\n  finishTopicReference(\n    node: Undone<N.Node>,\n    startLoc: Position,\n    pipeProposal: string,\n    tokenType: TokenType,\n  ): N.Expression {\n    if (\n      this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)\n    ) {\n      // The token matches the plugin\u2019s configuration.\n      // The token is therefore a topic reference.\n\n      // Determine the node type for the topic reference\n      // that is appropriate for the active pipe-operator proposal.\n      const nodeType =\n        pipeProposal === \"smart\"\n          ? \"PipelinePrimaryTopicReference\"\n          : // The proposal must otherwise be \"hack\",\n            // as enforced by testTopicReferenceConfiguration.\n            \"TopicReference\";\n\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(\n          // The topic reference is not allowed in the current context:\n          // it is outside of a pipe body.\n          // Raise recoverable errors.\n          pipeProposal === \"smart\"\n            ? Errors.PrimaryTopicNotAllowed\n            : // In this case, `pipeProposal === \"hack\"` is true.\n              Errors.PipeTopicUnbound,\n          { at: startLoc },\n        );\n      }\n\n      // Register the topic reference so that its pipe body knows\n      // that its topic was used at least once.\n      this.registerTopicReference();\n\n      return this.finishNode(node, nodeType);\n    } else {\n      // The token does not match the plugin\u2019s configuration.\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, {\n        at: startLoc,\n        token: tokenLabelName(tokenType),\n      });\n    }\n  }\n\n  // This helper method tests whether the given token type\n  // matches the pipelineOperator parser plugin\u2019s configuration.\n  // If the active pipe proposal is Hack style,\n  // and if the given token is the same as the plugin configuration\u2019s `topicToken`,\n  // then this is a valid topic reference.\n  // If the active pipe proposal is smart mix,\n  // then the topic token must always be `#`.\n  // If the active pipe proposal is neither (e.g., \"minimal\" or \"fsharp\"),\n  // then an error is thrown.\n  testTopicReferenceConfiguration(\n    pipeProposal: string,\n    startLoc: Position,\n    tokenType: TokenType,\n  ): boolean {\n    switch (pipeProposal) {\n      case \"hack\": {\n        return this.hasPlugin([\n          \"pipelineOperator\",\n          {\n            // @ts-expect-error token must have a label\n            topicToken: tokenLabelName(tokenType),\n          },\n        ]);\n      }\n      case \"smart\":\n        return tokenType === tt.hash;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, { at: startLoc });\n    }\n  }\n\n  // async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]\n  parseAsyncArrowUnaryFunction(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n  ): N.ArrowFunctionExpression {\n    // We don't need to push a new ParameterDeclarationScope here since we are sure\n    // 1) it is an async arrow, 2) no biding pattern is allowed in params\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, {\n        at: this.state.curPosition(),\n      });\n    }\n    this.expect(tt.arrow);\n    // let foo = async bar => {};\n    return this.parseArrowExpression(node, params, true);\n  }\n\n  // https://github.com/tc39/proposal-do-expressions\n  // https://github.com/tc39/proposal-async-do-expressions\n  parseDo(\n    this: Parser,\n    node: Undone<N.DoExpression>,\n    isAsync: boolean,\n  ): N.DoExpression {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next(); // eat `do`\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      // AsyncDoExpression :\n      // async [no LineTerminator here] do Block[~Yield, +Await, ~Return]\n      this.prodParam.enter(ParamKind.PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  // Parse the `super` keyword\n  parseSuper(): N.Super {\n    const node = this.startNode<N.Super>();\n    this.next(); // eat `super`\n    if (\n      this.match(tt.parenL) &&\n      !this.scope.allowDirectSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(Errors.SuperNotAllowed, { at: node });\n    } else if (\n      !this.scope.allowSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(Errors.UnexpectedSuper, { at: node });\n    }\n\n    if (\n      !this.match(tt.parenL) &&\n      !this.match(tt.bracketL) &&\n      !this.match(tt.dot)\n    ) {\n      this.raise(Errors.UnsupportedSuper, { at: node });\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parsePrivateName(): N.PrivateName {\n    const node = this.startNode<N.PrivateName>();\n    const id = this.startNodeAt<N.Identifier>(\n      // The position is hardcoded because we merge `#` and name into a single\n      // tt.privateName token\n      createPositionWithColumnOffset(this.state.startLoc, 1),\n    );\n    const name = this.state.value;\n    this.next(); // eat #name;\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent(\n    this: Parser,\n  ): N.FunctionExpression | N.MetaProperty {\n    const node = this.startNode<N.FunctionExpression | N.MetaProperty>();\n\n    // We do not do parseIdentifier here because when parseFunctionOrFunctionSent\n    // is called we already know that the current token is a \"name\" with the value \"function\"\n    // This will improve perf a tiny little bit as we do not do validation but more importantly\n    // here is that parseIdentifier will remove an item from the expression stack\n    // if \"function\" or \"class\" is parsed as identifier (in objects e.g.), which should not happen here.\n    this.next(); // eat `function`\n\n    if (this.prodParam.hasYield && this.match(tt.dot)) {\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"function\",\n      );\n      this.next(); // eat `.`\n      // https://github.com/tc39/proposal-function.sent#syntax-1\n      if (this.match(tt._sent)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.\n        this.unexpected();\n      }\n      return this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"sent\",\n      );\n    }\n    return this.parseFunction(node as Undone<N.FunctionExpression>);\n  }\n\n  parseMetaProperty(\n    node: Undone<N.MetaProperty>,\n    meta: N.Identifier,\n    propertyName: string,\n  ): N.MetaProperty {\n    node.meta = meta;\n\n    const containsEsc = this.state.containsEsc;\n\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, {\n        at: node.property,\n        target: meta.name,\n        onlyValidPropertyName: propertyName,\n      });\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportMeta\n  parseImportMetaProperty(\n    this: Parser,\n    node: Undone<N.MetaProperty | N.ImportExpression>,\n  ): N.MetaProperty | N.ImportExpression {\n    const id = this.createIdentifier(\n      this.startNodeAtNode<N.Identifier>(node),\n      \"import\",\n    );\n    this.next(); // eat `.`\n\n    if (this.isContextual(tt._meta)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, { at: id });\n      }\n      this.sawUnambiguousESM = true;\n    } else if (this.isContextual(tt._source) || this.isContextual(tt._defer)) {\n      const isSource = this.isContextual(tt._source);\n\n      // TODO: The proposal doesn't mention import.defer yet because it was\n      // pending on a decision for import.source. Wait to enable it until it's\n      // included in the proposal.\n      if (!isSource) this.unexpected();\n\n      this.expectPlugin(\n        isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\",\n      );\n      if (!this.options.createImportExpressions) {\n        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, {\n          at: this.state.startLoc,\n          phase: this.state.value,\n        });\n      }\n      this.next();\n      (node as Undone<N.ImportExpression>).phase = isSource\n        ? \"source\"\n        : \"defer\";\n      return this.parseImportCall(node as Undone<N.ImportExpression>);\n    }\n\n    return this.parseMetaProperty(node as Undone<N.MetaProperty>, id, \"meta\");\n  }\n\n  parseLiteralAtNode<T extends N.Node>(\n    value: any,\n    type: T[\"type\"],\n    node: any,\n  ): T {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode<T>(node, type);\n  }\n\n  parseLiteral<T extends N.Node>(value: any, type: T[\"type\"]): T {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value: any) {\n    return this.parseLiteral<N.StringLiteral>(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value: any) {\n    return this.parseLiteral<N.NumericLiteral>(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value: any) {\n    return this.parseLiteral<N.BigIntLiteral>(value, \"BigIntLiteral\");\n  }\n\n  parseDecimalLiteral(value: any) {\n    return this.parseLiteral<N.DecimalLiteral>(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value: {\n    value: any;\n    pattern: string;\n    flags: N.RegExpLiteral[\"flags\"];\n  }) {\n    const node = this.parseLiteral<N.RegExpLiteral>(\n      value.value,\n      \"RegExpLiteral\",\n    );\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n\n  parseBooleanLiteral(value: boolean) {\n    const node = this.startNode<N.BooleanLiteral>();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode<N.NullLiteral>();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n  parseParenAndDistinguishExpression(\n    this: Parser,\n    canBeArrow: boolean,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    let val;\n    this.next(); // eat `(`\n    this.expressionScope.enter(newArrowHeadScope());\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    const innerStartLoc = this.state.startLoc;\n    const exprList: N.Expression[] = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n\n    while (!this.match(tt.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(\n          tt.comma,\n          refExpressionErrors.optionalParametersLoc === null\n            ? null\n            : refExpressionErrors.optionalParametersLoc,\n        );\n        if (this.match(tt.parenR)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n\n      if (this.match(tt.ellipsis)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(\n          this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc),\n        );\n\n        if (!this.checkCommaAfterRest(charCodes.rightParenthesis)) {\n          break;\n        }\n      } else {\n        exprList.push(\n          this.parseMaybeAssignAllowIn(\n            refExpressionErrors,\n            this.parseParenItem,\n          ),\n        );\n      }\n    }\n\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(tt.parenR);\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    let arrowNode = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n    if (\n      canBeArrow &&\n      this.shouldParseArrow(exprList) &&\n      (arrowNode = this.parseArrow(arrowNode))\n    ) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      // @ts-expect-error todo(flow->ts) improve node types\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n\n    this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt<N.SequenceExpression>(innerStartLoc);\n      val.expressions = exprList;\n      // finish node at current location so it can pick up comments after `)`\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    return this.wrapParenthesis(\n      startLoc,\n      // @ts-expect-error todo(flow->ts)\n      val,\n    );\n  }\n\n  wrapParenthesis(startLoc: Position, expression: N.Expression): N.Expression {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n\n      this.takeSurroundingComments(\n        expression,\n        startLoc.index,\n        this.state.lastTokEndLoc.index,\n      );\n\n      return expression;\n    }\n\n    const parenExpression =\n      this.startNodeAt<N.ParenthesizedExpression>(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- `params` is used in typescript plugin\n  shouldParseArrow(params: Array<N.Node>): boolean {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(\n    node: Undone<N.ArrowFunctionExpression>,\n  ): Undone<N.ArrowFunctionExpression> | undefined {\n    if (this.eat(tt.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(\n    node: N.Expression,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLoc: Position,\n  ): N.Expression {\n    return node;\n  }\n\n  parseNewOrNewTarget(this: Parser): N.NewExpression | N.MetaProperty {\n    const node = this.startNode<N.NewExpression | N.MetaProperty>();\n    this.next();\n    if (this.match(tt.dot)) {\n      // https://tc39.es/ecma262/#prod-NewTarget\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"new\",\n      );\n      this.next();\n      const metaProp = this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"target\",\n      );\n\n      if (\n        !this.scope.inNonArrowFunction &&\n        !this.scope.inClass &&\n        !this.options.allowNewTargetOutsideFunction\n      ) {\n        this.raise(Errors.UnexpectedNewTarget, { at: metaProp });\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node as Undone<N.NewExpression>);\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call \u2014 at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n  // https://tc39.es/ecma262/#prod-NewExpression\n  parseNew(this: Parser, node: Undone<N.NewExpression>): N.NewExpression {\n    this.parseNewCallee(node);\n\n    if (this.eat(tt.parenL)) {\n      const args = this.parseExprList(tt.parenR);\n      this.toReferencedList(args);\n      // (parseExprList should be all non-null in this case)\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewCallee(this: Parser, node: Undone<N.NewExpression>): void {\n    const isImport = this.match(tt._import);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (\n      isImport &&\n      (callee.type === \"Import\" || callee.type === \"ImportExpression\")\n    ) {\n      this.raise(Errors.ImportCallNotNewExpression, { at: callee });\n    }\n  }\n\n  // Parse template expression.\n\n  parseTemplateElement(isTagged: boolean): N.TemplateElement {\n    const { start, startLoc, end, value } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt<N.TemplateElement>(\n      createPositionWithColumnOffset(startLoc, 1),\n    );\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, {\n          // FIXME: Adding 1 is probably wrong.\n          at: createPositionWithColumnOffset(\n            this.state.firstInvalidTemplateEscapePos,\n            1,\n          ),\n        });\n      }\n    }\n\n    const isTail = this.match(tt.templateTail);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset),\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(\n      finishedNode,\n      createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset),\n    );\n    return finishedNode;\n  }\n\n  // https://tc39.es/ecma262/#prod-TemplateLiteral\n  parseTemplate(this: Parser, isTagged: boolean): N.TemplateLiteral {\n    const node = this.startNode<N.TemplateLiteral>();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push((curElt = this.parseTemplateElement(isTagged)));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  // This is overwritten by the TypeScript plugin to parse template types\n  parseTemplateSubstitution(this: Parser): N.Expression {\n    return this.parseExpression();\n  }\n\n  // Parse an object literal, binding pattern, or record.\n\n  parseObjectLike(\n    close: TokenType,\n    isPattern: true,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectPattern;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: false | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectExpression;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: true,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.RecordExpression;\n  parseObjectLike<T extends N.ObjectPattern | N.ObjectExpression>(\n    this: Parser,\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): T {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash: any = Object.create(null);\n    let first = true;\n    const node = this.startNode<\n      N.ObjectExpression | N.ObjectPattern | N.RecordExpression\n    >();\n\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(\n            // @ts-expect-error todo(flow->ts) improve node types\n            node,\n          );\n          break;\n        }\n      }\n\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (\n        isRecord &&\n        !this.isObjectProperty(prop) &&\n        prop.type !== \"SpreadElement\"\n      ) {\n        this.raise(Errors.InvalidRecordProperty, { at: prop });\n      }\n\n      // @ts-expect-error shorthand may not index prop\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      // @ts-expect-error Fixme: refine typings\n      node.properties.push(prop);\n    }\n\n    this.next();\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    // @ts-expect-error type is well defined\n    return this.finishNode(node, type);\n  }\n\n  addTrailingCommaExtraToNode(node: N.Node): void {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n\n  // Check grammar production:\n  //   IdentifierName *_opt PropertyName\n  // It is used in `parsePropertyDefinition` to detect AsyncMethod and Accessors\n  maybeAsyncOrAccessorProp(prop: Undone<N.ObjectProperty>): boolean {\n    return (\n      !prop.computed &&\n      prop.key.type === \"Identifier\" &&\n      (this.isLiteralPropertyName() ||\n        this.match(tt.bracketL) ||\n        this.match(tt.star))\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyDefinition\n  parsePropertyDefinition(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMember | N.SpreadElement {\n    let decorators = [];\n    if (this.match(tt.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, {\n          at: this.state.startLoc,\n        });\n      }\n\n      // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\n      // the call to this.parseDecorator\n      while (this.match(tt.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode<N.ObjectProperty>();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n\n    if (this.match(tt.ellipsis)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n\n    let isGenerator = this.eat(tt.star);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      // https://tc39.es/ecma262/#prod-AsyncMethod\n      // https://tc39.es/ecma262/#prod-AsyncGeneratorMethod\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(tt.star);\n        this.parsePropertyName(prop);\n      }\n      // get PropertyName[?Yield, ?Await] () { FunctionBody[~Yield, ~Await] }\n      // set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(tt.star)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, {\n            at: this.state.curPosition(),\n            kind: keyName,\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n\n    return this.parseObjPropValue(\n      prop,\n      startLoc,\n      isGenerator,\n      isAsync,\n      false /* isPattern */,\n      isAccessor,\n      refExpressionErrors,\n    );\n  }\n\n  getGetterSetterExpectedParamCount(\n    method: N.ObjectMethod | N.ClassMethod,\n  ): number {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  // This exists so we can override within the ESTree plugin\n  getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n    return method.params;\n  }\n\n  // get methods aren't allowed to have any parameters\n  // set methods must have exactly 1 parameter which is not a rest parameter\n  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length !== paramCount) {\n      this.raise(\n        method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity,\n        { at: method },\n      );\n    }\n\n    if (\n      method.kind === \"set\" &&\n      params[params.length - 1]?.type === \"RestElement\"\n    ) {\n      this.raise(Errors.BadSetterRestParameter, { at: method });\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-MethodDefinition\n  parseObjectMethod(\n    this: Parser,\n    prop: Undone<N.ObjectMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n  ): N.ObjectMethod | undefined | null {\n    if (isAccessor) {\n      // isAccessor implies isAsync: false, isPattern: false, isGenerator: false\n      const finishedProp = this.parseMethod(\n        prop,\n        // This _should_ be false, but with error recovery, we allow it to be\n        // set for informational purposes\n        isGenerator,\n        /* isAsync */ false,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n\n    if (isAsync || isGenerator || this.match(tt.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n    }\n  }\n\n  // if `isPattern` is true, parse https://tc39.es/ecma262/#prod-BindingProperty\n  // else https://tc39.es/ecma262/#prod-PropertyDefinition\n  parseObjectProperty(\n    this: Parser,\n    prop: Undone<N.ObjectProperty>,\n    startLoc: Position | undefined | null,\n    isPattern: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectProperty | undefined | null {\n    prop.shorthand = false;\n\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern\n        ? this.parseMaybeDefault(this.state.startLoc)\n        : this.parseMaybeAssignAllowIn(refExpressionErrors);\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      // PropertyDefinition:\n      //   IdentifierReference\n      //   CoverInitializedName\n      // Note: `{ eval } = {}` will be checked in `checkLVal` later.\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else if (this.match(tt.eq)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, {\n            at: shorthandAssignLoc,\n          });\n        }\n        prop.value = this.parseMaybeDefault(\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(\n    this: Parser,\n    prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n    startLoc: Position | undefined | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMethod | N.ObjectProperty {\n    const node =\n      this.parseObjectMethod(\n        prop as Undone<N.ObjectMethod>,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) ||\n      this.parseObjectProperty(\n        prop as Undone<N.ObjectProperty>,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      );\n\n    if (!node) this.unexpected();\n\n    return node;\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyName\n  // when refExpressionErrors presents, it will parse private name\n  // and record the position of the first private name\n  parsePropertyName(\n    this: Parser,\n    prop:\n      | Undone<N.ObjectOrClassMember | N.ClassMember>\n      | N.TsNamedTypeElementBase,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression | N.Identifier {\n    if (this.eat(tt.bracketL)) {\n      (prop as Undone<N.ObjectOrClassMember>).computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(tt.bracketR);\n    } else {\n      // We check if it's valid for it to be a private name when we push it.\n      const { type, value } = this.state;\n      let key;\n      // most un-computed property names are identifiers\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case tt.num:\n            key = this.parseNumericLiteral(value);\n            break;\n          case tt.string:\n            key = this.parseStringLiteral(value);\n            break;\n          case tt.bigint:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case tt.decimal:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case tt.privateName: {\n            // the class private key has been handled in parseClassElementName\n            const privateKeyLoc = this.state.startLoc;\n            if (refExpressionErrors != null) {\n              if (refExpressionErrors.privateKeyLoc === null) {\n                refExpressionErrors.privateKeyLoc = privateKeyLoc;\n              }\n            } else {\n              this.raise(Errors.UnexpectedPrivateField, {\n                at: privateKeyLoc,\n              });\n            }\n            key = this.parsePrivateName();\n            break;\n          }\n          default:\n            this.unexpected();\n        }\n      }\n      (prop as any).key = key;\n      if (type !== tt.privateName) {\n        // ClassPrivateProperty is never computed, so we don't assign in that case.\n        prop.computed = false;\n      }\n    }\n\n    return prop.key;\n  }\n\n  // Initialize empty function node.\n\n  initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n\n  // Parse object or class method.\n\n  parseMethod<T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod>(\n    this: Parser,\n    node: Undone<T>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowDirectSuper: boolean,\n    type: T[\"type\"],\n    inClassScope: boolean = false,\n  ): T {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(\n      ScopeFlag.FUNCTION |\n        ScopeFlag.SUPER |\n        (inClassScope ? ScopeFlag.CLASS : 0) |\n        (allowDirectSuper ? ScopeFlag.DIRECT_SUPER : 0),\n    );\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n\n    return finishedNode;\n  }\n\n  // parse an array literal or tuple literal\n  // https://tc39.es/ecma262/#prod-ArrayLiteral\n  // https://tc39.es/proposal-record-tuple/#prod-TupleLiteral\n  parseArrayLike(\n    this: Parser,\n    close: TokenType,\n    canBePattern: boolean,\n    isTuple: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ArrayExpression | N.TupleExpression {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode<N.ArrayExpression | N.TupleExpression>();\n    this.next();\n    node.elements = this.parseExprList(\n      close,\n      /* allowEmpty */ !isTuple,\n      refExpressionErrors,\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(\n      node,\n      isTuple ? \"TupleExpression\" : \"ArrayExpression\",\n    );\n  }\n\n  // Parse arrow function expression.\n  // If the parameters are provided, they will be converted to an\n  // assignable list.\n  parseArrowExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    params: N.Expression[] | undefined | null,\n    isAsync: boolean,\n    trailingCommaLoc?: Position | null,\n  ): N.ArrowFunctionExpression {\n    this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.ARROW);\n    let flags = functionFlags(isAsync, false);\n    // ConciseBody[In] :\n    //   [lookahead \u2260 {] ExpressionBody[?In, ~Await]\n    //   { FunctionBody[~Yield, ~Await] }\n    if (!this.match(tt.braceL) && this.prodParam.hasIn) {\n      flags |= ParamKind.PARAM_IN;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(\n    node: Undone<N.ArrowFunctionExpression>,\n    params: N.Expression[],\n    trailingCommaLoc?: Position | null,\n  ): void {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params as (N.Pattern | N.TSParameterProperty)[];\n  }\n\n  parseFunctionBodyAndFinish<\n    T extends\n      | N.Function\n      | N.TSDeclareMethod\n      | N.TSDeclareFunction\n      | N.ClassPrivateMethod,\n  >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n    // @ts-expect-error (node is not bodiless if we get here)\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n\n  // Parse function body and check parameters.\n  parseFunctionBody(\n    this: Parser,\n    node: Undone<N.Function>,\n    allowExpression?: boolean | null,\n    isMethod: boolean = false,\n  ): void {\n    const isExpression = allowExpression && !this.match(tt.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      // https://tc39.es/ecma262/#prod-ExpressionBody\n      (node as Undone<N.ArrowFunctionExpression>).body =\n        this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      // Start a new scope with regard to labels\n      // flag (restore them to their old value afterwards).\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n\n      // FunctionBody[Yield, Await]:\n      //   StatementList[?Yield, ?Await, +Return] opt\n      this.prodParam.enter(\n        this.prodParam.currentFlags() | ParamKind.PARAM_RETURN,\n      );\n      node.body = this.parseBlock(\n        true,\n        false,\n        // Strict mode function checks after we parse the statements in the function body.\n        (hasStrictModeDirective: boolean) => {\n          const nonSimple = !this.isSimpleParamList(node.params);\n\n          if (hasStrictModeDirective && nonSimple) {\n            // This logic is here to align the error location with the ESTree plugin.\n            this.raise(Errors.IllegalLanguageModeDirective, {\n              at:\n                // @ts-expect-error kind may not index node\n                (node.kind === \"method\" || node.kind === \"constructor\") &&\n                // @ts-expect-error key may not index node\n                !!node.key\n                  ? // @ts-expect-error node.key has been guarded\n                    node.key.loc.end\n                  : node,\n            });\n          }\n\n          const strictModeChanged = !oldStrict && this.state.strict;\n\n          // Add the params to varDeclaredNames to ensure that an error is thrown\n          // if a let/const declaration in the function clashes with one of the params.\n          this.checkParams(\n            node,\n            !this.state.strict && !allowExpression && !isMethod && !nonSimple,\n            allowExpression,\n            strictModeChanged,\n          );\n\n          // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n          if (this.state.strict && node.id) {\n            this.checkIdentifier(\n              node.id,\n              BindingFlag.TYPE_OUTSIDE,\n              strictModeChanged,\n            );\n          }\n        },\n      );\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n\n  isSimpleParameter(node: N.Pattern | N.TSParameterProperty) {\n    return node.type === \"Identifier\";\n  }\n\n  isSimpleParamList(\n    params: ReadonlyArray<N.Pattern | N.TSParameterProperty>,\n  ): boolean {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n\n  checkParams(\n    node: Undone<N.Function>,\n    allowDuplicates: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isArrowFunction?: boolean | null,\n    strictModeChanged: boolean = true,\n  ): void {\n    const checkClashes = !allowDuplicates && new Set<string>();\n    // We create a fake node with the \"ephemeral\" type `FormalParameters`[1]\n    // since we just store an array of parameters. Perhaps someday we can have\n    // something like class FormalParameters extends Array { ... }, which would\n    // also be helpful when traversing this node.\n    //\n    // 1. https://tc39.es/ecma262/#prod-FormalParameters\n    const formalParameters = { type: \"FormalParameters\" } as const;\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: BindingFlag.TYPE_VAR,\n        checkClashes,\n        strictModeChanged,\n      });\n    }\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  parseExprList(\n    this: Parser,\n    close: TokenType,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n    nodeForExtra?: N.Node | null,\n  ): (N.Expression | null)[] {\n    const elts: (N.Expression | null)[] = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression | null;\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: false,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression;\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression | null {\n    let elt;\n    if (this.match(tt.comma)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, {\n          at: this.state.curPosition(),\n          unexpected: \",\",\n        });\n      }\n      elt = null;\n    } else if (this.match(tt.ellipsis)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n\n      elt = this.parseParenItem(\n        this.parseSpread(refExpressionErrors),\n        spreadNodeStartLoc,\n      );\n    } else if (this.match(tt.question)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, {\n          at: this.state.startLoc,\n        });\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(\n        refExpressionErrors,\n        this.parseParenItem,\n      );\n    }\n    return elt;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n  // This shouldn't be used to parse the keywords of meta properties, since they\n  // are not identifiers and cannot contain escape sequences.\n\n  parseIdentifier(liberal?: boolean): N.Identifier {\n    const node = this.startNode<N.Identifier>();\n    const name = this.parseIdentifierName(liberal);\n\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(\n    node: Omit<N.Identifier, \"type\">,\n    name: string,\n  ): N.Identifier {\n    node.name = name;\n    node.loc.identifierName = name;\n\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(liberal?: boolean): string {\n    let name: string;\n\n    const { startLoc, type } = this.state;\n\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n\n    if (liberal) {\n      // If the current token is not used as a keyword, set its type to \"tt.name\".\n      // This will prevent this.next() from throwing about unexpected escapes.\n      if (tokenIsKeyword) {\n        this.replaceToken(tt.name);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n\n    this.next();\n\n    return name;\n  }\n\n  checkReservedWord(\n    word: string,\n    startLoc: Position,\n    checkKeywords: boolean,\n    isBinding: boolean,\n  ): void {\n    // Every JavaScript reserved word is 10 characters or less.\n    if (word.length > 10) {\n      return;\n    }\n    // Most identifiers are not reservedWord-like, they don't need special\n    // treatments afterward, which very likely ends up throwing errors\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, {\n        at: startLoc,\n        keyword: word,\n      });\n      return;\n    }\n\n    const reservedTest = !this.state.strict\n      ? isReservedWord\n      : isBinding\n        ? isStrictBindReservedWord\n        : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, {\n        at: startLoc,\n        reservedWord: word,\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, { at: startLoc });\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, { at: startLoc });\n        return;\n      }\n\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {\n          at: startLoc,\n        });\n        return;\n      }\n\n      this.expressionScope.recordAsyncArrowParametersError({ at: startLoc });\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, { at: startLoc });\n        return;\n      }\n    }\n  }\n\n  isAwaitAllowed(): boolean {\n    if (this.prodParam.hasAwait) return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n\n  // Parses await expression inside async function.\n\n  parseAwait(this: Parser, startLoc: Position): N.AwaitExpression {\n    const node = this.startNodeAt<N.AwaitExpression>(startLoc);\n\n    this.expressionScope.recordParameterInitializerError(\n      Errors.AwaitExpressionFormalParameter,\n      {\n        // @ts-expect-error todo(flow->ts)\n        at: node,\n      },\n    );\n\n    if (this.eat(tt.star)) {\n      this.raise(Errors.ObsoleteAwaitStar, { at: node });\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait(): boolean {\n    if (this.hasPrecedingLineBreak()) return true;\n    const { type } = this.state;\n    return (\n      // All the following expressions are ambiguous:\n      //   await + 0, await - 0, await ( 0 ), await [ 0 ], await / 0 /u, await ``, await of []\n      type === tt.plusMin ||\n      type === tt.parenL ||\n      type === tt.bracketL ||\n      tokenIsTemplate(type) ||\n      (type === tt._of && !this.state.containsEsc) ||\n      // Sometimes the tokenizer generates tt.slash for regexps, and this is\n      // handler by parseExprAtom\n      type === tt.regexp ||\n      type === tt.slash ||\n      // This code could be parsed both as a modulo operator or as an intrinsic:\n      //   await %x(0)\n      (this.hasPlugin(\"v8intrinsic\") && type === tt.modulo)\n    );\n  }\n\n  // Parses yield expression inside generator.\n\n  parseYield(this: Parser): N.YieldExpression {\n    const node = this.startNode<N.YieldExpression>();\n\n    this.expressionScope.recordParameterInitializerError(\n      Errors.YieldInParameter,\n      {\n        // @ts-expect-error todo(flow->ts)\n        at: node,\n      },\n    );\n\n    this.next();\n    let delegating = false;\n    let argument: N.Expression | null = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(tt.star);\n      switch (this.state.type) {\n        case tt.semi:\n        case tt.eof:\n        case tt.braceR:\n        case tt.parenR:\n        case tt.bracketR:\n        case tt.braceBarR:\n        case tt.colon:\n        case tt.comma:\n          // The above is the complete set of tokens that can\n          // follow an AssignmentExpression, and none of them\n          // can start an AssignmentExpression\n          if (!delegating) break;\n        /* fallthrough */\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportCall\n  parseImportCall(\n    this: Parser,\n    node: Undone<N.ImportExpression>,\n  ): N.ImportExpression {\n    this.next(); // eat tt.parenL\n    node.source = this.parseMaybeAssignAllowIn();\n    if (\n      this.hasPlugin(\"importAttributes\") ||\n      this.hasPlugin(\"importAssertions\")\n    ) {\n      node.options = null;\n    }\n    if (this.eat(tt.comma)) {\n      this.expectImportAttributesPlugin();\n      if (!this.match(tt.parenR)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        this.eat(tt.comma);\n      }\n    }\n    this.expect(tt.parenR);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n\n  // Validates a pipeline (for any of the pipeline Babylon plugins) at the point\n  // of the infix operator `|>`.\n\n  checkPipelineAtInfixOperator(left: N.Expression, leftStartLoc: Position) {\n    if (this.hasPlugin([\"pipelineOperator\", { proposal: \"smart\" }])) {\n      if (left.type === \"SequenceExpression\") {\n        // Ensure that the pipeline head is not a comma-delimited\n        // sequence expression.\n        this.raise(Errors.PipelineHeadSequenceExpression, {\n          at: leftStartLoc,\n        });\n      }\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpr: N.Expression, startLoc: Position) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt<N.PipelineBareFunction>(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt<N.PipelineTopicExpression>(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n\n  isSimpleReference(expression: N.Expression): boolean {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return (\n          !expression.computed && this.isSimpleReference(expression.object)\n        );\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // This helper method is to be called immediately\n  // after a topic-style smart-mix pipe body is parsed.\n  // The `startLoc` is the starting position of the pipe body.\n\n  checkSmartPipeTopicBodyEarlyErrors(startLoc: Position): void {\n    // If the following token is invalidly `=>`, then throw a human-friendly error\n    // instead of something like 'Unexpected token, expected \";\"'.\n    // For example, `x => x |> y => #` (assuming `#` is the topic reference)\n    // groups into `x => (x |> y) => #`,\n    // and `(x |> y) => #` is an invalid arrow function.\n    // This is because smart-mix `|>` has tighter precedence than `=>`.\n    if (this.match(tt.arrow)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, { at: this.state.startLoc });\n    }\n\n    // A topic-style smart-mix pipe body must use the topic reference at least once.\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, { at: startLoc });\n    }\n  }\n\n  // Enable topic references from outer contexts within Hack-style pipe bodies.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references.\n  // The function then calls a callback, then resets the parser\n  // to the old topic-context state that it had before the function was called.\n\n  withTopicBindingContext<T>(callback: () => T): T {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      // Enable the use of the primary topic reference.\n      maxNumOfResolvableTopics: 1,\n      // Hide the use of any topic references from outer contexts.\n      maxTopicIndex: null,\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  // This helper method is used only with the deprecated smart-mix pipe proposal.\n  // Disables topic references from outer contexts within syntax constructs\n  // such as the bodies of iteration statements.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references with the smartPipelines plugin. They then run a\n  // callback, then they reset the parser to the old topic-context state that it\n  // had before the function was called.\n\n  withSmartMixTopicForbiddingContext<T>(callback: () => T): T {\n    if (this.hasPlugin([\"pipelineOperator\", { proposal: \"smart\" }])) {\n      // Reset the parser\u2019s topic context only if the smart-mix pipe proposal is active.\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        // Disable the use of the primary topic reference.\n        maxNumOfResolvableTopics: 0,\n        // Hide the use of any topic references from outer contexts.\n        maxTopicIndex: null,\n      };\n\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      // If the pipe proposal is \"minimal\", \"fsharp\", or \"hack\",\n      // or if no pipe proposal is active,\n      // then the callback result is returned\n      // without touching any extra parser state.\n      return callback();\n    }\n  }\n\n  withSoloAwaitPermittingContext<T>(callback: () => T): T {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = ParamKind.PARAM_IN & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | ParamKind.PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  disallowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = ParamKind.PARAM_IN & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~ParamKind.PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  // Register the use of a topic reference within the current\n  // topic-binding context.\n  registerTopicReference(): void {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  topicReferenceIsAllowedInCurrentContext(): boolean {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentContext(): boolean {\n    return (\n      this.state.topicContext.maxTopicIndex != null &&\n      this.state.topicContext.maxTopicIndex >= 0\n    );\n  }\n\n  parseFSharpPipelineBody(this: Parser, prec: number): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n\n    const ret = this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startLoc,\n      prec,\n    );\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return ret;\n  }\n\n  // https://github.com/tc39/proposal-js-module-blocks\n  parseModuleExpression(this: Parser): N.ModuleExpression {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode<N.ModuleExpression>();\n    this.next(); // eat \"module\"\n    if (!this.match(tt.braceL)) {\n      this.unexpected(null, tt.braceL);\n    }\n    // start program node immediately after `{`\n    const program = this.startNodeAt<N.Program>(this.state.endLoc);\n    this.next(); // eat `{`\n\n    const revertScopes = this.initializeScopes(/** inModule */ true);\n    this.enterInitialScopes();\n\n    try {\n      node.body = this.parseProgram(program, tt.braceR, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode<N.ModuleExpression>(node, \"ModuleExpression\");\n  }\n\n  // Used in Flow plugin\n  parsePropertyNamePrefixOperator(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    prop: Undone<N.ObjectOrClassMember | N.ClassMember>,\n  ): void {}\n}\n", "import type * as N from \"../types.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLoop,\n  tokenIsTemplate,\n  tt,\n  type TokenType,\n  getExportedToken,\n} from \"../tokenizer/types.ts\";\nimport ExpressionParser from \"./expression.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport { isIdentifierChar, isIdentifierStart } from \"../util/identifier.ts\";\nimport * as charCodes from \"charcodes\";\nimport {\n  ScopeFlag,\n  ClassElementType,\n  type BindingTypes,\n  BindingFlag,\n} from \"../util/scopeflags.ts\";\nimport { ExpressionErrors } from \"./util.ts\";\nimport { ParamKind, functionFlags } from \"../util/production-parameter.ts\";\nimport {\n  newExpressionScope,\n  newParameterDeclarationScope,\n} from \"../util/expression-scope.ts\";\nimport type { SourceType } from \"../options.ts\";\nimport { Token } from \"../tokenizer/index.ts\";\nimport type { Position } from \"../util/location.ts\";\nimport { createPositionWithColumnOffset } from \"../util/location.ts\";\nimport { cloneStringLiteral, cloneIdentifier, type Undone } from \"./node.ts\";\nimport type Parser from \"./index.ts\";\nimport { ParseBindingListFlags } from \"./lval.ts\";\n\nconst loopLabel = { kind: \"loop\" } as const,\n  switchLabel = { kind: \"switch\" } as const;\n\nexport const enum ParseFunctionFlag {\n  Expression = 0b0000,\n  Declaration = 0b0001,\n  HangingDeclaration = 0b0010,\n  NullableId = 0b0100,\n  Async = 0b1000,\n}\n\nexport const enum ParseStatementFlag {\n  StatementOnly = 0b0000,\n  AllowImportExport = 0b0001,\n  AllowDeclaration = 0b0010,\n  AllowFunctionDeclaration = 0b0100,\n  AllowLabeledFunction = 0b1000,\n}\n\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\n\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\n/**\n * Convert tokens for backward Babel 7 compat.\n * tt.privateName => tt.hash + tt.name\n * tt.templateTail => tt.backquote/tt.braceR + tt.template + tt.backquote\n * tt.templateNonTail => tt.backquote/tt.braceR + tt.template + tt.dollarBraceL\n * For performance reasons this routine mutates `tokens`, it is okay\n * here since we execute `parseTopLevel` once for every file.\n */\nfunction babel7CompatTokens(tokens: (Token | N.Comment)[], input: string) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const { type } = token;\n    if (typeof type === \"number\") {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (type === tt.privateName) {\n          const { loc, start, value, end } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(\n            i,\n            1,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.hash),\n              value: \"#\",\n              start: start,\n              end: hashEndPos,\n              startLoc: loc.start,\n              endLoc: hashEndLoc,\n            }),\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.name),\n              value: value,\n              start: hashEndPos,\n              end: end,\n              startLoc: hashEndLoc,\n              endLoc: loc.end,\n            }),\n          );\n          i++;\n          continue;\n        }\n\n        if (tokenIsTemplate(type)) {\n          const { loc, start, value, end } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === charCodes.graveAccent) {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          } else {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.braceR),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          }\n          let templateValue,\n            templateElementEnd,\n            templateElementEndLoc,\n            endToken;\n          if (type === tt.templateTail) {\n            // ends with '`'\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          } else {\n            // ends with `${`\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.dollarBraceL),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          }\n          tokens.splice(\n            i,\n            1,\n            startToken,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.template),\n              value: templateValue,\n              start: backquoteEnd,\n              end: templateElementEnd,\n              startLoc: backquoteEndLoc,\n              endLoc: templateElementEndLoc,\n            }),\n            endToken,\n          );\n          i += 2;\n          continue;\n        }\n      }\n      // @ts-expect-error: we manipulate `token` for performance reasons\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nexport default abstract class StatementParser extends ExpressionParser {\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  parseTopLevel(this: Parser, file: N.File, program: N.Program): N.File {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(\n    this: Parser,\n    program: Undone<N.Program>,\n    end: TokenType = tt.eof,\n    sourceType: SourceType = this.options.sourceType,\n  ): N.Program {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (\n      this.inModule &&\n      !this.options.allowUndeclaredExports &&\n      this.scope.undefinedExports.size > 0\n    ) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, { at, localName });\n      }\n    }\n    let finishedProgram: N.Program;\n    if (end === tt.eof) {\n      // finish at eof for top level program\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      // finish immediately before the end token\n      finishedProgram = this.finishNodeAt(\n        program,\n        \"Program\",\n        createPositionWithColumnOffset(this.state.startLoc, -1),\n      );\n    }\n    return finishedProgram;\n  }\n\n  /**\n   * cast a Statement to a Directive. This method mutates input statement.\n   */\n  stmtToDirective(stmt: N.Statement): N.Directive {\n    const directive = stmt as any;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n\n    directiveLiteral.type = \"DirectiveLiteral\";\n\n    return directive;\n  }\n\n  parseInterpreterDirective(): N.InterpreterDirective | null {\n    if (!this.match(tt.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode<N.InterpreterDirective>();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(): boolean {\n    if (!this.isContextual(tt._let)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n\n  chStartsBindingIdentifier(ch: number, pos: number) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        // We have seen `in` or `instanceof` so far, now check if the identifier\n        // ends here\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== charCodes.backslash) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === charCodes.backslash) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  chStartsBindingPattern(ch: number) {\n    return (\n      ch === charCodes.leftSquareBracket || ch === charCodes.leftCurlyBrace\n    );\n  }\n\n  /**\n   * Assuming we have seen a contextual `let` and declaration is allowed, check if it\n   * starts a variable declaration so that it should be interpreted as a keyword.\n   */\n  hasFollowingBindingAtom(): boolean {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return (\n      this.chStartsBindingPattern(nextCh) ||\n      this.chStartsBindingIdentifier(nextCh, next)\n    );\n  }\n\n  /**\n   * Assuming we have seen a contextual `using` and declaration is allowed, check if it\n   * starts a variable declaration in the same line so that it should be interpreted as\n   * a keyword.\n   */\n  hasInLineFollowingBindingIdentifier(): boolean {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n\n  startsUsingForOf(): boolean {\n    const { type, containsEsc } = this.lookahead();\n    if (type === tt._of && !containsEsc) {\n      // `using of` must start a for-lhs-of statement\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n\n  startsAwaitUsing(): boolean {\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        this.expectPlugin(\"explicitResourceManagement\");\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleItem\n  parseModuleItem(this: Parser) {\n    return this.parseStatementLike(\n      ParseStatementFlag.AllowImportExport |\n        ParseStatementFlag.AllowDeclaration |\n        ParseStatementFlag.AllowFunctionDeclaration |\n        // This function is actually also used to parse StatementItems,\n        // which with Annex B enabled allows labeled functions.\n        ParseStatementFlag.AllowLabeledFunction,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-StatementListItem\n  parseStatementListItem(this: Parser) {\n    return this.parseStatementLike(\n      ParseStatementFlag.AllowDeclaration |\n        ParseStatementFlag.AllowFunctionDeclaration |\n        (!this.options.annexB || this.state.strict\n          ? 0\n          : ParseStatementFlag.AllowLabeledFunction),\n    );\n  }\n\n  parseStatementOrSloppyAnnexBFunctionDeclaration(\n    this: Parser,\n    allowLabeledFunction: boolean = false,\n  ) {\n    let flags: ParseStatementFlag = ParseStatementFlag.StatementOnly;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= ParseStatementFlag.AllowFunctionDeclaration;\n      if (allowLabeledFunction) {\n        flags |= ParseStatementFlag.AllowLabeledFunction;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n  // https://tc39.es/ecma262/#prod-Statement\n  parseStatement(this: Parser) {\n    return this.parseStatementLike(ParseStatementFlag.StatementOnly);\n  }\n\n  // ImportDeclaration and ExportDeclaration are also handled here so we can throw recoverable errors\n  // when they are not at the top level\n  parseStatementLike(\n    this: Parser,\n    flags: ParseStatementFlag,\n  ):\n    | N.Statement\n    | N.Declaration\n    | N.ImportDeclaration\n    | N.ExportDefaultDeclaration\n    | N.ExportNamedDeclaration\n    | N.ExportAllDeclaration {\n    let decorators: N.Decorator[] | null = null;\n\n    if (this.match(tt.at)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n\n  parseStatementContent(\n    this: Parser,\n    flags: ParseStatementFlag,\n    decorators?: N.Decorator[] | null,\n  ): N.Statement {\n    const starttype = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & ParseStatementFlag.AllowDeclaration);\n    const allowFunctionDeclaration = !!(\n      flags & ParseStatementFlag.AllowFunctionDeclaration\n    );\n    const topLevel = flags & ParseStatementFlag.AllowImportExport;\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case tt._break:\n        return this.parseBreakContinueStatement(node, /* isBreak */ true);\n      case tt._continue:\n        return this.parseBreakContinueStatement(node, /* isBreak */ false);\n      case tt._debugger:\n        return this.parseDebuggerStatement(node as Undone<N.DebuggerStatement>);\n      case tt._do:\n        return this.parseDoWhileStatement(node as Undone<N.DoWhileStatement>);\n      case tt._for:\n        return this.parseForStatement(node as Undone<N.ForStatement>);\n      case tt._function:\n        if (this.lookaheadCharCode() === charCodes.dot) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(\n            this.state.strict\n              ? Errors.StrictFunction\n              : this.options.annexB\n                ? Errors.SloppyFunctionAnnexB\n                : Errors.SloppyFunction,\n            { at: this.state.startLoc },\n          );\n        }\n        return this.parseFunctionStatement(\n          node as Undone<N.FunctionDeclaration>,\n          false,\n          !allowDeclaration && allowFunctionDeclaration,\n        );\n      case tt._class:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(\n          this.maybeTakeDecorators(\n            decorators,\n            node as Undone<N.ClassDeclaration>,\n          ),\n          true,\n        );\n\n      case tt._if:\n        return this.parseIfStatement(node as Undone<N.IfStatement>);\n      case tt._return:\n        return this.parseReturnStatement(node as Undone<N.ReturnStatement>);\n      case tt._switch:\n        return this.parseSwitchStatement(node as Undone<N.SwitchStatement>);\n      case tt._throw:\n        return this.parseThrowStatement(node as Undone<N.ThrowStatement>);\n      case tt._try:\n        return this.parseTryStatement(node as Undone<N.TryStatement>);\n\n      case tt._await:\n        // [+Await] await [no LineTerminator here] using [no LineTerminator here] BindingList[+Using]\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, { at: node });\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, {\n              at: node,\n            });\n          }\n          this.next(); // eat 'await'\n          return this.parseVarStatement(\n            node as Undone<N.VariableDeclaration>,\n            \"await using\",\n          );\n        }\n        break;\n      case tt._using:\n        // using [no LineTerminator here] BindingList[+Using]\n        if (\n          this.state.containsEsc ||\n          !this.hasInLineFollowingBindingIdentifier()\n        ) {\n          break;\n        }\n        this.expectPlugin(\"explicitResourceManagement\");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, {\n            at: this.state.startLoc,\n          });\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc,\n          });\n        }\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          \"using\",\n        );\n      case tt._let: {\n        if (this.state.containsEsc) {\n          break;\n        }\n        // `let [` is an explicit negative lookahead for\n        // ExpressionStatement, so special-case it first.\n        const next = this.nextTokenStart();\n        const nextCh = this.codePointAtPos(next);\n        if (nextCh !== charCodes.leftSquareBracket) {\n          if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n          if (\n            !this.chStartsBindingIdentifier(nextCh, next) &&\n            nextCh !== charCodes.leftCurlyBrace\n          ) {\n            break;\n          }\n        }\n      }\n      // fall through\n      case tt._const: {\n        if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc,\n          });\n        }\n      }\n      // fall through\n      case tt._var: {\n        const kind = this.state.value;\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          kind,\n        );\n      }\n      case tt._while:\n        return this.parseWhileStatement(node as Undone<N.WhileStatement>);\n      case tt._with:\n        return this.parseWithStatement(node as Undone<N.WithStatement>);\n      case tt.braceL:\n        return this.parseBlock();\n      case tt.semi:\n        return this.parseEmptyStatement(node as Undone<N.EmptyStatement>);\n      case tt._import: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (\n          nextTokenCharCode === charCodes.leftParenthesis || // import()\n          nextTokenCharCode === charCodes.dot // import.meta\n        ) {\n          break;\n        }\n      }\n      // fall through\n      case tt._export: {\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\n          this.raise(Errors.UnexpectedImportExport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        this.next(); // eat `import`/`export`\n\n        let result;\n        if (starttype === tt._import) {\n          result = this.parseImport(node as Undone<N.ImportDeclaration>);\n\n          if (\n            result.type === \"ImportDeclaration\" &&\n            (!result.importKind || result.importKind === \"value\")\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        } else {\n          result = this.parseExport(\n            node as Undone<\n              | N.ExportAllDeclaration\n              | N.ExportDefaultDeclaration\n              | N.ExportDefaultDeclaration\n            >,\n            decorators,\n          );\n\n          if (\n            (result.type === \"ExportNamedDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            (result.type === \"ExportAllDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            result.type === \"ExportDefaultDeclaration\"\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        }\n\n        this.assertModuleNodeAllowed(result);\n\n        return result;\n      }\n\n      default: {\n        if (this.isAsyncFunction()) {\n          if (!allowDeclaration) {\n            this.raise(Errors.AsyncFunctionInSingleStatementContext, {\n              at: this.state.startLoc,\n            });\n          }\n          this.next(); // eat 'async'\n          return this.parseFunctionStatement(\n            node as Undone<N.FunctionDeclaration>,\n            true,\n            !allowDeclaration && allowFunctionDeclaration,\n          );\n        }\n      }\n    }\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (\n      tokenIsIdentifier(starttype) &&\n      expr.type === \"Identifier\" &&\n      this.eat(tt.colon)\n    ) {\n      return this.parseLabeledStatement(\n        node as Undone<N.LabeledStatement>,\n        maybeName,\n        // @ts-expect-error migrate to Babel types\n        expr,\n        flags,\n      );\n    } else {\n      return this.parseExpressionStatement(\n        node as Undone<N.ExpressionStatement>,\n        expr,\n        decorators,\n      );\n    }\n  }\n\n  assertModuleNodeAllowed(node: N.Node): void {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, { at: node });\n    }\n  }\n\n  decoratorsEnabledBeforeExport(): boolean {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return (\n      this.hasPlugin(\"decorators\") &&\n      this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false\n    );\n  }\n\n  // Attach the decorators to the given class.\n  // NOTE: This method changes the .start location of the class, and thus\n  // can affect comment attachment. Calling it before or after finalizing\n  // the class node (and thus finalizing its comments) changes how comments\n  // before the `class` keyword or before the final .start location of the\n  // class are attached.\n  maybeTakeDecorators<T extends Undone<N.Class>>(\n    maybeDecorators: N.Decorator[] | null,\n    classNode: T,\n    exportNode?: Undone<N.ExportDefaultDeclaration | N.ExportNamedDeclaration>,\n  ): T {\n    if (maybeDecorators) {\n      if (classNode.decorators && classNode.decorators.length > 0) {\n        // Note: decorators attachment is only attempred multiple times\n        // when the class is part of an export declaration.\n        if (\n          typeof this.getPluginOption(\n            \"decorators\",\n            \"decoratorsBeforeExport\",\n          ) !== \"boolean\"\n        ) {\n          // If `decoratorsBeforeExport` was set to `true` or `false`, we\n          // already threw an error about decorators not being in a valid\n          // position.\n          this.raise(Errors.DecoratorsBeforeAfterExport, {\n            at: classNode.decorators[0],\n          });\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n\n  canHaveLeadingDecorator(): boolean {\n    return this.match(tt._class);\n  }\n\n  parseDecorators(this: Parser, allowExport?: boolean): N.Decorator[] {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(tt.at));\n\n    if (this.match(tt._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, { at: this.state.startLoc });\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, {\n        at: this.state.startLoc,\n      });\n    }\n\n    return decorators;\n  }\n\n  parseDecorator(this: Parser): N.Decorator {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n    const node = this.startNode<N.Decorator>();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr: N.Expression;\n\n      if (this.match(tt.parenL)) {\n        const startLoc = this.state.startLoc;\n        this.next(); // eat '('\n        expr = this.parseExpression();\n        this.expect(tt.parenR);\n        expr = this.wrapParenthesis(startLoc, expr);\n\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (\n          this.getPluginOption(\"decorators\", \"allowCallParenthesized\") ===\n            false &&\n          node.expression !== expr\n        ) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, {\n            at: paramsStartLoc,\n          });\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(tt.dot)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(tt.privateName)) {\n            this.classScope.usePrivateName(\n              this.state.value,\n              this.state.startLoc,\n            );\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(this: Parser, expr: N.Expression): N.Expression {\n    if (this.eat(tt.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: true,\n  ): N.BreakStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: false,\n  ): N.ContinueStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ): N.BreakStatement | N.ContinueStatement {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n\n    return this.finishNode(\n      node,\n      isBreak ? \"BreakStatement\" : \"ContinueStatement\",\n    );\n  }\n\n  verifyBreakContinue(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, { at: node, type });\n    }\n  }\n\n  parseDebuggerStatement(\n    node: Undone<N.DebuggerStatement>,\n  ): N.DebuggerStatement {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression(this: Parser): N.Expression {\n    this.expect(tt.parenL);\n    const val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  }\n\n  // https://tc39.es/ecma262/#prod-DoWhileStatement\n  parseDoWhileStatement(\n    this: Parser,\n    node: Undone<N.DoWhileStatement>,\n  ): N.DoWhileStatement {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body's body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body's body.\n        this.parseStatement(),\n      );\n\n    this.state.labels.pop();\n\n    this.expect(tt._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(tt.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  parseForStatement(\n    this: Parser,\n    node: Undone<N.ForStatement | N.ForInOf>,\n  ): N.ForLike {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    let awaitAt = null;\n\n    if (this.isAwaitAllowed() && this.eatContextual(tt._await)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(ScopeFlag.OTHER);\n    this.expect(tt.parenL);\n\n    if (this.match(tt.semi)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node as Undone<N.ForStatement>, null);\n    }\n\n    const startsWithLet = this.isContextual(tt._let);\n    {\n      const startsWithAwaitUsing =\n        this.isContextual(tt._await) && this.startsAwaitUsing();\n      const starsWithUsingDeclaration =\n        startsWithAwaitUsing ||\n        (this.isContextual(tt._using) && this.startsUsingForOf());\n      const isLetOrUsing =\n        (startsWithLet && this.hasFollowingBindingAtom()) ||\n        starsWithUsingDeclaration;\n\n      if (this.match(tt._var) || this.match(tt._const) || isLetOrUsing) {\n        const initNode = this.startNode<N.VariableDeclaration>();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, {\n              at: this.state.startLoc,\n            });\n          }\n          this.next(); // eat 'await'\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, \"VariableDeclaration\");\n\n        const isForIn = this.match(tt._in);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, { at: init });\n        }\n        if (\n          (isForIn || this.isContextual(tt._of)) &&\n          init.declarations.length === 1\n        ) {\n          return this.parseForIn(node as Undone<N.ForInOf>, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node as Undone<N.ForStatement>, init);\n      }\n    }\n\n    // Check whether the first token is possibly a contextual keyword, so that\n    // we can forbid `for (async of` if this turns out to be a for-of loop.\n    const startsWithAsync = this.isContextual(tt._async);\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(tt._of);\n    if (isForOf) {\n      // Check for leading tokens that are forbidden in for-of loops:\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, { at: init });\n      }\n\n      if (\n        // `for await (async of []);` is allowed.\n        awaitAt === null &&\n        startsWithAsync &&\n        init.type === \"Identifier\"\n      ) {\n        // This catches the case where the `async` in `for (async of` was\n        // parsed as an identifier. If it was parsed as the start of an async\n        // arrow function (e.g. `for (async of => {} of []);`), the LVal check\n        // further down will raise a more appropriate error.\n        this.raise(Errors.ForOfAsync, { at: init });\n      }\n    }\n    if (isForOf || this.match(tt._in)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, /* isLHS */ true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, { in: { type } });\n      return this.parseForIn(\n        node as Undone<N.ForInStatement | N.ForOfStatement>,\n        // @ts-expect-error init has been transformed to an assignable\n        init,\n        awaitAt,\n      );\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node as Undone<N.ForStatement>, init);\n  }\n\n  // https://tc39.es/ecma262/#prod-HoistableDeclaration\n  parseFunctionStatement(\n    this: Parser,\n    node: Undone<N.FunctionDeclaration>,\n    isAsync: boolean,\n    isHangingDeclaration: boolean,\n  ): N.FunctionDeclaration {\n    this.next(); // eat 'function'\n    return this.parseFunction(\n      node,\n      ParseFunctionFlag.Declaration |\n        (isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : 0) |\n        (isAsync ? ParseFunctionFlag.Async : 0),\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-IfStatement\n  parseIfStatement(this: Parser, node: Undone<N.IfStatement>) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    // Annex B.3.3\n    // https://tc39.es/ecma262/#sec-functiondeclarations-in-ifstatement-statement-clauses\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(tt._else)\n      ? this.parseStatementOrSloppyAnnexBFunctionDeclaration()\n      : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(this: Parser, node: Undone<N.ReturnStatement>) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, { at: this.state.startLoc });\n    }\n\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-SwitchStatement\n  parseSwitchStatement(this: Parser, node: Undone<N.SwitchStatement>) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases: N.SwitchStatement[\"cases\"] = (node.cases = []);\n    this.expect(tt.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(ScopeFlag.OTHER);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    let cur;\n    for (let sawDefault; !this.match(tt.braceR); ) {\n      if (this.match(tt._case) || this.match(tt._default)) {\n        const isCase = this.match(tt._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        // @ts-expect-error Fixme\n        cases.push((cur = this.startNode()));\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(tt.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(this: Parser, node: Undone<N.ThrowStatement>) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, { at: this.state.lastTokEndLoc });\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam(this: Parser): N.Pattern {\n    const param = this.parseBindingAtom();\n\n    this.scope.enter(\n      this.options.annexB && param.type === \"Identifier\"\n        ? ScopeFlag.SIMPLE_CATCH\n        : 0,\n    );\n    this.checkLVal(param, {\n      in: { type: \"CatchClause\" },\n      binding: BindingFlag.TYPE_CATCH_PARAM,\n    });\n\n    return param;\n  }\n\n  parseTryStatement(\n    this: Parser,\n    node: Undone<N.TryStatement>,\n  ): N.TryStatement {\n    this.next();\n\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(tt._catch)) {\n      const clause = this.startNode<N.CatchClause>();\n      this.next();\n      if (this.match(tt.parenL)) {\n        this.expect(tt.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(tt.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(ScopeFlag.OTHER);\n      }\n\n      // Parse the catch clause's body.\n      clause.body =\n        // For the smartPipelines plugin: Disable topic references from outer\n        // contexts within the catch clause's body.\n        this.withSmartMixTopicForbiddingContext(() =>\n          // Parse the catch clause's body.\n          this.parseBlock(false, false),\n        );\n\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, { at: node });\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-VariableStatement\n  // https://tc39.es/ecma262/#prod-LexicalDeclaration\n  parseVarStatement(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n    allowMissingInitializer: boolean = false,\n  ): N.VariableDeclaration {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  // https://tc39.es/ecma262/#prod-WhileStatement\n  parseWhileStatement(\n    this: Parser,\n    node: Undone<N.WhileStatement>,\n  ): N.WhileStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(),\n      );\n\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(\n    this: Parser,\n    node: Undone<N.WithStatement>,\n  ): N.WithStatement {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, { at: this.state.startLoc });\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n\n    // Parse the statement body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the with statement's body.\n      // They are permitted in function default-parameter expressions, which are\n      // part of the outer context, outside of the with statement's body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the statement body.\n        this.parseStatement(),\n      );\n\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node: Undone<N.EmptyStatement>): N.EmptyStatement {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-LabelledStatement\n  parseLabeledStatement(\n    this: Parser,\n    node: Undone<N.LabeledStatement>,\n    maybeName: string,\n    expr: N.Identifier,\n    flags: ParseStatementFlag,\n  ): N.LabeledStatement {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, {\n          at: expr,\n          labelName: maybeName,\n        });\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type)\n      ? \"loop\"\n      : this.match(tt._switch)\n        ? \"switch\"\n        : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start,\n    });\n    // https://tc39.es/ecma262/#prod-LabelledItem\n    node.body =\n      flags & ParseStatementFlag.AllowLabeledFunction\n        ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true)\n        : this.parseStatement();\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(\n    node: Undone<N.ExpressionStatement>,\n    expr: N.Expression,\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    decorators: N.Decorator[] | null,\n  ) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowDirectives` is true (used for\n  // function bodies).\n\n  parseBlock(\n    this: Parser,\n    allowDirectives: boolean = false,\n    createNewLexicalScope: boolean = true,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement {\n    const node = this.startNode<N.BlockStatement>();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(tt.braceL);\n    if (createNewLexicalScope) {\n      this.scope.enter(ScopeFlag.OTHER);\n    }\n    this.parseBlockBody(\n      node,\n      allowDirectives,\n      false,\n      tt.braceR,\n      afterBlockParse,\n    );\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt: N.Statement): boolean {\n    return (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"StringLiteral\" &&\n      !stmt.expression.extra.parenthesized\n    );\n  }\n\n  parseBlockBody(\n    this: Parser,\n    node: Undone<N.BlockStatementLike>,\n    allowDirectives: boolean | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const body: N.BlockStatementLike[\"body\"] = (node.body = []);\n    const directives: N.BlockStatementLike[\"directives\"] = (node.directives =\n      []);\n    this.parseBlockOrModuleBlockBody(\n      body,\n      allowDirectives ? directives : undefined,\n      topLevel,\n      end,\n      afterBlockParse,\n    );\n  }\n\n  // Undefined directives means that directives are not allowed.\n  // https://tc39.es/ecma262/#prod-Block\n  // https://tc39.es/ecma262/#prod-ModuleBody\n  parseBlockOrModuleBlockBody(\n    this: Parser,\n    body: N.Statement[],\n    directives: N.Directive[] | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = topLevel\n        ? this.parseModuleItem()\n        : this.parseStatementListItem();\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (\n            !hasStrictModeDirective &&\n            directive.value.value === \"use strict\"\n          ) {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n        parsedNonDirective = true;\n        // clear strict errors since the strict mode will not change within the block\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n\n    afterBlockParse?.call(this, hasStrictModeDirective);\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  parseFor(\n    this: Parser,\n    node: Undone<N.ForStatement>,\n    init?: N.VariableDeclaration | N.Expression | null,\n  ): N.ForStatement {\n    node.init = init;\n    this.semicolon(/* allowAsi */ false);\n    node.test = this.match(tt.semi) ? null : this.parseExpression();\n    this.semicolon(/* allowAsi */ false);\n    node.update = this.match(tt.parenR) ? null : this.parseExpression();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body.\n        this.parseStatement(),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  parseForIn(\n    this: Parser,\n    node: Undone<N.ForInOf>,\n    init: N.VariableDeclaration | N.AssignmentPattern,\n    awaitAt?: Position | null,\n  ): N.ForInOf {\n    const isForIn = this.match(tt._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (!isForIn ||\n        !this.options.annexB ||\n        this.state.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\")\n    ) {\n      this.raise(Errors.ForInOfLoopInitializer, {\n        at: init,\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\",\n      });\n    }\n\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, {\n        at: init,\n        ancestor: { type: \"ForStatement\" },\n      });\n    }\n\n    node.left = init;\n    node.right = isForIn\n      ? this.parseExpression()\n      : this.parseMaybeAssignAllowIn();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  parseVar(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    isFor: boolean,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n    allowMissingInitializer: boolean = false,\n  ): Undone<N.VariableDeclaration> {\n    const declarations: N.VariableDeclarator[] = (node.declarations = []);\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode<N.VariableDeclarator>();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(tt.eq)\n        ? null\n        : isFor\n          ? this.parseMaybeAssignDisallowIn()\n          : this.parseMaybeAssignAllowIn();\n\n      if (decl.init === null && !allowMissingInitializer) {\n        if (\n          decl.id.type !== \"Identifier\" &&\n          !(isFor && (this.match(tt._in) || this.isContextual(tt._of)))\n        ) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"destructuring\",\n          });\n        } else if (\n          kind === \"const\" &&\n          !(this.match(tt._in) || this.isContextual(tt._of))\n        ) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"const\",\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(tt.comma)) break;\n    }\n    return node;\n  }\n\n  parseVarId(\n    this: Parser,\n    decl: Undone<N.VariableDeclarator>,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n  ): void {\n    const id = this.parseBindingAtom();\n    this.checkLVal(id, {\n      in: { type: \"VariableDeclarator\" },\n      binding: kind === \"var\" ? BindingFlag.TYPE_VAR : BindingFlag.TYPE_LEXICAL,\n    });\n    decl.id = id;\n  }\n\n  // https://tc39.es/ecma262/#prod-AsyncFunctionExpression\n  parseAsyncFunctionExpression(\n    this: Parser,\n    node: Undone<N.FunctionExpression>,\n  ): N.FunctionExpression {\n    return this.parseFunction(node, ParseFunctionFlag.Async);\n  }\n\n  // Parse a function declaration or expression (depending on the\n  // ParseFunctionFlag.Declaration flag).\n\n  parseFunction<T extends N.NormalFunction>(\n    this: Parser,\n    node: Undone<T>,\n    flags: ParseFunctionFlag = ParseFunctionFlag.Expression,\n  ): T {\n    const hangingDeclaration = flags & ParseFunctionFlag.HangingDeclaration;\n    const isDeclaration = !!(flags & ParseFunctionFlag.Declaration);\n    const requireId = isDeclaration && !(flags & ParseFunctionFlag.NullableId);\n    const isAsync = !!(flags & ParseFunctionFlag.Async);\n\n    this.initFunction(node, isAsync);\n\n    if (this.match(tt.star)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, {\n          at: this.state.startLoc,\n        });\n      }\n      this.next(); // eat *\n      node.generator = true;\n    }\n\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(ScopeFlag.FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, /* isConstructor */ false);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the function body. They are permitted in function\n    // default-parameter expressions, outside of the function body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the function body.\n      this.parseFunctionBodyAndFinish(\n        node,\n        isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\",\n      );\n    });\n\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isDeclaration && !hangingDeclaration) {\n      // We need to register this _after_ parsing the function body\n      // because of TypeScript body-less function declarations,\n      // which shouldn't be added to the scope.\n      this.registerFunctionStatementId(node as T);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node as T;\n  }\n\n  parseFunctionId(requireId?: boolean): N.Identifier | undefined | null {\n    return requireId || tokenIsIdentifier(this.state.type)\n      ? this.parseIdentifier()\n      : null;\n  }\n\n  parseFunctionParams(\n    this: Parser,\n    node: Undone<N.Function>,\n    isConstructor?: boolean,\n  ): void {\n    this.expect(tt.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(\n      tt.parenR,\n      charCodes.rightParenthesis,\n      ParseBindingListFlags.IS_FUNCTION_PARAMS |\n        (isConstructor ? ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS : 0),\n    );\n\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node: N.Function): void {\n    if (!node.id) return;\n\n    // If it is a regular function declaration in sloppy mode, then it is\n    // subject to Annex B semantics (BindingFlag.TYPE_FUNCTION). Otherwise, the binding\n    // mode depends on properties of the current scope (see\n    // treatFunctionsAsVar).\n    this.scope.declareName(\n      node.id.name,\n      !this.options.annexB || this.state.strict || node.generator || node.async\n        ? this.scope.treatFunctionsAsVar\n          ? BindingFlag.TYPE_VAR\n          : BindingFlag.TYPE_LEXICAL\n        : BindingFlag.TYPE_FUNCTION,\n      node.id.loc.start,\n    );\n  }\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseClass<T extends N.Class>(\n    this: Parser,\n    node: Undone<T>,\n    isStatement: /* T === ClassDeclaration */ boolean,\n    optionalId?: boolean,\n  ): T {\n    this.next(); // 'class'\n\n    // A class definition is always strict mode code.\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    // this.state.strict is restored in parseClassBody\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n\n    return this.finishNode(\n      node,\n      isStatement ? \"ClassDeclaration\" : \"ClassExpression\",\n    );\n  }\n\n  isClassProperty(): boolean {\n    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);\n  }\n\n  isClassMethod(): boolean {\n    return this.match(tt.parenL);\n  }\n\n  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n    return (\n      !method.computed &&\n      !method.static &&\n      (method.key.name === \"constructor\" || // Identifier\n        method.key.value === \"constructor\") // String literal\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassBody\n  parseClassBody(\n    this: Parser,\n    hadSuperClass: boolean,\n    oldStrict: boolean,\n  ): N.ClassBody {\n    this.classScope.enter();\n\n    const state: N.ParseClassMemberState = {\n      hadConstructor: false,\n      hadSuperClass,\n    };\n    let decorators: N.Decorator[] = [];\n    const classBody = this.startNode<N.ClassBody>();\n    classBody.body = [];\n\n    this.expect(tt.braceL);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the class body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the contents within the braces.\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, {\n              at: this.state.lastTokEndLoc,\n            });\n          }\n          continue;\n        }\n\n        if (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode<N.ClassMember>();\n\n        // steal the decorators if there are any\n        if (decorators.length) {\n          // @ts-expect-error Fixme\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (\n          // @ts-expect-error Fixme\n          member.kind === \"constructor\" &&\n          // @ts-expect-error Fixme\n          member.decorators &&\n          // @ts-expect-error Fixme\n          member.decorators.length > 0\n        ) {\n          this.raise(Errors.DecoratorConstructor, { at: member });\n        }\n      }\n    });\n\n    this.state.strict = oldStrict;\n\n    this.next(); // eat `}`\n\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, { at: this.state.startLoc });\n    }\n\n    this.classScope.exit();\n\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  // returns true if the current identifier is a method/field name,\n  // false if it is a modifier\n  parseClassMemberFromModifier(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n  ): boolean {\n    const key = this.parseIdentifier(true); // eats the modifier\n\n    if (this.isClassMethod()) {\n      const method: N.ClassMethod = member as any;\n\n      // a method named like the modifier\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(\n        classBody,\n        method,\n        false,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop: N.ClassProperty = member as any;\n\n      // a property named like the modifier\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n  ): void {\n    const isStatic = this.isContextual(tt._static);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        // a class element named 'static'\n        return;\n      }\n      if (this.eat(tt.braceL)) {\n        this.parseClassStaticBlock(classBody, member as any as N.StaticBlock);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n    isStatic: boolean,\n  ) {\n    const publicMethod = member as N.ClassMethod;\n    const privateMethod = member as N.ClassPrivateMethod;\n    const publicProp = member as N.ClassProperty;\n    const privateProp = member as N.ClassPrivateProperty;\n    const accessorProp = member as N.ClassAccessorProperty;\n\n    const method: typeof publicMethod | typeof privateMethod = publicMethod;\n    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;\n\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n\n    if (this.eat(tt.star)) {\n      // a generator\n      method.kind = \"method\";\n      const isPrivateName = this.match(tt.privateName);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        // Private generator method\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, {\n          at: publicMethod.key,\n        });\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        true,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n\n      return;\n    }\n\n    const isContextual =\n      tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(tt.privateName);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      // a normal method\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        // TypeScript allows multiple overloaded constructor declarations.\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, { at: key });\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, { at: key });\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        false,\n        false,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (\n      isContextual &&\n      key.name === \"async\" &&\n      !this.isLineTerminator()\n    ) {\n      // an async method\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(tt.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n\n      method.kind = \"method\";\n      // The so-called parsed name would have been \"async\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        // private async method\n        this.pushClassPrivateMethod(\n          classBody,\n          privateMethod,\n          isGenerator,\n          true,\n        );\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, { at: publicMethod.key });\n        }\n\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          isGenerator,\n          true,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n    } else if (\n      isContextual &&\n      (key.name === \"get\" || key.name === \"set\") &&\n      !(this.match(tt.star) && this.isLineTerminator())\n    ) {\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n      // a getter or setter\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      // The so-called parsed name would have been \"get/set\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        // private getter/setter\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, { at: publicMethod.key });\n        }\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          false,\n          false,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (\n      isContextual &&\n      key.name === \"accessor\" &&\n      !this.isLineTerminator()\n    ) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n\n      // The so-called parsed name would have been \"accessor\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassElementName\n  parseClassElementName(\n    this: Parser,\n    member: Undone<N.ClassMember>,\n  ): N.Expression | N.Identifier {\n    const { type, value } = this.state;\n    if (\n      (type === tt.name || type === tt.string) &&\n      member.static &&\n      value === \"prototype\"\n    ) {\n      this.raise(Errors.StaticPrototype, { at: this.state.startLoc });\n    }\n\n    if (type === tt.privateName) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, {\n          at: this.state.startLoc,\n        });\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n\n    return this.parsePropertyName(member);\n  }\n\n  parseClassStaticBlock(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<\n      N.StaticBlock & {\n        decorators?: Array<N.Decorator>;\n      }\n    >,\n  ) {\n    // Start a new lexical scope\n    this.scope.enter(\n      ScopeFlag.CLASS | ScopeFlag.STATIC_BLOCK | ScopeFlag.SUPER,\n    );\n    // Start a new scope with regard to loop labels\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    // ClassStaticBlockStatementList:\n    //   StatementList[~Yield, ~Await, ~Return] opt\n    this.prodParam.enter(ParamKind.PARAM);\n    const body: N.Node[] = (member.body = []);\n    this.parseBlockOrModuleBlockBody(body, undefined, false, tt.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode<N.StaticBlock>(member, \"StaticBlock\"));\n    if (member.decorators?.length) {\n      this.raise(Errors.DecoratorStaticBlock, { at: member });\n    }\n  }\n\n  pushClassProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassProperty,\n  ) {\n    if (\n      !prop.computed &&\n      (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")\n    ) {\n      // Non-computed field, which is either an identifier named \"constructor\"\n      // or a string literal named \"constructor\"\n      this.raise(Errors.ConstructorClassField, { at: prop.key });\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: Undone<N.ClassPrivateProperty>,\n  ) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      ClassElementType.OTHER,\n      node.key.loc.start,\n    );\n  }\n\n  pushClassAccessorProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassAccessorProperty,\n    isPrivate: boolean,\n  ) {\n    if (!isPrivate && !prop.computed) {\n      // Not private, so not node is not a PrivateName and we can safely cast\n      const key = prop.key as N.Expression;\n\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        // Non-computed field, which is either an identifier named \"constructor\"\n        // or a string literal named \"constructor\"\n        this.raise(Errors.ConstructorClassField, { at: key });\n      }\n    }\n\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n\n    if (isPrivate) {\n      this.classScope.declarePrivateName(\n        this.getPrivateNameSV(node.key),\n        ClassElementType.OTHER,\n        node.key.loc.start,\n      );\n    }\n  }\n\n  pushClassMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowsDirectSuper: boolean,\n  ): void {\n    classBody.body.push(\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      ),\n    );\n  }\n\n  pushClassPrivateMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassPrivateMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n  ): void {\n    const node = this.parseMethod(\n      method,\n      isGenerator,\n      isAsync,\n      /* isConstructor */ false,\n      false,\n      \"ClassPrivateMethod\",\n      true,\n    );\n    classBody.body.push(node);\n\n    const kind =\n      node.kind === \"get\"\n        ? node.static\n          ? ClassElementType.STATIC_GETTER\n          : ClassElementType.INSTANCE_GETTER\n        : node.kind === \"set\"\n          ? node.static\n            ? ClassElementType.STATIC_SETTER\n            : ClassElementType.INSTANCE_SETTER\n          : ClassElementType.OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  declareClassPrivateMethodInScope(\n    node: Undone<\n      N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod\n    >,\n    kind: number,\n  ) {\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      kind,\n      node.key.loc.start,\n    );\n  }\n\n  // Overridden in typescript.js\n  parsePostMemberNameModifiers(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    methodOrProp: Undone<N.ClassMethod | N.ClassProperty>,\n  ): void {}\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassPrivateProperty(\n    this: Parser,\n    node: Undone<N.ClassPrivateProperty>,\n  ): N.ClassPrivateProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassProperty(this: Parser, node: N.ClassProperty): N.ClassProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassAccessorProperty(\n    this: Parser,\n    node: N.ClassAccessorProperty,\n  ): N.ClassAccessorProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-Initializer\n  parseInitializer(\n    this: Parser,\n    node: Undone<\n      N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty\n    >,\n  ): void {\n    this.scope.enter(ScopeFlag.CLASS | ScopeFlag.SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(ParamKind.PARAM);\n    node.value = this.eat(tt.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(\n    node: Undone<N.Class>,\n    isStatement: boolean,\n    optionalId?: boolean | null,\n    bindingType: BindingTypes = BindingFlag.TYPE_CLASS,\n  ): void {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, { at: this.state.startLoc });\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassHeritage\n  parseClassSuper(this: Parser, node: Undone<N.Class>): void {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  // Parses module export declaration.\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n\n  parseExport(\n    this: Parser,\n    node: Undone<\n      | N.ExportDefaultDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportNamedDeclaration\n    >,\n    decorators: N.Decorator[] | null,\n  ): N.AnyExport {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(\n      node,\n      /* isExport */ true,\n    );\n    const hasDefault = this.maybeParseExportDefaultSpecifier(\n      node,\n      maybeDefaultIdentifier,\n    );\n    const parseAfterDefault = !hasDefault || this.eat(tt.comma);\n    const hasStar =\n      parseAfterDefault &&\n      this.eatExportStar(\n        // @ts-expect-error todo(flow->ts)\n        node,\n      );\n    const hasNamespace =\n      hasStar &&\n      this.maybeParseExportNamespaceSpecifier(\n        // @ts-expect-error todo(flow->ts)\n        node,\n      );\n    const parseAfterNamespace =\n      parseAfterDefault && (!hasNamespace || this.eat(tt.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      this.parseExportFrom(node as Undone<N.ExportNamedDeclaration>, true);\n\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, tt.braceL);\n    }\n\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, tt._from);\n    }\n\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      this.parseExportFrom(\n        node as Undone<N.ExportNamedDeclaration>,\n        isFromRequired,\n      );\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(\n        node as Undone<N.ExportNamedDeclaration>,\n      );\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      const node2 = node as Undone<N.ExportNamedDeclaration>;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (node2.declaration?.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      const node2 = node as Undone<N.ExportDefaultDeclaration>;\n      // export default ...\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl as N.ClassDeclaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n\n      this.checkExport(node2, true, true);\n\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n\n    this.unexpected(null, tt.braceL);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  eatExportStar(node: N.Node): boolean {\n    return this.eat(tt.star);\n  }\n\n  maybeParseExportDefaultSpecifier(\n    node: Undone<\n      | N.ExportDefaultDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportNamedDeclaration\n    >,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): node is Undone<N.ExportNamedDeclaration> {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      // export defaultObj ...\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier?.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode<N.ExportDefaultSpecifier>(id);\n      specifier.exported = id;\n      (node as Undone<N.ExportNamedDeclaration>).specifiers = [\n        this.finishNode(specifier, \"ExportDefaultSpecifier\"),\n      ];\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n    if (this.isContextual(tt._as)) {\n      if (!node.specifiers) node.specifiers = [];\n\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n\n      this.next();\n\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(\n        this.finishNode(specifier, \"ExportNamespaceSpecifier\"),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node: N.Node): boolean {\n    if (this.match(tt.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportDeclaration(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n  ): boolean {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n\n  isAsyncFunction(): boolean {\n    if (!this.isContextual(tt._async)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression(this: Parser): N.Expression | N.Declaration {\n    const expr = this.startNode();\n\n    if (this.match(tt._function)) {\n      this.next();\n      return this.parseFunction(\n        expr as Undone<N.FunctionDeclaration>,\n        ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId,\n      );\n    } else if (this.isAsyncFunction()) {\n      this.next(); // eat 'async'\n      this.next(); // eat 'function'\n      return this.parseFunction(\n        expr as Undone<N.FunctionDeclaration>,\n        ParseFunctionFlag.Declaration |\n          ParseFunctionFlag.NullableId |\n          ParseFunctionFlag.Async,\n      );\n    }\n\n    if (this.match(tt._class)) {\n      return this.parseClass(expr as Undone<N.ClassExpression>, true, true);\n    }\n\n    if (this.match(tt.at)) {\n      if (\n        this.hasPlugin(\"decorators\") &&\n        this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true\n      ) {\n        this.raise(Errors.DecoratorBeforeExport, { at: this.state.startLoc });\n      }\n      return this.parseClass(\n        this.maybeTakeDecorators(\n          this.parseDecorators(false),\n          this.startNode<N.ClassDeclaration>(),\n        ),\n        true,\n        true,\n      );\n    }\n\n    if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, {\n        at: this.state.startLoc,\n      });\n    }\n\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n  parseExportDeclaration(\n    this: Parser,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    node: Undone<N.ExportNamedDeclaration>,\n  ): N.Declaration | undefined | null {\n    if (this.match(tt._class)) {\n      const node = this.parseClass(\n        this.startNode<N.ClassDeclaration>(),\n        true,\n        false,\n      );\n      return node;\n    }\n    return this.parseStatementListItem() as N.Declaration;\n  }\n\n  isExportDefaultSpecifier(): boolean {\n    const { type } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if ((type === tt._async && !this.state.containsEsc) || type === tt._let) {\n        return false;\n      }\n      if (\n        (type === tt._type || type === tt._interface) &&\n        !this.state.containsEsc\n      ) {\n        const { type: nextType } = this.lookahead();\n        // If we see any variable name other than `from` after `type` keyword,\n        // we consider it as flow/typescript type exports\n        // note that this approach may fail on some pedantic cases\n        // export type from = number\n        if (\n          (tokenIsIdentifier(nextType) && nextType !== tt._from) ||\n          nextType === tt.braceL\n        ) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(tt._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (\n      this.input.charCodeAt(next) === charCodes.comma ||\n      (tokenIsIdentifier(this.state.type) && hasFrom)\n    ) {\n      return true;\n    }\n    // lookahead again when `export default from` is seen\n    if (this.match(tt._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(\n        this.nextTokenStartSince(next + 4),\n      );\n      return (\n        nextAfterFrom === charCodes.quotationMark ||\n        nextAfterFrom === charCodes.apostrophe\n      );\n    }\n    return false;\n  }\n\n  parseExportFrom(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n    expect?: boolean,\n  ): void {\n    if (this.eatContextual(tt._from)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration(): boolean {\n    const { type } = this.state;\n    if (type === tt.at) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (\n          this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true\n        ) {\n          this.raise(Errors.DecoratorBeforeExport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        return true;\n      }\n    }\n\n    return (\n      type === tt._var ||\n      type === tt._const ||\n      type === tt._function ||\n      type === tt._class ||\n      this.isLet() ||\n      this.isAsyncFunction()\n    );\n  }\n\n  checkExport(\n    node: Undone<N.ExportNamedDeclaration | N.ExportDefaultDeclaration>,\n    checkNames?: boolean,\n    isDefault?: boolean,\n    isFrom?: boolean,\n  ): void {\n    if (checkNames) {\n      // Check for duplicate exports\n      if (isDefault) {\n        // Default exports\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          const declaration = (node as any as N.ExportDefaultDeclaration)\n            .declaration;\n          if (\n            declaration.type === \"Identifier\" &&\n            declaration.name === \"from\" &&\n            declaration.end - declaration.start === 4 && // does not contain escape\n            !declaration.extra?.parenthesized\n          ) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, {\n              at: declaration,\n            });\n          }\n        }\n        // @ts-expect-error node.specifiers may not exist\n      } else if (node.specifiers?.length) {\n        // Named exports\n        // @ts-expect-error node.specifiers may not exist\n        for (const specifier of node.specifiers) {\n          const { exported } = specifier;\n          const exportName =\n            exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const { local } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, {\n                at: specifier,\n                localName: local.value,\n                exportName,\n              });\n            } else {\n              // check for keywords used as local names\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              // check if export is defined\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        // Exported declarations\n        if (\n          node.declaration.type === \"FunctionDeclaration\" ||\n          node.declaration.type === \"ClassDeclaration\"\n        ) {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n\n  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      // @ts-expect-error migrate to Babel types\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(\n    node: Undone<\n      | N.Identifier\n      | N.StringLiteral\n      | N.ExportNamedDeclaration\n      | N.ExportSpecifier\n      | N.ExportDefaultSpecifier\n    >,\n    exportName: string,\n  ): void {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, { at: node });\n      } else {\n        this.raise(Errors.DuplicateExport, { at: node, exportName });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n\n  // Parses a comma-separated list of module exports.\n\n  parseExportSpecifiers(isInTypeExport: boolean): Array<N.ExportSpecifier> {\n    const nodes = [];\n    let first = true;\n\n    // export { x, y as z } [from '...']\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      const isString = this.match(tt.string);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(\n        this.parseExportSpecifier(\n          node,\n          isString,\n          isInTypeExport,\n          isMaybeTypeOnly,\n        ),\n      );\n    }\n\n    return nodes;\n  }\n\n  parseExportSpecifier(\n    node: any,\n    isString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    isInTypeExport: boolean,\n    isMaybeTypeOnly: boolean,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ExportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleExportName\n  parseModuleExportName(): N.StringLiteral | N.Identifier {\n    if (this.match(tt.string)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {\n          at: result,\n          surrogateCharCode: surrogate[0].charCodeAt(0),\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n\n  isJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ): boolean {\n    if (node.assertions != null) {\n      return node.assertions.some(({ key, value }) => {\n        return (\n          value.value === \"json\" &&\n          (key.type === \"Identifier\"\n            ? key.name === \"type\"\n            : key.value === \"type\")\n        );\n      });\n    }\n    return false;\n  }\n\n  checkImportReflection(node: Undone<N.ImportDeclaration>) {\n    const { specifiers } = node;\n    const singleBindingType =\n      specifiers.length === 1 ? specifiers[0].type : null;\n\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, {\n          at: specifiers[0].loc.start,\n        });\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, {\n          at: specifiers[0].loc.start,\n        });\n      }\n    } else if (node.module) {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, {\n          at: specifiers[0].loc.start,\n        });\n      }\n      if (node.assertions?.length > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n    }\n  }\n\n  checkJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ) {\n    // @ts-expect-error Fixme: node.type must be undefined because they are undone\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      // @ts-expect-error specifiers may not index node\n      const { specifiers } = node;\n      if (specifiers != null) {\n        // @ts-expect-error refine specifier types\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\"\n              ? imported.name !== \"default\"\n              : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, {\n            at: nonDefaultNamedSpecifier.loc.start,\n          });\n        }\n      }\n    }\n  }\n\n  isPotentialImportPhase(isExport: boolean): boolean {\n    if (isExport) return false;\n    return (\n      this.isContextual(tt._source) ||\n      this.isContextual(tt._defer) ||\n      this.isContextual(tt._module)\n    );\n  }\n\n  applyImportPhase(\n    node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n    isExport: boolean,\n    phase: string | null,\n    loc?: Position,\n  ): void {\n    if (isExport) {\n      if (!process.env.IS_PUBLISH) {\n        if (phase === \"module\" || phase === \"source\") {\n          throw new Error(\n            `Assertion failure: export declarations do not support the '${phase}' phase.`,\n          );\n        }\n      }\n      return;\n    }\n\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      (node as N.ImportDeclaration).module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      (node as N.ImportDeclaration).module = false;\n    }\n\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      (node as N.ImportDeclaration).phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      (node as N.ImportDeclaration).phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      (node as N.ImportDeclaration).phase = null;\n    }\n  }\n\n  /*\n   * Parse `module` in `import module x from \"x\"`, disambiguating\n   * `import module from \"x\"` and `import module from from \"x\"`.\n   *\n   * This function might return an identifier representing the `module`\n   * if it eats `module` and then discovers that it was the default import\n   * binding and not the import reflection.\n   *\n   * This function is also used to parse `import type` and `import typeof`\n   * in the TS and Flow plugins.\n   *\n   * Note: the proposal has been updated to use `source` instead of `module`,\n   * but it has not been implemented yet.\n   */\n  parseMaybeImportPhase(\n    node: Undone<N.ImportDeclaration | N.TsImportEqualsDeclaration>,\n    isExport: boolean,\n  ): N.Identifier | null {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        null,\n      );\n      return null;\n    }\n\n    const phaseIdentifier = this.parseIdentifier(true);\n\n    const { type } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type)\n      ? // OK: import <phase> x from \"foo\";\n        // OK: import <phase> from from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // NO: import <phase> from 'foo';\n        // With the module declarations proposals, we will need further disambiguation\n        // for `import module from from;`.\n        type !== tt._from || this.lookaheadCharCode() === charCodes.lowercaseF\n      : // OK: import <phase> { x } from \"foo\";\n        // OK: import <phase> x from \"foo\";\n        // OK: import <phase> * as T from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // OK: import <phase> \"foo\";\n        // The last one is invalid, we will continue parsing and throw\n        // an error later\n        type !== tt.comma;\n\n    if (isImportPhase) {\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        phaseIdentifier.name,\n        phaseIdentifier.loc.start,\n      );\n      return null;\n    } else {\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        null,\n      );\n      // `<phase>` is a default binding, return it to the main import declaration parser\n      return phaseIdentifier;\n    }\n  }\n\n  isPrecedingIdImportPhase(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    phase: string,\n  ) {\n    const { type } = this.state;\n    return tokenIsIdentifier(type)\n      ? // OK: import <phase> x from \"foo\";\n        // OK: import <phase> from from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // NO: import <phase> from 'foo';\n        // With the module declarations proposals, we will need further disambiguation\n        // for `import module from from;`.\n        type !== tt._from || this.lookaheadCharCode() === charCodes.lowercaseF\n      : // OK: import <phase> { x } from \"foo\";\n        // OK: import <phase> x from \"foo\";\n        // OK: import <phase> * as T from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // OK: import <phase> \"foo\";\n        // The last one is invalid, we will continue parsing and throw\n        // an error later\n        type !== tt.comma;\n  }\n\n  // Parses import declaration.\n  // https://tc39.es/ecma262/#prod-ImportDeclaration\n\n  parseImport(this: Parser, node: Undone<N.ImportDeclaration>): N.AnyImport {\n    if (this.match(tt.string)) {\n      // import '...'\n      return this.parseImportSourceAndAttributes(node);\n    }\n\n    return this.parseImportSpecifiersAndAfter(\n      node,\n      this.parseMaybeImportPhase(node, /* isExport */ false),\n    );\n  }\n\n  parseImportSpecifiersAndAfter(\n    this: Parser,\n    node: Undone<N.ImportDeclaration>,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): N.AnyImport {\n    node.specifiers = [];\n\n    // check if we have a default import like\n    // import React from \"react\";\n    const hasDefault = this.maybeParseDefaultImportSpecifier(\n      node,\n      maybeDefaultIdentifier,\n    );\n    /* we are checking if we do not have a default import, then it is obvious that we need named imports\n     * import { get } from \"axios\";\n     * but if we do have a default import\n     * we need to check if we have a comma after that and\n     * that is where this `|| this.eat` condition comes into play\n     */\n    const parseNext = !hasDefault || this.eat(tt.comma);\n    // if we do have to parse the next set of specifiers, we first check for star imports\n    // import React, * from \"react\";\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    // now we check if we need to parse the next imports\n    // but only if they are not importing * (everything)\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(tt._from);\n\n    return this.parseImportSourceAndAttributes(node);\n  }\n\n  parseImportSourceAndAttributes(\n    this: Parser,\n    node: Undone<N.ImportDeclaration>,\n  ): N.AnyImport {\n    node.specifiers ??= [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource(this: Parser): N.StringLiteral {\n    if (!this.match(tt.string)) this.unexpected();\n    return this.parseExprAtom() as N.StringLiteral;\n  }\n\n  parseImportSpecifierLocal<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(\n    node: Undone<N.ImportDeclaration>,\n    specifier: Undone<T>,\n    type: T[\"type\"],\n  ): void {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  finishImportSpecifier<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(\n    specifier: Undone<T>,\n    type: T[\"type\"],\n    bindingType: BindingTypes = BindingFlag.TYPE_LEXICAL,\n  ) {\n    this.checkLVal(specifier.local, {\n      in: { type },\n      binding: bindingType,\n    });\n    return this.finishNode(specifier, type);\n  }\n\n  /**\n   * parse assert entries\n   *\n   * @see {@link https://tc39.es/proposal-import-attributes/#prod-WithEntries WithEntries}\n   */\n  parseImportAttributes(): N.ImportAttribute[] {\n    this.expect(tt.braceL);\n\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(tt.braceR)) {\n        break;\n      }\n\n      const node = this.startNode<N.ImportAttribute>();\n\n      // parse AssertionKey : IdentifierName, StringLiteral\n      const keyName = this.state.value;\n      // check if we already have an entry for an attribute\n      // if a duplicate entry is found, throw an error\n      // for now this logic will come into play only when someone declares `type` twice\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: this.state.startLoc,\n          key: keyName,\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(tt.string)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(tt.colon);\n\n      if (!this.match(tt.string)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc,\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(tt.comma));\n\n    this.expect(tt.braceR);\n\n    return attrs;\n  }\n\n  /**\n   * parse module attributes\n   * @deprecated It will be removed in Babel 8\n   */\n  parseModuleAttributes() {\n    const attrs: N.ImportAttribute[] = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode<N.ImportAttribute>();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, {\n          at: node.key,\n        });\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: node.key,\n          key: node.key.name,\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(tt.colon);\n      if (!this.match(tt.string)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc,\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAttributes(\n    node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n  ) {\n    let attributes: N.ImportAttribute[];\n    let useWith = false;\n\n    // https://tc39.es/proposal-import-attributes/#prod-WithClause\n    if (this.match(tt._with)) {\n      if (\n        this.hasPrecedingLineBreak() &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      ) {\n        // This will be parsed as a with statement, and we will throw a\n        // better error about it not being supported in strict mode.\n        return;\n      }\n\n      this.next(); // eat `with`\n\n      if (!process.env.BABEL_8_BREAKING) {\n        if (this.hasPlugin(\"moduleAttributes\")) {\n          attributes = this.parseModuleAttributes();\n        } else {\n          this.expectImportAttributesPlugin();\n          attributes = this.parseImportAttributes();\n        }\n      } else {\n        this.expectImportAttributesPlugin();\n        attributes = this.parseImportAttributes();\n      }\n      useWith = true;\n    } else if (this.isContextual(tt._assert) && !this.hasPrecedingLineBreak()) {\n      if (this.hasPlugin(\"importAttributes\")) {\n        if (\n          this.getPluginOption(\"importAttributes\", \"deprecatedAssertSyntax\") !==\n          true\n        ) {\n          this.raise(Errors.ImportAttributesUseAssert, {\n            at: this.state.startLoc,\n          });\n        }\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      } else {\n        this.expectOnePlugin([\"importAttributes\", \"importAssertions\"]);\n      }\n      this.next(); // eat `assert`\n      attributes = this.parseImportAttributes();\n    } else if (\n      this.hasPlugin(\"importAttributes\") ||\n      this.hasPlugin(\"importAssertions\")\n    ) {\n      attributes = [];\n    } else if (!process.env.BABEL_8_BREAKING) {\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = [];\n      } else return;\n    } else return;\n\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n\n  maybeParseDefaultImportSpecifier(\n    node: Undone<N.ImportDeclaration>,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): boolean {\n    // import defaultObj, { x, y as z } from '...'\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode<N.ImportDefaultSpecifier>(\n        maybeDefaultIdentifier,\n      );\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(\n        this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"),\n      );\n      return true;\n    } else if (\n      // We allow keywords, and parseImportSpecifierLocal will report a recoverable error\n      tokenIsKeywordOrIdentifier(this.state.type)\n    ) {\n      this.parseImportSpecifierLocal(\n        node,\n        this.startNode<N.ImportDefaultSpecifier>(),\n        \"ImportDefaultSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node: Undone<N.ImportDeclaration>): boolean {\n    if (this.match(tt.star)) {\n      const specifier = this.startNode<N.ImportNamespaceSpecifier>();\n      this.next();\n      this.expectContextual(tt._as);\n\n      this.parseImportSpecifierLocal(\n        node,\n        specifier,\n        \"ImportNamespaceSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node: Undone<N.ImportDeclaration>) {\n    let first = true;\n    this.expect(tt.braceL);\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        // Detect an attempt to deep destructure\n        if (this.eat(tt.colon)) {\n          throw this.raise(Errors.DestructureNamedImport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n\n      const specifier = this.startNode<N.ImportSpecifier>();\n      const importedIsString = this.match(tt.string);\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        node.importKind === \"type\" || node.importKind === \"typeof\",\n        isMaybeTypeOnly,\n        undefined,\n      );\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportSpecifier\n  parseImportSpecifier(\n    specifier: Undone<N.ImportSpecifier>,\n    importedIsString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript and Flow parser */\n    isInTypeOnlyImport: boolean,\n    isMaybeTypeOnly: boolean,\n    bindingType: BindingTypes | undefined,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ImportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const { imported } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, {\n          at: specifier,\n          importName: (imported as N.StringLiteral).value,\n        });\n      }\n      this.checkReservedWord(\n        (imported as N.Identifier).name,\n        specifier.loc.start,\n        true,\n        true,\n      );\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(\n      specifier,\n      \"ImportSpecifier\",\n      bindingType,\n    );\n  }\n\n  // This is used in flow and typescript plugin\n  // Determine whether a parameter is a this param\n  isThisParam(\n    param: N.Pattern | N.Identifier | N.TSParameterProperty,\n  ): boolean {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\n", "import type { Options } from \"../options.ts\";\nimport type * as N from \"../types.ts\";\nimport type { PluginList } from \"../plugin-utils.ts\";\nimport { getOptions } from \"../options.ts\";\nimport StatementParser from \"./statement.ts\";\nimport ScopeHandler from \"../util/scope.ts\";\n\nexport type PluginsMap = Map<\n  string,\n  {\n    [x: string]: any;\n  }\n>;\n\nexport default class Parser extends StatementParser {\n  // Forward-declaration so typescript plugin can override jsx plugin\n  // todo(flow->ts) - this probably can be removed\n  // abstract jsxParseOpeningElementAfterName(\n  //   node: N.JSXOpeningElement,\n  // ): N.JSXOpeningElement;\n\n  constructor(options: Options | undefined | null, input: string) {\n    options = getOptions(options);\n    super(options, input);\n\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  // This can be overwritten, for example, by the TypeScript plugin.\n  getScopeHandler(): {\n    new (...args: any): ScopeHandler;\n  } {\n    return ScopeHandler;\n  }\n\n  parse(): N.File {\n    this.enterInitialScopes();\n    const file = this.startNode() as N.File;\n    const program = this.startNode() as N.Program;\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n}\n\nfunction pluginsMap(plugins: PluginList): PluginsMap {\n  const pluginMap: PluginsMap = new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\n", "import type { Options } from \"./options.ts\";\nimport {\n  hasPlugin,\n  validatePlugins,\n  mixinPluginNames,\n  mixinPlugins,\n  type PluginList,\n} from \"./plugin-utils.ts\";\nimport type {\n  PluginConfig as ParserPlugin,\n  FlowPluginOptions,\n  RecordAndTuplePluginOptions,\n  PipelineOperatorPluginOptions,\n} from \"./typings.ts\";\nimport Parser from \"./parser/index.ts\";\n\nimport type { ExportedTokenType } from \"./tokenizer/types.ts\";\nimport {\n  getExportedToken,\n  tt as internalTokenTypes,\n  type InternalTokenTypes,\n} from \"./tokenizer/types.ts\";\n\nimport type { Expression, File } from \"./types.ts\";\n\nexport function parse(input: string, options?: Options): File {\n  if (options?.sourceType === \"unambiguous\") {\n    options = {\n      ...options,\n    };\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        // Top level await introduces code which can be both a valid script and\n        // a valid module, but which produces different ASTs:\n        //    await\n        //    0\n        // can be parsed either as an AwaitExpression, or as two ExpressionStatements.\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch {}\n      } else {\n        // This is both a valid module and a valid script, but\n        // we parse it as a script by default\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\n\nexport function parseExpression(input: string, options?: Options): Expression {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\n\nfunction generateExportedTokenTypes(\n  internalTokenTypes: InternalTokenTypes,\n): Record<string, ExportedTokenType> {\n  const tokenTypes: Record<string, ExportedTokenType> = {};\n  for (const typeName of Object.keys(\n    internalTokenTypes,\n  ) as (keyof InternalTokenTypes)[]) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\n\nexport const tokTypes = generateExportedTokenTypes(internalTokenTypes);\n\nfunction getParser(options: Options | undefined | null, input: string): Parser {\n  let cls = Parser;\n  if (options?.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache: { [key: string]: { new (...args: any): Parser } } = {};\n\n/** Get a Parser class with plugins applied. */\nfunction getParserClass(pluginsFromOptions: PluginList): {\n  new (...args: any): Parser;\n} {\n  const pluginList = mixinPluginNames.filter(name =>\n    hasPlugin(pluginsFromOptions, name),\n  );\n\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      // @ts-expect-error todo(flow->ts)\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\n\nexport type {\n  FlowPluginOptions,\n  ParserPlugin,\n  PipelineOperatorPluginOptions,\n  RecordAndTuplePluginOptions,\n};\nexport type ParserOptions = Partial<Options>;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nvar MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  var cache = [];\n\n  return function(input) {\n    for (var i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        var temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    var result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nvar normalize = lruMemoize(function normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  var parts = [];\n  var start = 0;\n  var i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   \u201Csources\u201D entry.  This value is prepended to the individual\n    //   entries in the \u201Csource\u201D field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   \u201CsourceRoot\u201D, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\nfunction SortTemplate(comparator) {\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot, false) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n  return doQuickSort;\n}\n\nfunction cloneSort(comparator) {\n  let template = SortTemplate.toString();\n  let templateFn = new Function(`return ${template}`)();\n  return templateFn(comparator);\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\n\nlet sortCache = new WeakMap();\nexports.quickSort = function (ary, comparator, start = 0) {\n  let doQuickSort = sortCache.get(comparator);\n  if (doQuickSort === void 0) {\n    doQuickSort = cloneSort(comparator);\n    sortCache.set(comparator, doQuickSort);\n  }\n  doQuickSort(ary, comparator, start, ary.length - 1);\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    var boundCallback = aCallback.bind(context);\n    var names = this._names;\n    var sources = this._sources;\n    var sourceMapURL = this._sourceMapURL;\n\n    for (var i = 0, n = mappings.length; i < n; i++) {\n      var mapping = mappings[i];\n      var source = mapping.source === null ? null : sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, sourceMapURL);\n      boundCallback({\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : names.at(mapping.name)\n      });\n    }\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\n\nconst compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;\nfunction sortGenerated(array, start) {\n  let l = array.length;\n  let n = array.length - start;\n  if (n <= 1) {\n    return;\n  } else if (n == 2) {\n    let a = array[start];\n    let b = array[start + 1];\n    if (compareGenerated(a, b) > 0) {\n      array[start] = b;\n      array[start + 1] = a;\n    }\n  } else if (n < 20) {\n    for (let i = start; i < l; i++) {\n      for (let j = i; j > start; j--) {\n        let a = array[j - 1];\n        let b = array[j];\n        if (compareGenerated(a, b) <= 0) {\n          break;\n        }\n        array[j - 1] = b;\n        array[j] = a;\n      }\n    }\n  } else {\n    quickSort(array, compareGenerated, start);\n  }\n}\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    let subarrayStart = 0;\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n\n        sortGenerated(generatedMappings, subarrayStart);\n        subarrayStart = generatedMappings.length;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = [];\n        while (index < end) {\n          base64VLQ.decode(aStr, index, temp);\n          value = temp.value;\n          index = temp.rest;\n          segment.push(value);\n        }\n\n        if (segment.length === 2) {\n          throw new Error('Found a source, but no line and column');\n        }\n\n        if (segment.length === 3) {\n          throw new Error('Found a source and line, but no column');\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          let currentSource = mapping.source;\n          while (originalMappings.length <= currentSource) {\n            originalMappings.push(null);\n          }\n          if (originalMappings[currentSource] === null) {\n            originalMappings[currentSource] = [];\n          }\n          originalMappings[currentSource].push(mapping);\n        }\n      }\n    }\n\n    sortGenerated(generatedMappings, subarrayStart);\n    this.__generatedMappings = generatedMappings;\n\n    for (var i = 0; i < originalMappings.length; i++) {\n      if (originalMappings[i] != null) {\n        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);\n      }\n    }\n    this.__originalMappings = [].concat(...originalMappings);\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n", "/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n", "(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = global || self, factory(global.estreeWalker = {}));\n}(this, (function (exports) { 'use strict';\n\n\t// @ts-check\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\n\t/** @typedef {{\n\t\tskip: () => void;\n\t\tremove: () => void;\n\t\treplace: (node: BaseNode) => void;\n\t}} WalkerContext */\n\n\tclass WalkerBase {\n\t\tconstructor() {\n\t\t\t/** @type {boolean} */\n\t\t\tthis.should_skip = false;\n\n\t\t\t/** @type {boolean} */\n\t\t\tthis.should_remove = false;\n\n\t\t\t/** @type {BaseNode | null} */\n\t\t\tthis.replacement = null;\n\n\t\t\t/** @type {WalkerContext} */\n\t\t\tthis.context = {\n\t\t\t\tskip: () => (this.should_skip = true),\n\t\t\t\tremove: () => (this.should_remove = true),\n\t\t\t\treplace: (node) => (this.replacement = node)\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {any} parent\n\t\t * @param {string} prop\n\t\t * @param {number} index\n\t\t * @param {BaseNode} node\n\t\t */\n\t\treplace(parent, prop, index, node) {\n\t\t\tif (parent) {\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tparent[prop][index] = node;\n\t\t\t\t} else {\n\t\t\t\t\tparent[prop] = node;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {any} parent\n\t\t * @param {string} prop\n\t\t * @param {number} index\n\t\t */\n\t\tremove(parent, prop, index) {\n\t\t\tif (parent) {\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tparent[prop].splice(index, 1);\n\t\t\t\t} else {\n\t\t\t\t\tdelete parent[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./walker.js').WalkerContext} WalkerContext */\n\n\t/** @typedef {(\n\t *    this: WalkerContext,\n\t *    node: BaseNode,\n\t *    parent: BaseNode,\n\t *    key: string,\n\t *    index: number\n\t * ) => void} SyncHandler */\n\n\tclass SyncWalker extends WalkerBase {\n\t\t/**\n\t\t *\n\t\t * @param {SyncHandler} enter\n\t\t * @param {SyncHandler} leave\n\t\t */\n\t\tconstructor(enter, leave) {\n\t\t\tsuper();\n\n\t\t\t/** @type {SyncHandler} */\n\t\t\tthis.enter = enter;\n\n\t\t\t/** @type {SyncHandler} */\n\t\t\tthis.leave = leave;\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {BaseNode} node\n\t\t * @param {BaseNode} parent\n\t\t * @param {string} [prop]\n\t\t * @param {number} [index]\n\t\t * @returns {BaseNode}\n\t\t */\n\t\tvisit(node, parent, prop, index) {\n\t\t\tif (node) {\n\t\t\t\tif (this.enter) {\n\t\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tthis.should_skip = false;\n\t\t\t\t\tthis.should_remove = false;\n\t\t\t\t\tthis.replacement = null;\n\n\t\t\t\t\tthis.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\t\tif (skipped) return node;\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\n\t\t\t\tfor (const key in node) {\n\t\t\t\t\tconst value = node[key];\n\n\t\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\t\tif (!this.visit(value[i], node, key, i)) {\n\t\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\t\tthis.visit(value, node, key, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.leave) {\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tthis.replacement = null;\n\t\t\t\t\tthis.should_remove = false;\n\n\t\t\t\t\tthis.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.replacement = _replacement;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./walker').WalkerContext} WalkerContext */\n\n\t/** @typedef {(\n\t *    this: WalkerContext,\n\t *    node: BaseNode,\n\t *    parent: BaseNode,\n\t *    key: string,\n\t *    index: number\n\t * ) => Promise<void>} AsyncHandler */\n\n\tclass AsyncWalker extends WalkerBase {\n\t\t/**\n\t\t *\n\t\t * @param {AsyncHandler} enter\n\t\t * @param {AsyncHandler} leave\n\t\t */\n\t\tconstructor(enter, leave) {\n\t\t\tsuper();\n\n\t\t\t/** @type {AsyncHandler} */\n\t\t\tthis.enter = enter;\n\n\t\t\t/** @type {AsyncHandler} */\n\t\t\tthis.leave = leave;\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {BaseNode} node\n\t\t * @param {BaseNode} parent\n\t\t * @param {string} [prop]\n\t\t * @param {number} [index]\n\t\t * @returns {Promise<BaseNode>}\n\t\t */\n\t\tasync visit(node, parent, prop, index) {\n\t\t\tif (node) {\n\t\t\t\tif (this.enter) {\n\t\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tthis.should_skip = false;\n\t\t\t\t\tthis.should_remove = false;\n\t\t\t\t\tthis.replacement = null;\n\n\t\t\t\t\tawait this.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\t\tif (skipped) return node;\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\n\t\t\t\tfor (const key in node) {\n\t\t\t\t\tconst value = node[key];\n\n\t\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\t\tif (!(await this.visit(value[i], node, key, i))) {\n\t\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\t\tawait this.visit(value, node, key, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.leave) {\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tthis.replacement = null;\n\t\t\t\t\tthis.should_remove = false;\n\n\t\t\t\t\tawait this.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.replacement = _replacement;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./sync.js').SyncHandler} SyncHandler */\n\t/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */\n\n\t/**\n\t *\n\t * @param {BaseNode} ast\n\t * @param {{\n\t *   enter?: SyncHandler\n\t *   leave?: SyncHandler\n\t * }} walker\n\t * @returns {BaseNode}\n\t */\n\tfunction walk(ast, { enter, leave }) {\n\t\tconst instance = new SyncWalker(enter, leave);\n\t\treturn instance.visit(ast, null);\n\t}\n\n\t/**\n\t *\n\t * @param {BaseNode} ast\n\t * @param {{\n\t *   enter?: AsyncHandler\n\t *   leave?: AsyncHandler\n\t * }} walker\n\t * @returns {Promise<BaseNode>}\n\t */\n\tasync function asyncWalk(ast, { enter, leave }) {\n\t\tconst instance = new AsyncWalker(enter, leave);\n\t\treturn await instance.visit(ast, null);\n\t}\n\n\texports.asyncWalk = asyncWalk;\n\texports.walk = walk;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar shared = require('@vue/shared');\nvar parser = require('@babel/parser');\nvar sourceMapJs = require('source-map-js');\nvar estreeWalker = require('estree-walker');\n\nfunction defaultOnError(error) {\n  throw error;\n}\nfunction defaultOnWarn(msg) {\n}\nfunction createCompilerError(code, loc, messages, additionalMessage) {\n  const msg = (messages || errorMessages)[code] + (additionalMessage || ``) ;\n  const error = new SyntaxError(String(msg));\n  error.code = code;\n  error.loc = loc;\n  return error;\n}\nconst errorMessages = {\n  // parse errors\n  [0]: \"Illegal comment.\",\n  [1]: \"CDATA section is allowed only in XML context.\",\n  [2]: \"Duplicate attribute.\",\n  [3]: \"End tag cannot have attributes.\",\n  [4]: \"Illegal '/' in tags.\",\n  [5]: \"Unexpected EOF in tag.\",\n  [6]: \"Unexpected EOF in CDATA section.\",\n  [7]: \"Unexpected EOF in comment.\",\n  [8]: \"Unexpected EOF in script.\",\n  [9]: \"Unexpected EOF in tag.\",\n  [10]: \"Incorrectly closed comment.\",\n  [11]: \"Incorrectly opened comment.\",\n  [12]: \"Illegal tag name. Use '&lt;' to print '<'.\",\n  [13]: \"Attribute value was expected.\",\n  [14]: \"End tag name was expected.\",\n  [15]: \"Whitespace was expected.\",\n  [16]: \"Unexpected '<!--' in comment.\",\n  [17]: `Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).`,\n  [18]: \"Unquoted attribute value cannot contain U+0022 (\\\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).\",\n  [19]: \"Attribute name cannot start with '='.\",\n  [21]: \"'<?' is allowed only in XML context.\",\n  [20]: `Unexpected null character.`,\n  [22]: \"Illegal '/' in tags.\",\n  // Vue-specific parse errors\n  [23]: \"Invalid end tag.\",\n  [24]: \"Element is missing end tag.\",\n  [25]: \"Interpolation end sign was not found.\",\n  [27]: \"End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.\",\n  [26]: \"Legal directive name was expected.\",\n  // transform errors\n  [28]: `v-if/v-else-if is missing expression.`,\n  [29]: `v-if/else branches must use unique keys.`,\n  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\n  [31]: `v-for is missing expression.`,\n  [32]: `v-for has invalid expression.`,\n  [33]: `<template v-for> key should be placed on the <template> tag.`,\n  [34]: `v-bind is missing expression.`,\n  [35]: `v-on is missing expression.`,\n  [36]: `Unexpected custom directive on <slot> outlet.`,\n  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,\n  [38]: `Duplicate slot names found. `,\n  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,\n  [40]: `v-slot can only be used on components or <template> tags.`,\n  [41]: `v-model is missing expression.`,\n  [42]: `v-model value must be a valid JavaScript member expression.`,\n  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,\n  [45]: `Error parsing JavaScript expression: `,\n  [46]: `<KeepAlive> expects exactly one child component.`,\n  // generic errors\n  [47]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n  [48]: `ES module mode is not supported in this build of compiler.`,\n  [49]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\n  [50]: `\"scopeId\" option is only supported in module mode.`,\n  // deprecations\n  [51]: `@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.`,\n  [52]: `v-is=\"component-name\" has been deprecated. Use is=\"vue:component-name\" instead. v-is support will be removed in 3.4.`,\n  // just to fulfill types\n  [53]: ``\n};\n\nconst FRAGMENT = Symbol(``);\nconst TELEPORT = Symbol(``);\nconst SUSPENSE = Symbol(``);\nconst KEEP_ALIVE = Symbol(``);\nconst BASE_TRANSITION = Symbol(``);\nconst OPEN_BLOCK = Symbol(``);\nconst CREATE_BLOCK = Symbol(``);\nconst CREATE_ELEMENT_BLOCK = Symbol(``);\nconst CREATE_VNODE = Symbol(``);\nconst CREATE_ELEMENT_VNODE = Symbol(``);\nconst CREATE_COMMENT = Symbol(``);\nconst CREATE_TEXT = Symbol(``);\nconst CREATE_STATIC = Symbol(``);\nconst RESOLVE_COMPONENT = Symbol(``);\nconst RESOLVE_DYNAMIC_COMPONENT = Symbol(\n  ``\n);\nconst RESOLVE_DIRECTIVE = Symbol(``);\nconst RESOLVE_FILTER = Symbol(``);\nconst WITH_DIRECTIVES = Symbol(``);\nconst RENDER_LIST = Symbol(``);\nconst RENDER_SLOT = Symbol(``);\nconst CREATE_SLOTS = Symbol(``);\nconst TO_DISPLAY_STRING = Symbol(``);\nconst MERGE_PROPS = Symbol(``);\nconst NORMALIZE_CLASS = Symbol(``);\nconst NORMALIZE_STYLE = Symbol(``);\nconst NORMALIZE_PROPS = Symbol(``);\nconst GUARD_REACTIVE_PROPS = Symbol(``);\nconst TO_HANDLERS = Symbol(``);\nconst CAMELIZE = Symbol(``);\nconst CAPITALIZE = Symbol(``);\nconst TO_HANDLER_KEY = Symbol(``);\nconst SET_BLOCK_TRACKING = Symbol(``);\nconst PUSH_SCOPE_ID = Symbol(``);\nconst POP_SCOPE_ID = Symbol(``);\nconst WITH_CTX = Symbol(``);\nconst UNREF = Symbol(``);\nconst IS_REF = Symbol(``);\nconst WITH_MEMO = Symbol(``);\nconst IS_MEMO_SAME = Symbol(``);\nconst helperNameMap = {\n  [FRAGMENT]: `Fragment`,\n  [TELEPORT]: `Teleport`,\n  [SUSPENSE]: `Suspense`,\n  [KEEP_ALIVE]: `KeepAlive`,\n  [BASE_TRANSITION]: `BaseTransition`,\n  [OPEN_BLOCK]: `openBlock`,\n  [CREATE_BLOCK]: `createBlock`,\n  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\n  [CREATE_VNODE]: `createVNode`,\n  [CREATE_ELEMENT_VNODE]: `createElementVNode`,\n  [CREATE_COMMENT]: `createCommentVNode`,\n  [CREATE_TEXT]: `createTextVNode`,\n  [CREATE_STATIC]: `createStaticVNode`,\n  [RESOLVE_COMPONENT]: `resolveComponent`,\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\n  [RESOLVE_FILTER]: `resolveFilter`,\n  [WITH_DIRECTIVES]: `withDirectives`,\n  [RENDER_LIST]: `renderList`,\n  [RENDER_SLOT]: `renderSlot`,\n  [CREATE_SLOTS]: `createSlots`,\n  [TO_DISPLAY_STRING]: `toDisplayString`,\n  [MERGE_PROPS]: `mergeProps`,\n  [NORMALIZE_CLASS]: `normalizeClass`,\n  [NORMALIZE_STYLE]: `normalizeStyle`,\n  [NORMALIZE_PROPS]: `normalizeProps`,\n  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\n  [TO_HANDLERS]: `toHandlers`,\n  [CAMELIZE]: `camelize`,\n  [CAPITALIZE]: `capitalize`,\n  [TO_HANDLER_KEY]: `toHandlerKey`,\n  [SET_BLOCK_TRACKING]: `setBlockTracking`,\n  [PUSH_SCOPE_ID]: `pushScopeId`,\n  [POP_SCOPE_ID]: `popScopeId`,\n  [WITH_CTX]: `withCtx`,\n  [UNREF]: `unref`,\n  [IS_REF]: `isRef`,\n  [WITH_MEMO]: `withMemo`,\n  [IS_MEMO_SAME]: `isMemoSame`\n};\nfunction registerRuntimeHelpers(helpers) {\n  Object.getOwnPropertySymbols(helpers).forEach((s) => {\n    helperNameMap[s] = helpers[s];\n  });\n}\n\nconst locStub = {\n  source: \"\",\n  start: { line: 1, column: 1, offset: 0 },\n  end: { line: 1, column: 1, offset: 0 }\n};\nfunction createRoot(children, loc = locStub) {\n  return {\n    type: 0,\n    children,\n    helpers: /* @__PURE__ */ new Set(),\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: 0,\n    temps: 0,\n    codegenNode: void 0,\n    loc\n  };\n}\nfunction createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {\n  if (context) {\n    if (isBlock) {\n      context.helper(OPEN_BLOCK);\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));\n    } else {\n      context.helper(getVNodeHelper(context.inSSR, isComponent));\n    }\n    if (directives) {\n      context.helper(WITH_DIRECTIVES);\n    }\n  }\n  return {\n    type: 13,\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent,\n    loc\n  };\n}\nfunction createArrayExpression(elements, loc = locStub) {\n  return {\n    type: 17,\n    loc,\n    elements\n  };\n}\nfunction createObjectExpression(properties, loc = locStub) {\n  return {\n    type: 15,\n    loc,\n    properties\n  };\n}\nfunction createObjectProperty(key, value) {\n  return {\n    type: 16,\n    loc: locStub,\n    key: shared.isString(key) ? createSimpleExpression(key, true) : key,\n    value\n  };\n}\nfunction createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {\n  return {\n    type: 4,\n    loc,\n    content,\n    isStatic,\n    constType: isStatic ? 3 : constType\n  };\n}\nfunction createInterpolation(content, loc) {\n  return {\n    type: 5,\n    loc,\n    content: shared.isString(content) ? createSimpleExpression(content, false, loc) : content\n  };\n}\nfunction createCompoundExpression(children, loc = locStub) {\n  return {\n    type: 8,\n    loc,\n    children\n  };\n}\nfunction createCallExpression(callee, args = [], loc = locStub) {\n  return {\n    type: 14,\n    loc,\n    callee,\n    arguments: args\n  };\n}\nfunction createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {\n  return {\n    type: 18,\n    params,\n    returns,\n    newline,\n    isSlot,\n    loc\n  };\n}\nfunction createConditionalExpression(test, consequent, alternate, newline = true) {\n  return {\n    type: 19,\n    test,\n    consequent,\n    alternate,\n    newline,\n    loc: locStub\n  };\n}\nfunction createCacheExpression(index, value, isVNode = false) {\n  return {\n    type: 20,\n    index,\n    value,\n    isVNode,\n    loc: locStub\n  };\n}\nfunction createBlockStatement(body) {\n  return {\n    type: 21,\n    body,\n    loc: locStub\n  };\n}\nfunction createTemplateLiteral(elements) {\n  return {\n    type: 22,\n    elements,\n    loc: locStub\n  };\n}\nfunction createIfStatement(test, consequent, alternate) {\n  return {\n    type: 23,\n    test,\n    consequent,\n    alternate,\n    loc: locStub\n  };\n}\nfunction createAssignmentExpression(left, right) {\n  return {\n    type: 24,\n    left,\n    right,\n    loc: locStub\n  };\n}\nfunction createSequenceExpression(expressions) {\n  return {\n    type: 25,\n    expressions,\n    loc: locStub\n  };\n}\nfunction createReturnStatement(returns) {\n  return {\n    type: 26,\n    returns,\n    loc: locStub\n  };\n}\nfunction getVNodeHelper(ssr, isComponent) {\n  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;\n}\nfunction getVNodeBlockHelper(ssr, isComponent) {\n  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;\n}\nfunction convertToBlock(node, { helper, removeHelper, inSSR }) {\n  if (!node.isBlock) {\n    node.isBlock = true;\n    removeHelper(getVNodeHelper(inSSR, node.isComponent));\n    helper(OPEN_BLOCK);\n    helper(getVNodeBlockHelper(inSSR, node.isComponent));\n  }\n}\n\nconst isStaticExp = (p) => p.type === 4 && p.isStatic;\nconst isBuiltInType = (tag, expected) => tag === expected || tag === shared.hyphenate(expected);\nfunction isCoreComponent(tag) {\n  if (isBuiltInType(tag, \"Teleport\")) {\n    return TELEPORT;\n  } else if (isBuiltInType(tag, \"Suspense\")) {\n    return SUSPENSE;\n  } else if (isBuiltInType(tag, \"KeepAlive\")) {\n    return KEEP_ALIVE;\n  } else if (isBuiltInType(tag, \"BaseTransition\")) {\n    return BASE_TRANSITION;\n  }\n}\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/;\nconst isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/;\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/;\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g;\nconst isMemberExpressionBrowser = (path) => {\n  path = path.trim().replace(whitespaceRE, (s) => s.trim());\n  let state = 0 /* inMemberExp */;\n  let stateStack = [];\n  let currentOpenBracketCount = 0;\n  let currentOpenParensCount = 0;\n  let currentStringType = null;\n  for (let i = 0; i < path.length; i++) {\n    const char = path.charAt(i);\n    switch (state) {\n      case 0 /* inMemberExp */:\n        if (char === \"[\") {\n          stateStack.push(state);\n          state = 1 /* inBrackets */;\n          currentOpenBracketCount++;\n        } else if (char === \"(\") {\n          stateStack.push(state);\n          state = 2 /* inParens */;\n          currentOpenParensCount++;\n        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {\n          return false;\n        }\n        break;\n      case 1 /* inBrackets */:\n        if (char === `'` || char === `\"` || char === \"`\") {\n          stateStack.push(state);\n          state = 3 /* inString */;\n          currentStringType = char;\n        } else if (char === `[`) {\n          currentOpenBracketCount++;\n        } else if (char === `]`) {\n          if (!--currentOpenBracketCount) {\n            state = stateStack.pop();\n          }\n        }\n        break;\n      case 2 /* inParens */:\n        if (char === `'` || char === `\"` || char === \"`\") {\n          stateStack.push(state);\n          state = 3 /* inString */;\n          currentStringType = char;\n        } else if (char === `(`) {\n          currentOpenParensCount++;\n        } else if (char === `)`) {\n          if (i === path.length - 1) {\n            return false;\n          }\n          if (!--currentOpenParensCount) {\n            state = stateStack.pop();\n          }\n        }\n        break;\n      case 3 /* inString */:\n        if (char === currentStringType) {\n          state = stateStack.pop();\n          currentStringType = null;\n        }\n        break;\n    }\n  }\n  return !currentOpenBracketCount && !currentOpenParensCount;\n};\nconst isMemberExpressionNode = (path, context) => {\n  try {\n    let ret = parser.parseExpression(path, {\n      plugins: context.expressionPlugins\n    });\n    if (ret.type === \"TSAsExpression\" || ret.type === \"TSTypeAssertion\") {\n      ret = ret.expression;\n    }\n    return ret.type === \"MemberExpression\" || ret.type === \"OptionalMemberExpression\" || ret.type === \"Identifier\";\n  } catch (e) {\n    return false;\n  }\n};\nconst isMemberExpression = isMemberExpressionNode;\nfunction getInnerRange(loc, offset, length) {\n  const source = loc.source.slice(offset, offset + length);\n  const newLoc = {\n    source,\n    start: advancePositionWithClone(loc.start, loc.source, offset),\n    end: loc.end\n  };\n  if (length != null) {\n    newLoc.end = advancePositionWithClone(\n      loc.start,\n      loc.source,\n      offset + length\n    );\n  }\n  return newLoc;\n}\nfunction advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\n  return advancePositionWithMutation(\n    shared.extend({}, pos),\n    source,\n    numberOfCharacters\n  );\n}\nfunction advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\n  let linesCount = 0;\n  let lastNewLinePos = -1;\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10) {\n      linesCount++;\n      lastNewLinePos = i;\n    }\n  }\n  pos.offset += numberOfCharacters;\n  pos.line += linesCount;\n  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;\n  return pos;\n}\nfunction assert(condition, msg) {\n  if (!condition) {\n    throw new Error(msg || `unexpected compiler condition`);\n  }\n}\nfunction findDir(node, name, allowEmpty = false) {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 7 && (allowEmpty || p.exp) && (shared.isString(name) ? p.name === name : name.test(p.name))) {\n      return p;\n    }\n  }\n}\nfunction findProp(node, name, dynamicOnly = false, allowEmpty = false) {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 6) {\n      if (dynamicOnly)\n        continue;\n      if (p.name === name && (p.value || allowEmpty)) {\n        return p;\n      }\n    } else if (p.name === \"bind\" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {\n      return p;\n    }\n  }\n}\nfunction isStaticArgOf(arg, name) {\n  return !!(arg && isStaticExp(arg) && arg.content === name);\n}\nfunction hasDynamicKeyVBind(node) {\n  return node.props.some(\n    (p) => p.type === 7 && p.name === \"bind\" && (!p.arg || // v-bind=\"obj\"\n    p.arg.type !== 4 || // v-bind:[_ctx.foo]\n    !p.arg.isStatic)\n    // v-bind:[foo]\n  );\n}\nfunction isText$1(node) {\n  return node.type === 5 || node.type === 2;\n}\nfunction isVSlot(p) {\n  return p.type === 7 && p.name === \"slot\";\n}\nfunction isTemplateNode(node) {\n  return node.type === 1 && node.tagType === 3;\n}\nfunction isSlotOutlet(node) {\n  return node.type === 1 && node.tagType === 2;\n}\nconst propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);\nfunction getUnnormalizedProps(props, callPath = []) {\n  if (props && !shared.isString(props) && props.type === 14) {\n    const callee = props.callee;\n    if (!shared.isString(callee) && propsHelperSet.has(callee)) {\n      return getUnnormalizedProps(\n        props.arguments[0],\n        callPath.concat(props)\n      );\n    }\n  }\n  return [props, callPath];\n}\nfunction injectProp(node, prop, context) {\n  let propsWithInjection;\n  let props = node.type === 13 ? node.props : node.arguments[2];\n  let callPath = [];\n  let parentCall;\n  if (props && !shared.isString(props) && props.type === 14) {\n    const ret = getUnnormalizedProps(props);\n    props = ret[0];\n    callPath = ret[1];\n    parentCall = callPath[callPath.length - 1];\n  }\n  if (props == null || shared.isString(props)) {\n    propsWithInjection = createObjectExpression([prop]);\n  } else if (props.type === 14) {\n    const first = props.arguments[0];\n    if (!shared.isString(first) && first.type === 15) {\n      if (!hasProp(prop, first)) {\n        first.properties.unshift(prop);\n      }\n    } else {\n      if (props.callee === TO_HANDLERS) {\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n          createObjectExpression([prop]),\n          props\n        ]);\n      } else {\n        props.arguments.unshift(createObjectExpression([prop]));\n      }\n    }\n    !propsWithInjection && (propsWithInjection = props);\n  } else if (props.type === 15) {\n    if (!hasProp(prop, props)) {\n      props.properties.unshift(prop);\n    }\n    propsWithInjection = props;\n  } else {\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n      createObjectExpression([prop]),\n      props\n    ]);\n    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\n      parentCall = callPath[callPath.length - 2];\n    }\n  }\n  if (node.type === 13) {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection;\n    } else {\n      node.props = propsWithInjection;\n    }\n  } else {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection;\n    } else {\n      node.arguments[2] = propsWithInjection;\n    }\n  }\n}\nfunction hasProp(prop, props) {\n  let result = false;\n  if (prop.key.type === 4) {\n    const propKeyName = prop.key.content;\n    result = props.properties.some(\n      (p) => p.key.type === 4 && p.key.content === propKeyName\n    );\n  }\n  return result;\n}\nfunction toValidAssetId(name, type) {\n  return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\n    return searchValue === \"-\" ? \"_\" : name.charCodeAt(replaceValue).toString();\n  })}`;\n}\nfunction hasScopeRef(node, ids) {\n  if (!node || Object.keys(ids).length === 0) {\n    return false;\n  }\n  switch (node.type) {\n    case 1:\n      for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i];\n        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {\n          return true;\n        }\n      }\n      return node.children.some((c) => hasScopeRef(c, ids));\n    case 11:\n      if (hasScopeRef(node.source, ids)) {\n        return true;\n      }\n      return node.children.some((c) => hasScopeRef(c, ids));\n    case 9:\n      return node.branches.some((b) => hasScopeRef(b, ids));\n    case 10:\n      if (hasScopeRef(node.condition, ids)) {\n        return true;\n      }\n      return node.children.some((c) => hasScopeRef(c, ids));\n    case 4:\n      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];\n    case 8:\n      return node.children.some((c) => shared.isObject(c) && hasScopeRef(c, ids));\n    case 5:\n    case 12:\n      return hasScopeRef(node.content, ids);\n    case 2:\n    case 3:\n      return false;\n    default:\n      return false;\n  }\n}\nfunction getMemoedVNodeCall(node) {\n  if (node.type === 14 && node.callee === WITH_MEMO) {\n    return node.arguments[1].returns;\n  } else {\n    return node;\n  }\n}\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n\nconst deprecationData = {\n  [\"COMPILER_IS_ON_ELEMENT\"]: {\n    message: `Platform-native elements with \"is\" prop will no longer be treated as components in Vue 3 unless the \"is\" value is explicitly prefixed with \"vue:\".`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`\n  },\n  [\"COMPILER_V_BIND_SYNC\"]: {\n    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \\`v-bind:${key}.sync\\` should be changed to \\`v-model:${key}\\`.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\n  },\n  [\"COMPILER_V_BIND_PROP\"]: {\n    message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`\n  },\n  [\"COMPILER_V_BIND_OBJECT_ORDER\"]: {\n    message: `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`\n  },\n  [\"COMPILER_V_ON_NATIVE\"]: {\n    message: `.native modifier for v-on has been removed as is no longer necessary.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`\n  },\n  [\"COMPILER_V_IF_V_FOR_PRECEDENCE\"]: {\n    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`\n  },\n  [\"COMPILER_NATIVE_TEMPLATE\"]: {\n    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`\n  },\n  [\"COMPILER_INLINE_TEMPLATE\"]: {\n    message: `\"inline-template\" has been removed in Vue 3.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`\n  },\n  [\"COMPILER_FILTER\"]: {\n    message: `filters have been removed in Vue 3. The \"|\" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\n  }\n};\nfunction getCompatValue(key, context) {\n  const config = context.options ? context.options.compatConfig : context.compatConfig;\n  const value = config && config[key];\n  if (key === \"MODE\") {\n    return value || 3;\n  } else {\n    return value;\n  }\n}\nfunction isCompatEnabled(key, context) {\n  const mode = getCompatValue(\"MODE\", context);\n  const value = getCompatValue(key, context);\n  return mode === 3 ? value === true : value !== false;\n}\nfunction checkCompatEnabled(key, context, loc, ...args) {\n  const enabled = isCompatEnabled(key, context);\n  return enabled;\n}\nfunction warnDeprecation(key, context, loc, ...args) {\n  const val = getCompatValue(key, context);\n  if (val === \"suppress-warning\") {\n    return;\n  }\n  const { message, link } = deprecationData[key];\n  const msg = `(deprecation ${key}) ${typeof message === \"function\" ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;\n  const err = new SyntaxError(msg);\n  err.code = key;\n  if (loc)\n    err.loc = loc;\n  context.onWarn(err);\n}\n\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g;\nconst decodeMap = {\n  gt: \">\",\n  lt: \"<\",\n  amp: \"&\",\n  apos: \"'\",\n  quot: '\"'\n};\nconst defaultParserOptions = {\n  delimiters: [`{{`, `}}`],\n  getNamespace: () => 0,\n  getTextMode: () => 0,\n  isVoidTag: shared.NO,\n  isPreTag: shared.NO,\n  isCustomElement: shared.NO,\n  decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\n  onError: defaultOnError,\n  onWarn: defaultOnWarn,\n  comments: false\n};\nfunction baseParse(content, options = {}) {\n  const context = createParserContext(content, options);\n  const start = getCursor(context);\n  return createRoot(\n    parseChildren(context, 0, []),\n    getSelection(context, start)\n  );\n}\nfunction createParserContext(content, rawOptions) {\n  const options = shared.extend({}, defaultParserOptions);\n  let key;\n  for (key in rawOptions) {\n    options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];\n  }\n  return {\n    options,\n    column: 1,\n    line: 1,\n    offset: 0,\n    originalSource: content,\n    source: content,\n    inPre: false,\n    inVPre: false,\n    onWarn: options.onWarn\n  };\n}\nfunction parseChildren(context, mode, ancestors) {\n  const parent = last(ancestors);\n  const ns = parent ? parent.ns : 0;\n  const nodes = [];\n  while (!isEnd(context, mode, ancestors)) {\n    const s = context.source;\n    let node = void 0;\n    if (mode === 0 || mode === 1) {\n      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\n        node = parseInterpolation(context, mode);\n      } else if (mode === 0 && s[0] === \"<\") {\n        if (s.length === 1) {\n          emitError(context, 5, 1);\n        } else if (s[1] === \"!\") {\n          if (startsWith(s, \"<!--\")) {\n            node = parseComment(context);\n          } else if (startsWith(s, \"<!DOCTYPE\")) {\n            node = parseBogusComment(context);\n          } else if (startsWith(s, \"<![CDATA[\")) {\n            if (ns !== 0) {\n              node = parseCDATA(context, ancestors);\n            } else {\n              emitError(context, 1);\n              node = parseBogusComment(context);\n            }\n          } else {\n            emitError(context, 11);\n            node = parseBogusComment(context);\n          }\n        } else if (s[1] === \"/\") {\n          if (s.length === 2) {\n            emitError(context, 5, 2);\n          } else if (s[2] === \">\") {\n            emitError(context, 14, 2);\n            advanceBy(context, 3);\n            continue;\n          } else if (/[a-z]/i.test(s[2])) {\n            emitError(context, 23);\n            parseTag(context, 1 /* End */, parent);\n            continue;\n          } else {\n            emitError(\n              context,\n              12,\n              2\n            );\n            node = parseBogusComment(context);\n          }\n        } else if (/[a-z]/i.test(s[1])) {\n          node = parseElement(context, ancestors);\n          if (isCompatEnabled(\n            \"COMPILER_NATIVE_TEMPLATE\",\n            context\n          ) && node && node.tag === \"template\" && !node.props.some(\n            (p) => p.type === 7 && isSpecialTemplateDirective(p.name)\n          )) {\n            node = node.children;\n          }\n        } else if (s[1] === \"?\") {\n          emitError(\n            context,\n            21,\n            1\n          );\n          node = parseBogusComment(context);\n        } else {\n          emitError(context, 12, 1);\n        }\n      }\n    }\n    if (!node) {\n      node = parseText(context, mode);\n    }\n    if (shared.isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        pushNode(nodes, node[i]);\n      }\n    } else {\n      pushNode(nodes, node);\n    }\n  }\n  let removedWhitespace = false;\n  if (mode !== 2 && mode !== 1) {\n    const shouldCondense = context.options.whitespace !== \"preserve\";\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (node.type === 2) {\n        if (!context.inPre) {\n          if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\n            const prev = nodes[i - 1];\n            const next = nodes[i + 1];\n            if (!prev || !next || shouldCondense && (prev.type === 3 && next.type === 3 || prev.type === 3 && next.type === 1 || prev.type === 1 && next.type === 3 || prev.type === 1 && next.type === 1 && /[\\r\\n]/.test(node.content))) {\n              removedWhitespace = true;\n              nodes[i] = null;\n            } else {\n              node.content = \" \";\n            }\n          } else if (shouldCondense) {\n            node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, \" \");\n          }\n        } else {\n          node.content = node.content.replace(/\\r\\n/g, \"\\n\");\n        }\n      } else if (node.type === 3 && !context.options.comments) {\n        removedWhitespace = true;\n        nodes[i] = null;\n      }\n    }\n    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\n      const first = nodes[0];\n      if (first && first.type === 2) {\n        first.content = first.content.replace(/^\\r?\\n/, \"\");\n      }\n    }\n  }\n  return removedWhitespace ? nodes.filter(Boolean) : nodes;\n}\nfunction pushNode(nodes, node) {\n  if (node.type === 2) {\n    const prev = last(nodes);\n    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {\n      prev.content += node.content;\n      prev.loc.end = node.loc.end;\n      prev.loc.source += node.loc.source;\n      return;\n    }\n  }\n  nodes.push(node);\n}\nfunction parseCDATA(context, ancestors) {\n  advanceBy(context, 9);\n  const nodes = parseChildren(context, 3, ancestors);\n  if (context.source.length === 0) {\n    emitError(context, 6);\n  } else {\n    advanceBy(context, 3);\n  }\n  return nodes;\n}\nfunction parseComment(context) {\n  const start = getCursor(context);\n  let content;\n  const match = /--(\\!)?>/.exec(context.source);\n  if (!match) {\n    content = context.source.slice(4);\n    advanceBy(context, context.source.length);\n    emitError(context, 7);\n  } else {\n    if (match.index <= 3) {\n      emitError(context, 0);\n    }\n    if (match[1]) {\n      emitError(context, 10);\n    }\n    content = context.source.slice(4, match.index);\n    const s = context.source.slice(0, match.index);\n    let prevIndex = 1, nestedIndex = 0;\n    while ((nestedIndex = s.indexOf(\"<!--\", prevIndex)) !== -1) {\n      advanceBy(context, nestedIndex - prevIndex + 1);\n      if (nestedIndex + 4 < s.length) {\n        emitError(context, 16);\n      }\n      prevIndex = nestedIndex + 1;\n    }\n    advanceBy(context, match.index + match[0].length - prevIndex + 1);\n  }\n  return {\n    type: 3,\n    content,\n    loc: getSelection(context, start)\n  };\n}\nfunction parseBogusComment(context) {\n  const start = getCursor(context);\n  const contentStart = context.source[1] === \"?\" ? 1 : 2;\n  let content;\n  const closeIndex = context.source.indexOf(\">\");\n  if (closeIndex === -1) {\n    content = context.source.slice(contentStart);\n    advanceBy(context, context.source.length);\n  } else {\n    content = context.source.slice(contentStart, closeIndex);\n    advanceBy(context, closeIndex + 1);\n  }\n  return {\n    type: 3,\n    content,\n    loc: getSelection(context, start)\n  };\n}\nfunction parseElement(context, ancestors) {\n  const wasInPre = context.inPre;\n  const wasInVPre = context.inVPre;\n  const parent = last(ancestors);\n  const element = parseTag(context, 0 /* Start */, parent);\n  const isPreBoundary = context.inPre && !wasInPre;\n  const isVPreBoundary = context.inVPre && !wasInVPre;\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    if (isPreBoundary) {\n      context.inPre = false;\n    }\n    if (isVPreBoundary) {\n      context.inVPre = false;\n    }\n    return element;\n  }\n  ancestors.push(element);\n  const mode = context.options.getTextMode(element, parent);\n  const children = parseChildren(context, mode, ancestors);\n  ancestors.pop();\n  {\n    const inlineTemplateProp = element.props.find(\n      (p) => p.type === 6 && p.name === \"inline-template\"\n    );\n    if (inlineTemplateProp && checkCompatEnabled(\n      \"COMPILER_INLINE_TEMPLATE\",\n      context,\n      inlineTemplateProp.loc\n    )) {\n      const loc = getSelection(context, element.loc.end);\n      inlineTemplateProp.value = {\n        type: 2,\n        content: loc.source,\n        loc\n      };\n    }\n  }\n  element.children = children;\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, 1 /* End */, parent);\n  } else {\n    emitError(context, 24, 0, element.loc.start);\n    if (context.source.length === 0 && element.tag.toLowerCase() === \"script\") {\n      const first = children[0];\n      if (first && startsWith(first.loc.source, \"<!--\")) {\n        emitError(context, 8);\n      }\n    }\n  }\n  element.loc = getSelection(context, element.loc.start);\n  if (isPreBoundary) {\n    context.inPre = false;\n  }\n  if (isVPreBoundary) {\n    context.inVPre = false;\n  }\n  return element;\n}\nconst isSpecialTemplateDirective = /* @__PURE__ */ shared.makeMap(\n  `if,else,else-if,for,slot`\n);\nfunction parseTag(context, type, parent) {\n  const start = getCursor(context);\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\n  const tag = match[1];\n  const ns = context.options.getNamespace(tag, parent);\n  advanceBy(context, match[0].length);\n  advanceSpaces(context);\n  const cursor = getCursor(context);\n  const currentSource = context.source;\n  if (context.options.isPreTag(tag)) {\n    context.inPre = true;\n  }\n  let props = parseAttributes(context, type);\n  if (type === 0 /* Start */ && !context.inVPre && props.some((p) => p.type === 7 && p.name === \"pre\")) {\n    context.inVPre = true;\n    shared.extend(context, cursor);\n    context.source = currentSource;\n    props = parseAttributes(context, type).filter((p) => p.name !== \"v-pre\");\n  }\n  let isSelfClosing = false;\n  if (context.source.length === 0) {\n    emitError(context, 9);\n  } else {\n    isSelfClosing = startsWith(context.source, \"/>\");\n    if (type === 1 /* End */ && isSelfClosing) {\n      emitError(context, 4);\n    }\n    advanceBy(context, isSelfClosing ? 2 : 1);\n  }\n  if (type === 1 /* End */) {\n    return;\n  }\n  let tagType = 0;\n  if (!context.inVPre) {\n    if (tag === \"slot\") {\n      tagType = 2;\n    } else if (tag === \"template\") {\n      if (props.some(\n        (p) => p.type === 7 && isSpecialTemplateDirective(p.name)\n      )) {\n        tagType = 3;\n      }\n    } else if (isComponent(tag, props, context)) {\n      tagType = 1;\n    }\n  }\n  return {\n    type: 1,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: void 0\n    // to be created during transform phase\n  };\n}\nfunction isComponent(tag, props, context) {\n  const options = context.options;\n  if (options.isCustomElement(tag)) {\n    return false;\n  }\n  if (tag === \"component\" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {\n    return true;\n  }\n  for (let i = 0; i < props.length; i++) {\n    const p = props[i];\n    if (p.type === 6) {\n      if (p.name === \"is\" && p.value) {\n        if (p.value.content.startsWith(\"vue:\")) {\n          return true;\n        } else if (checkCompatEnabled(\n          \"COMPILER_IS_ON_ELEMENT\",\n          context,\n          p.loc\n        )) {\n          return true;\n        }\n      }\n    } else {\n      if (p.name === \"is\") {\n        return true;\n      } else if (\n        // :is on plain element - only treat as component in compat mode\n        p.name === \"bind\" && isStaticArgOf(p.arg, \"is\") && true && checkCompatEnabled(\n          \"COMPILER_IS_ON_ELEMENT\",\n          context,\n          p.loc\n        )\n      ) {\n        return true;\n      }\n    }\n  }\n}\nfunction parseAttributes(context, type) {\n  const props = [];\n  const attributeNames = /* @__PURE__ */ new Set();\n  while (context.source.length > 0 && !startsWith(context.source, \">\") && !startsWith(context.source, \"/>\")) {\n    if (startsWith(context.source, \"/\")) {\n      emitError(context, 22);\n      advanceBy(context, 1);\n      advanceSpaces(context);\n      continue;\n    }\n    if (type === 1 /* End */) {\n      emitError(context, 3);\n    }\n    const attr = parseAttribute(context, attributeNames);\n    if (attr.type === 6 && attr.value && attr.name === \"class\") {\n      attr.value.content = attr.value.content.replace(/\\s+/g, \" \").trim();\n    }\n    if (type === 0 /* Start */) {\n      props.push(attr);\n    }\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n      emitError(context, 15);\n    }\n    advanceSpaces(context);\n  }\n  return props;\n}\nfunction parseAttribute(context, nameSet) {\n  var _a;\n  const start = getCursor(context);\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\n  const name = match[0];\n  if (nameSet.has(name)) {\n    emitError(context, 2);\n  }\n  nameSet.add(name);\n  if (name[0] === \"=\") {\n    emitError(context, 19);\n  }\n  {\n    const pattern = /[\"'<]/g;\n    let m;\n    while (m = pattern.exec(name)) {\n      emitError(\n        context,\n        17,\n        m.index\n      );\n    }\n  }\n  advanceBy(context, name.length);\n  let value = void 0;\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n    advanceSpaces(context);\n    advanceBy(context, 1);\n    advanceSpaces(context);\n    value = parseAttributeValue(context);\n    if (!value) {\n      emitError(context, 13);\n    }\n  }\n  const loc = getSelection(context, start);\n  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\n    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(\n      name\n    );\n    let isPropShorthand = startsWith(name, \".\");\n    let dirName = match2[1] || (isPropShorthand || startsWith(name, \":\") ? \"bind\" : startsWith(name, \"@\") ? \"on\" : \"slot\");\n    let arg;\n    if (match2[2]) {\n      const isSlot = dirName === \"slot\";\n      const startOffset = name.lastIndexOf(\n        match2[2],\n        name.length - (((_a = match2[3]) == null ? void 0 : _a.length) || 0)\n      );\n      const loc2 = getSelection(\n        context,\n        getNewPosition(context, start, startOffset),\n        getNewPosition(\n          context,\n          start,\n          startOffset + match2[2].length + (isSlot && match2[3] || \"\").length\n        )\n      );\n      let content = match2[2];\n      let isStatic = true;\n      if (content.startsWith(\"[\")) {\n        isStatic = false;\n        if (!content.endsWith(\"]\")) {\n          emitError(\n            context,\n            27\n          );\n          content = content.slice(1);\n        } else {\n          content = content.slice(1, content.length - 1);\n        }\n      } else if (isSlot) {\n        content += match2[3] || \"\";\n      }\n      arg = {\n        type: 4,\n        content,\n        isStatic,\n        constType: isStatic ? 3 : 0,\n        loc: loc2\n      };\n    }\n    if (value && value.isQuoted) {\n      const valueLoc = value.loc;\n      valueLoc.start.offset++;\n      valueLoc.start.column++;\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\n      valueLoc.source = valueLoc.source.slice(1, -1);\n    }\n    const modifiers = match2[3] ? match2[3].slice(1).split(\".\") : [];\n    if (isPropShorthand)\n      modifiers.push(\"prop\");\n    if (dirName === \"bind\" && arg) {\n      if (modifiers.includes(\"sync\") && checkCompatEnabled(\n        \"COMPILER_V_BIND_SYNC\",\n        context,\n        loc,\n        arg.loc.source\n      )) {\n        dirName = \"model\";\n        modifiers.splice(modifiers.indexOf(\"sync\"), 1);\n      }\n    }\n    return {\n      type: 7,\n      name: dirName,\n      exp: value && {\n        type: 4,\n        content: value.content,\n        isStatic: false,\n        // Treat as non-constant by default. This can be potentially set to\n        // other values by `transformExpression` to make it eligible for hoisting.\n        constType: 0,\n        loc: value.loc\n      },\n      arg,\n      modifiers,\n      loc\n    };\n  }\n  if (!context.inVPre && startsWith(name, \"v-\")) {\n    emitError(context, 26);\n  }\n  return {\n    type: 6,\n    name,\n    value: value && {\n      type: 2,\n      content: value.content,\n      loc: value.loc\n    },\n    loc\n  };\n}\nfunction parseAttributeValue(context) {\n  const start = getCursor(context);\n  let content;\n  const quote = context.source[0];\n  const isQuoted = quote === `\"` || quote === `'`;\n  if (isQuoted) {\n    advanceBy(context, 1);\n    const endIndex = context.source.indexOf(quote);\n    if (endIndex === -1) {\n      content = parseTextData(\n        context,\n        context.source.length,\n        4\n      );\n    } else {\n      content = parseTextData(context, endIndex, 4);\n      advanceBy(context, 1);\n    }\n  } else {\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\n    if (!match) {\n      return void 0;\n    }\n    const unexpectedChars = /[\"'<=`]/g;\n    let m;\n    while (m = unexpectedChars.exec(match[0])) {\n      emitError(\n        context,\n        18,\n        m.index\n      );\n    }\n    content = parseTextData(context, match[0].length, 4);\n  }\n  return { content, isQuoted, loc: getSelection(context, start) };\n}\nfunction parseInterpolation(context, mode) {\n  const [open, close] = context.options.delimiters;\n  const closeIndex = context.source.indexOf(close, open.length);\n  if (closeIndex === -1) {\n    emitError(context, 25);\n    return void 0;\n  }\n  const start = getCursor(context);\n  advanceBy(context, open.length);\n  const innerStart = getCursor(context);\n  const innerEnd = getCursor(context);\n  const rawContentLength = closeIndex - open.length;\n  const rawContent = context.source.slice(0, rawContentLength);\n  const preTrimContent = parseTextData(context, rawContentLength, mode);\n  const content = preTrimContent.trim();\n  const startOffset = preTrimContent.indexOf(content);\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset);\n  }\n  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\n  advancePositionWithMutation(innerEnd, rawContent, endOffset);\n  advanceBy(context, close.length);\n  return {\n    type: 5,\n    content: {\n      type: 4,\n      isStatic: false,\n      // Set `isConstant` to false by default and will decide in transformExpression\n      constType: 0,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  };\n}\nfunction parseText(context, mode) {\n  const endTokens = mode === 3 ? [\"]]>\"] : [\"<\", context.options.delimiters[0]];\n  let endIndex = context.source.length;\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1);\n    if (index !== -1 && endIndex > index) {\n      endIndex = index;\n    }\n  }\n  const start = getCursor(context);\n  const content = parseTextData(context, endIndex, mode);\n  return {\n    type: 2,\n    content,\n    loc: getSelection(context, start)\n  };\n}\nfunction parseTextData(context, length, mode) {\n  const rawText = context.source.slice(0, length);\n  advanceBy(context, length);\n  if (mode === 2 || mode === 3 || !rawText.includes(\"&\")) {\n    return rawText;\n  } else {\n    return context.options.decodeEntities(\n      rawText,\n      mode === 4\n    );\n  }\n}\nfunction getCursor(context) {\n  const { column, line, offset } = context;\n  return { column, line, offset };\n}\nfunction getSelection(context, start, end) {\n  end = end || getCursor(context);\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  };\n}\nfunction last(xs) {\n  return xs[xs.length - 1];\n}\nfunction startsWith(source, searchString) {\n  return source.startsWith(searchString);\n}\nfunction advanceBy(context, numberOfCharacters) {\n  const { source } = context;\n  advancePositionWithMutation(context, source, numberOfCharacters);\n  context.source = source.slice(numberOfCharacters);\n}\nfunction advanceSpaces(context) {\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\n  if (match) {\n    advanceBy(context, match[0].length);\n  }\n}\nfunction getNewPosition(context, start, numberOfCharacters) {\n  return advancePositionWithClone(\n    start,\n    context.originalSource.slice(start.offset, numberOfCharacters),\n    numberOfCharacters\n  );\n}\nfunction emitError(context, code, offset, loc = getCursor(context)) {\n  if (offset) {\n    loc.offset += offset;\n    loc.column += offset;\n  }\n  context.options.onError(\n    createCompilerError(code, {\n      start: loc,\n      end: loc,\n      source: \"\"\n    })\n  );\n}\nfunction isEnd(context, mode, ancestors) {\n  const s = context.source;\n  switch (mode) {\n    case 0:\n      if (startsWith(s, \"</\")) {\n        for (let i = ancestors.length - 1; i >= 0; --i) {\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n            return true;\n          }\n        }\n      }\n      break;\n    case 1:\n    case 2: {\n      const parent = last(ancestors);\n      if (parent && startsWithEndTagOpen(s, parent.tag)) {\n        return true;\n      }\n      break;\n    }\n    case 3:\n      if (startsWith(s, \"]]>\")) {\n        return true;\n      }\n      break;\n  }\n  return !s;\n}\nfunction startsWithEndTagOpen(source, tag) {\n  return startsWith(source, \"</\") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || \">\");\n}\n\nfunction hoistStatic(root, context) {\n  walk(\n    root,\n    context,\n    // Root node is unfortunately non-hoistable due to potential parent\n    // fallthrough attributes.\n    isSingleElementRoot(root, root.children[0])\n  );\n}\nfunction isSingleElementRoot(root, child) {\n  const { children } = root;\n  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);\n}\nfunction walk(node, context, doNotHoistNode = false) {\n  const { children } = node;\n  const originalCount = children.length;\n  let hoistedCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (child.type === 1 && child.tagType === 0) {\n      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);\n      if (constantType > 0) {\n        if (constantType >= 2) {\n          child.codegenNode.patchFlag = -1 + (``);\n          child.codegenNode = context.hoist(child.codegenNode);\n          hoistedCount++;\n          continue;\n        }\n      } else {\n        const codegenNode = child.codegenNode;\n        if (codegenNode.type === 13) {\n          const flag = getPatchFlag(codegenNode);\n          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {\n            const props = getNodeProps(child);\n            if (props) {\n              codegenNode.props = context.hoist(props);\n            }\n          }\n          if (codegenNode.dynamicProps) {\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);\n          }\n        }\n      }\n    }\n    if (child.type === 1) {\n      const isComponent = child.tagType === 1;\n      if (isComponent) {\n        context.scopes.vSlot++;\n      }\n      walk(child, context);\n      if (isComponent) {\n        context.scopes.vSlot--;\n      }\n    } else if (child.type === 11) {\n      walk(child, context, child.children.length === 1);\n    } else if (child.type === 9) {\n      for (let i2 = 0; i2 < child.branches.length; i2++) {\n        walk(\n          child.branches[i2],\n          context,\n          child.branches[i2].children.length === 1\n        );\n      }\n    }\n  }\n  if (hoistedCount && context.transformHoist) {\n    context.transformHoist(children, context, node);\n  }\n  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && shared.isArray(node.codegenNode.children)) {\n    const hoisted = context.hoist(\n      createArrayExpression(node.codegenNode.children)\n    );\n    if (context.hmr) {\n      hoisted.content = `[...${hoisted.content}]`;\n    }\n    node.codegenNode.children = hoisted;\n  }\n}\nfunction getConstantType(node, context) {\n  const { constantCache } = context;\n  switch (node.type) {\n    case 1:\n      if (node.tagType !== 0) {\n        return 0;\n      }\n      const cached = constantCache.get(node);\n      if (cached !== void 0) {\n        return cached;\n      }\n      const codegenNode = node.codegenNode;\n      if (codegenNode.type !== 13) {\n        return 0;\n      }\n      if (codegenNode.isBlock && node.tag !== \"svg\" && node.tag !== \"foreignObject\") {\n        return 0;\n      }\n      const flag = getPatchFlag(codegenNode);\n      if (!flag) {\n        let returnType2 = 3;\n        const generatedPropsType = getGeneratedPropsConstantType(node, context);\n        if (generatedPropsType === 0) {\n          constantCache.set(node, 0);\n          return 0;\n        }\n        if (generatedPropsType < returnType2) {\n          returnType2 = generatedPropsType;\n        }\n        for (let i = 0; i < node.children.length; i++) {\n          const childType = getConstantType(node.children[i], context);\n          if (childType === 0) {\n            constantCache.set(node, 0);\n            return 0;\n          }\n          if (childType < returnType2) {\n            returnType2 = childType;\n          }\n        }\n        if (returnType2 > 1) {\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i];\n            if (p.type === 7 && p.name === \"bind\" && p.exp) {\n              const expType = getConstantType(p.exp, context);\n              if (expType === 0) {\n                constantCache.set(node, 0);\n                return 0;\n              }\n              if (expType < returnType2) {\n                returnType2 = expType;\n              }\n            }\n          }\n        }\n        if (codegenNode.isBlock) {\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i];\n            if (p.type === 7) {\n              constantCache.set(node, 0);\n              return 0;\n            }\n          }\n          context.removeHelper(OPEN_BLOCK);\n          context.removeHelper(\n            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)\n          );\n          codegenNode.isBlock = false;\n          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));\n        }\n        constantCache.set(node, returnType2);\n        return returnType2;\n      } else {\n        constantCache.set(node, 0);\n        return 0;\n      }\n    case 2:\n    case 3:\n      return 3;\n    case 9:\n    case 11:\n    case 10:\n      return 0;\n    case 5:\n    case 12:\n      return getConstantType(node.content, context);\n    case 4:\n      return node.constType;\n    case 8:\n      let returnType = 3;\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (shared.isString(child) || shared.isSymbol(child)) {\n          continue;\n        }\n        const childType = getConstantType(child, context);\n        if (childType === 0) {\n          return 0;\n        } else if (childType < returnType) {\n          returnType = childType;\n        }\n      }\n      return returnType;\n    default:\n      return 0;\n  }\n}\nconst allowHoistedHelperSet = /* @__PURE__ */ new Set([\n  NORMALIZE_CLASS,\n  NORMALIZE_STYLE,\n  NORMALIZE_PROPS,\n  GUARD_REACTIVE_PROPS\n]);\nfunction getConstantTypeOfHelperCall(value, context) {\n  if (value.type === 14 && !shared.isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {\n    const arg = value.arguments[0];\n    if (arg.type === 4) {\n      return getConstantType(arg, context);\n    } else if (arg.type === 14) {\n      return getConstantTypeOfHelperCall(arg, context);\n    }\n  }\n  return 0;\n}\nfunction getGeneratedPropsConstantType(node, context) {\n  let returnType = 3;\n  const props = getNodeProps(node);\n  if (props && props.type === 15) {\n    const { properties } = props;\n    for (let i = 0; i < properties.length; i++) {\n      const { key, value } = properties[i];\n      const keyType = getConstantType(key, context);\n      if (keyType === 0) {\n        return keyType;\n      }\n      if (keyType < returnType) {\n        returnType = keyType;\n      }\n      let valueType;\n      if (value.type === 4) {\n        valueType = getConstantType(value, context);\n      } else if (value.type === 14) {\n        valueType = getConstantTypeOfHelperCall(value, context);\n      } else {\n        valueType = 0;\n      }\n      if (valueType === 0) {\n        return valueType;\n      }\n      if (valueType < returnType) {\n        returnType = valueType;\n      }\n    }\n  }\n  return returnType;\n}\nfunction getNodeProps(node) {\n  const codegenNode = node.codegenNode;\n  if (codegenNode.type === 13) {\n    return codegenNode.props;\n  }\n}\nfunction getPatchFlag(node) {\n  const flag = node.patchFlag;\n  return flag ? parseInt(flag, 10) : void 0;\n}\n\nfunction createTransformContext(root, {\n  filename = \"\",\n  prefixIdentifiers = false,\n  hoistStatic: hoistStatic2 = false,\n  hmr = false,\n  cacheHandlers = false,\n  nodeTransforms = [],\n  directiveTransforms = {},\n  transformHoist = null,\n  isBuiltInComponent = shared.NOOP,\n  isCustomElement = shared.NOOP,\n  expressionPlugins = [],\n  scopeId = null,\n  slotted = true,\n  ssr = false,\n  inSSR = false,\n  ssrCssVars = ``,\n  bindingMetadata = shared.EMPTY_OBJ,\n  inline = false,\n  isTS = false,\n  onError = defaultOnError,\n  onWarn = defaultOnWarn,\n  compatConfig\n}) {\n  const nameMatch = filename.replace(/\\?.*$/, \"\").match(/([^/\\\\]+)\\.\\w+$/);\n  const context = {\n    // options\n    selfName: nameMatch && shared.capitalize(shared.camelize(nameMatch[1])),\n    prefixIdentifiers,\n    hoistStatic: hoistStatic2,\n    hmr,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    transformHoist,\n    isBuiltInComponent,\n    isCustomElement,\n    expressionPlugins,\n    scopeId,\n    slotted,\n    ssr,\n    inSSR,\n    ssrCssVars,\n    bindingMetadata,\n    inline,\n    isTS,\n    onError,\n    onWarn,\n    compatConfig,\n    // state\n    root,\n    helpers: /* @__PURE__ */ new Map(),\n    components: /* @__PURE__ */ new Set(),\n    directives: /* @__PURE__ */ new Set(),\n    hoists: [],\n    imports: [],\n    constantCache: /* @__PURE__ */ new WeakMap(),\n    temps: 0,\n    cached: 0,\n    identifiers: /* @__PURE__ */ Object.create(null),\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    parent: null,\n    currentNode: root,\n    childIndex: 0,\n    inVOnce: false,\n    // methods\n    helper(name) {\n      const count = context.helpers.get(name) || 0;\n      context.helpers.set(name, count + 1);\n      return name;\n    },\n    removeHelper(name) {\n      const count = context.helpers.get(name);\n      if (count) {\n        const currentCount = count - 1;\n        if (!currentCount) {\n          context.helpers.delete(name);\n        } else {\n          context.helpers.set(name, currentCount);\n        }\n      }\n    },\n    helperString(name) {\n      return `_${helperNameMap[context.helper(name)]}`;\n    },\n    replaceNode(node) {\n      context.parent.children[context.childIndex] = context.currentNode = node;\n    },\n    removeNode(node) {\n      const list = context.parent.children;\n      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;\n      if (!node || node === context.currentNode) {\n        context.currentNode = null;\n        context.onNodeRemoved();\n      } else {\n        if (context.childIndex > removalIndex) {\n          context.childIndex--;\n          context.onNodeRemoved();\n        }\n      }\n      context.parent.children.splice(removalIndex, 1);\n    },\n    onNodeRemoved: () => {\n    },\n    addIdentifiers(exp) {\n      {\n        if (shared.isString(exp)) {\n          addId(exp);\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(addId);\n        } else if (exp.type === 4) {\n          addId(exp.content);\n        }\n      }\n    },\n    removeIdentifiers(exp) {\n      {\n        if (shared.isString(exp)) {\n          removeId(exp);\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(removeId);\n        } else if (exp.type === 4) {\n          removeId(exp.content);\n        }\n      }\n    },\n    hoist(exp) {\n      if (shared.isString(exp))\n        exp = createSimpleExpression(exp);\n      context.hoists.push(exp);\n      const identifier = createSimpleExpression(\n        `_hoisted_${context.hoists.length}`,\n        false,\n        exp.loc,\n        2\n      );\n      identifier.hoisted = exp;\n      return identifier;\n    },\n    cache(exp, isVNode = false) {\n      return createCacheExpression(context.cached++, exp, isVNode);\n    }\n  };\n  {\n    context.filters = /* @__PURE__ */ new Set();\n  }\n  function addId(id) {\n    const { identifiers } = context;\n    if (identifiers[id] === void 0) {\n      identifiers[id] = 0;\n    }\n    identifiers[id]++;\n  }\n  function removeId(id) {\n    context.identifiers[id]--;\n  }\n  return context;\n}\nfunction transform(root, options) {\n  const context = createTransformContext(root, options);\n  traverseNode(root, context);\n  if (options.hoistStatic) {\n    hoistStatic(root, context);\n  }\n  if (!options.ssr) {\n    createRootCodegen(root, context);\n  }\n  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);\n  root.components = [...context.components];\n  root.directives = [...context.directives];\n  root.imports = context.imports;\n  root.hoists = context.hoists;\n  root.temps = context.temps;\n  root.cached = context.cached;\n  {\n    root.filters = [...context.filters];\n  }\n}\nfunction createRootCodegen(root, context) {\n  const { helper } = context;\n  const { children } = root;\n  if (children.length === 1) {\n    const child = children[0];\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\n      const codegenNode = child.codegenNode;\n      if (codegenNode.type === 13) {\n        convertToBlock(codegenNode, context);\n      }\n      root.codegenNode = codegenNode;\n    } else {\n      root.codegenNode = child;\n    }\n  } else if (children.length > 1) {\n    let patchFlag = 64;\n    shared.PatchFlagNames[64];\n    root.codegenNode = createVNodeCall(\n      context,\n      helper(FRAGMENT),\n      void 0,\n      root.children,\n      patchFlag + (``),\n      void 0,\n      void 0,\n      true,\n      void 0,\n      false\n      /* isComponent */\n    );\n  } else ;\n}\nfunction traverseChildren(parent, context) {\n  let i = 0;\n  const nodeRemoved = () => {\n    i--;\n  };\n  for (; i < parent.children.length; i++) {\n    const child = parent.children[i];\n    if (shared.isString(child))\n      continue;\n    context.parent = parent;\n    context.childIndex = i;\n    context.onNodeRemoved = nodeRemoved;\n    traverseNode(child, context);\n  }\n}\nfunction traverseNode(node, context) {\n  context.currentNode = node;\n  const { nodeTransforms } = context;\n  const exitFns = [];\n  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {\n    const onExit = nodeTransforms[i2](node, context);\n    if (onExit) {\n      if (shared.isArray(onExit)) {\n        exitFns.push(...onExit);\n      } else {\n        exitFns.push(onExit);\n      }\n    }\n    if (!context.currentNode) {\n      return;\n    } else {\n      node = context.currentNode;\n    }\n  }\n  switch (node.type) {\n    case 3:\n      if (!context.ssr) {\n        context.helper(CREATE_COMMENT);\n      }\n      break;\n    case 5:\n      if (!context.ssr) {\n        context.helper(TO_DISPLAY_STRING);\n      }\n      break;\n    case 9:\n      for (let i2 = 0; i2 < node.branches.length; i2++) {\n        traverseNode(node.branches[i2], context);\n      }\n      break;\n    case 10:\n    case 11:\n    case 1:\n    case 0:\n      traverseChildren(node, context);\n      break;\n  }\n  context.currentNode = node;\n  let i = exitFns.length;\n  while (i--) {\n    exitFns[i]();\n  }\n}\nfunction createStructuralDirectiveTransform(name, fn) {\n  const matches = shared.isString(name) ? (n) => n === name : (n) => name.test(n);\n  return (node, context) => {\n    if (node.type === 1) {\n      const { props } = node;\n      if (node.tagType === 3 && props.some(isVSlot)) {\n        return;\n      }\n      const exitFns = [];\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i];\n        if (prop.type === 7 && matches(prop.name)) {\n          props.splice(i, 1);\n          i--;\n          const onExit = fn(node, prop, context);\n          if (onExit)\n            exitFns.push(onExit);\n        }\n      }\n      return exitFns;\n    }\n  };\n}\n\nconst PURE_ANNOTATION = `/*#__PURE__*/`;\nconst aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\nfunction createCodegenContext(ast, {\n  mode = \"function\",\n  prefixIdentifiers = mode === \"module\",\n  sourceMap = false,\n  filename = `template.vue.html`,\n  scopeId = null,\n  optimizeImports = false,\n  runtimeGlobalName = `Vue`,\n  runtimeModuleName = `vue`,\n  ssrRuntimeModuleName = \"vue/server-renderer\",\n  ssr = false,\n  isTS = false,\n  inSSR = false\n}) {\n  const context = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    scopeId,\n    optimizeImports,\n    runtimeGlobalName,\n    runtimeModuleName,\n    ssrRuntimeModuleName,\n    ssr,\n    isTS,\n    inSSR,\n    source: ast.loc.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n    pure: false,\n    map: void 0,\n    helper(key) {\n      return `_${helperNameMap[key]}`;\n    },\n    push(code, node) {\n      context.code += code;\n      if (context.map) {\n        if (node) {\n          let name;\n          if (node.type === 4 && !node.isStatic) {\n            const content = node.content.replace(/^_ctx\\./, \"\");\n            if (content !== node.content && isSimpleIdentifier(content)) {\n              name = content;\n            }\n          }\n          addMapping(node.loc.start, name);\n        }\n        advancePositionWithMutation(context, code);\n        if (node && node.loc !== locStub) {\n          addMapping(node.loc.end);\n        }\n      }\n    },\n    indent() {\n      newline(++context.indentLevel);\n    },\n    deindent(withoutNewLine = false) {\n      if (withoutNewLine) {\n        --context.indentLevel;\n      } else {\n        newline(--context.indentLevel);\n      }\n    },\n    newline() {\n      newline(context.indentLevel);\n    }\n  };\n  function newline(n) {\n    context.push(\"\\n\" + `  `.repeat(n));\n  }\n  function addMapping(loc, name) {\n    context.map.addMapping({\n      name,\n      source: context.filename,\n      original: {\n        line: loc.line,\n        column: loc.column - 1\n        // source-map column is 0 based\n      },\n      generated: {\n        line: context.line,\n        column: context.column - 1\n      }\n    });\n  }\n  if (sourceMap) {\n    context.map = new sourceMapJs.SourceMapGenerator();\n    context.map.setSourceContent(filename, context.source);\n  }\n  return context;\n}\nfunction generate(ast, options = {}) {\n  const context = createCodegenContext(ast, options);\n  if (options.onContextCreated)\n    options.onContextCreated(context);\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context;\n  const helpers = Array.from(ast.helpers);\n  const hasHelpers = helpers.length > 0;\n  const useWithBlock = !prefixIdentifiers && mode !== \"module\";\n  const genScopeId = scopeId != null && mode === \"module\";\n  const isSetupInlined = !!options.inline;\n  const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;\n  if (mode === \"module\") {\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);\n  } else {\n    genFunctionPreamble(ast, preambleContext);\n  }\n  const functionName = ssr ? `ssrRender` : `render`;\n  const args = ssr ? [\"_ctx\", \"_push\", \"_parent\", \"_attrs\"] : [\"_ctx\", \"_cache\"];\n  if (options.bindingMetadata && !options.inline) {\n    args.push(\"$props\", \"$setup\", \"$data\", \"$options\");\n  }\n  const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(\",\") : args.join(\", \");\n  if (isSetupInlined) {\n    push(`(${signature}) => {`);\n  } else {\n    push(`function ${functionName}(${signature}) {`);\n  }\n  indent();\n  if (useWithBlock) {\n    push(`with (_ctx) {`);\n    indent();\n    if (hasHelpers) {\n      push(`const { ${helpers.map(aliasHelper).join(\", \")} } = _Vue`);\n      push(`\n`);\n      newline();\n    }\n  }\n  if (ast.components.length) {\n    genAssets(ast.components, \"component\", context);\n    if (ast.directives.length || ast.temps > 0) {\n      newline();\n    }\n  }\n  if (ast.directives.length) {\n    genAssets(ast.directives, \"directive\", context);\n    if (ast.temps > 0) {\n      newline();\n    }\n  }\n  if (ast.filters && ast.filters.length) {\n    newline();\n    genAssets(ast.filters, \"filter\", context);\n    newline();\n  }\n  if (ast.temps > 0) {\n    push(`let `);\n    for (let i = 0; i < ast.temps; i++) {\n      push(`${i > 0 ? `, ` : ``}_temp${i}`);\n    }\n  }\n  if (ast.components.length || ast.directives.length || ast.temps) {\n    push(`\n`);\n    newline();\n  }\n  if (!ssr) {\n    push(`return `);\n  }\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context);\n  } else {\n    push(`null`);\n  }\n  if (useWithBlock) {\n    deindent();\n    push(`}`);\n  }\n  deindent();\n  push(`}`);\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    // SourceMapGenerator does have toJSON() method but it's not in the types\n    map: context.map ? context.map.toJSON() : void 0\n  };\n}\nfunction genFunctionPreamble(ast, context) {\n  const {\n    ssr,\n    prefixIdentifiers,\n    push,\n    newline,\n    runtimeModuleName,\n    runtimeGlobalName,\n    ssrRuntimeModuleName\n  } = context;\n  const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;\n  const helpers = Array.from(ast.helpers);\n  if (helpers.length > 0) {\n    if (prefixIdentifiers) {\n      push(`const { ${helpers.map(aliasHelper).join(\", \")} } = ${VueBinding}\n`);\n    } else {\n      push(`const _Vue = ${VueBinding}\n`);\n      if (ast.hoists.length) {\n        const staticHelpers = [\n          CREATE_VNODE,\n          CREATE_ELEMENT_VNODE,\n          CREATE_COMMENT,\n          CREATE_TEXT,\n          CREATE_STATIC\n        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(\", \");\n        push(`const { ${staticHelpers} } = _Vue\n`);\n      }\n    }\n  }\n  if (ast.ssrHelpers && ast.ssrHelpers.length) {\n    push(\n      `const { ${ast.ssrHelpers.map(aliasHelper).join(\", \")} } = require(\"${ssrRuntimeModuleName}\")\n`\n    );\n  }\n  genHoists(ast.hoists, context);\n  newline();\n  push(`return `);\n}\nfunction genModulePreamble(ast, context, genScopeId, inline) {\n  const {\n    push,\n    newline,\n    optimizeImports,\n    runtimeModuleName,\n    ssrRuntimeModuleName\n  } = context;\n  if (genScopeId && ast.hoists.length) {\n    ast.helpers.add(PUSH_SCOPE_ID);\n    ast.helpers.add(POP_SCOPE_ID);\n  }\n  if (ast.helpers.size) {\n    const helpers = Array.from(ast.helpers);\n    if (optimizeImports) {\n      push(\n        `import { ${helpers.map((s) => helperNameMap[s]).join(\", \")} } from ${JSON.stringify(runtimeModuleName)}\n`\n      );\n      push(\n        `\n// Binding optimization for webpack code-split\nconst ${helpers.map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`).join(\", \")}\n`\n      );\n    } else {\n      push(\n        `import { ${helpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(\", \")} } from ${JSON.stringify(runtimeModuleName)}\n`\n      );\n    }\n  }\n  if (ast.ssrHelpers && ast.ssrHelpers.length) {\n    push(\n      `import { ${ast.ssrHelpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(\", \")} } from \"${ssrRuntimeModuleName}\"\n`\n    );\n  }\n  if (ast.imports.length) {\n    genImports(ast.imports, context);\n    newline();\n  }\n  genHoists(ast.hoists, context);\n  newline();\n  if (!inline) {\n    push(`export `);\n  }\n}\nfunction genAssets(assets, type, { helper, push, newline, isTS }) {\n  const resolver = helper(\n    type === \"filter\" ? RESOLVE_FILTER : type === \"component\" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE\n  );\n  for (let i = 0; i < assets.length; i++) {\n    let id = assets[i];\n    const maybeSelfReference = id.endsWith(\"__self\");\n    if (maybeSelfReference) {\n      id = id.slice(0, -6);\n    }\n    push(\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`\n    );\n    if (i < assets.length - 1) {\n      newline();\n    }\n  }\n}\nfunction genHoists(hoists, context) {\n  if (!hoists.length) {\n    return;\n  }\n  context.pure = true;\n  const { push, newline, helper, scopeId, mode } = context;\n  const genScopeId = scopeId != null && mode !== \"function\";\n  newline();\n  if (genScopeId) {\n    push(\n      `const _withScopeId = n => (${helper(\n        PUSH_SCOPE_ID\n      )}(\"${scopeId}\"),n=n(),${helper(POP_SCOPE_ID)}(),n)`\n    );\n    newline();\n  }\n  for (let i = 0; i < hoists.length; i++) {\n    const exp = hoists[i];\n    if (exp) {\n      const needScopeIdWrapper = genScopeId && exp.type === 13;\n      push(\n        `const _hoisted_${i + 1} = ${needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``}`\n      );\n      genNode(exp, context);\n      if (needScopeIdWrapper) {\n        push(`)`);\n      }\n      newline();\n    }\n  }\n  context.pure = false;\n}\nfunction genImports(importsOptions, context) {\n  if (!importsOptions.length) {\n    return;\n  }\n  importsOptions.forEach((imports) => {\n    context.push(`import `);\n    genNode(imports.exp, context);\n    context.push(` from '${imports.path}'`);\n    context.newline();\n  });\n}\nfunction isText(n) {\n  return shared.isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;\n}\nfunction genNodeListAsArray(nodes, context) {\n  const multilines = nodes.length > 3 || nodes.some((n) => shared.isArray(n) || !isText(n));\n  context.push(`[`);\n  multilines && context.indent();\n  genNodeList(nodes, context, multilines);\n  multilines && context.deindent();\n  context.push(`]`);\n}\nfunction genNodeList(nodes, context, multilines = false, comma = true) {\n  const { push, newline } = context;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (shared.isString(node)) {\n      push(node);\n    } else if (shared.isArray(node)) {\n      genNodeListAsArray(node, context);\n    } else {\n      genNode(node, context);\n    }\n    if (i < nodes.length - 1) {\n      if (multilines) {\n        comma && push(\",\");\n        newline();\n      } else {\n        comma && push(\", \");\n      }\n    }\n  }\n}\nfunction genNode(node, context) {\n  if (shared.isString(node)) {\n    context.push(node);\n    return;\n  }\n  if (shared.isSymbol(node)) {\n    context.push(context.helper(node));\n    return;\n  }\n  switch (node.type) {\n    case 1:\n    case 9:\n    case 11:\n      genNode(node.codegenNode, context);\n      break;\n    case 2:\n      genText(node, context);\n      break;\n    case 4:\n      genExpression(node, context);\n      break;\n    case 5:\n      genInterpolation(node, context);\n      break;\n    case 12:\n      genNode(node.codegenNode, context);\n      break;\n    case 8:\n      genCompoundExpression(node, context);\n      break;\n    case 3:\n      genComment(node, context);\n      break;\n    case 13:\n      genVNodeCall(node, context);\n      break;\n    case 14:\n      genCallExpression(node, context);\n      break;\n    case 15:\n      genObjectExpression(node, context);\n      break;\n    case 17:\n      genArrayExpression(node, context);\n      break;\n    case 18:\n      genFunctionExpression(node, context);\n      break;\n    case 19:\n      genConditionalExpression(node, context);\n      break;\n    case 20:\n      genCacheExpression(node, context);\n      break;\n    case 21:\n      genNodeList(node.body, context, true, false);\n      break;\n    case 22:\n      genTemplateLiteral(node, context);\n      break;\n    case 23:\n      genIfStatement(node, context);\n      break;\n    case 24:\n      genAssignmentExpression(node, context);\n      break;\n    case 25:\n      genSequenceExpression(node, context);\n      break;\n    case 26:\n      genReturnStatement(node, context);\n      break;\n  }\n}\nfunction genText(node, context) {\n  context.push(JSON.stringify(node.content), node);\n}\nfunction genExpression(node, context) {\n  const { content, isStatic } = node;\n  context.push(isStatic ? JSON.stringify(content) : content, node);\n}\nfunction genInterpolation(node, context) {\n  const { push, helper, pure } = context;\n  if (pure)\n    push(PURE_ANNOTATION);\n  push(`${helper(TO_DISPLAY_STRING)}(`);\n  genNode(node.content, context);\n  push(`)`);\n}\nfunction genCompoundExpression(node, context) {\n  for (let i = 0; i < node.children.length; i++) {\n    const child = node.children[i];\n    if (shared.isString(child)) {\n      context.push(child);\n    } else {\n      genNode(child, context);\n    }\n  }\n}\nfunction genExpressionAsPropertyKey(node, context) {\n  const { push } = context;\n  if (node.type === 8) {\n    push(`[`);\n    genCompoundExpression(node, context);\n    push(`]`);\n  } else if (node.isStatic) {\n    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);\n    push(text, node);\n  } else {\n    push(`[${node.content}]`, node);\n  }\n}\nfunction genComment(node, context) {\n  const { push, helper, pure } = context;\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);\n}\nfunction genVNodeCall(node, context) {\n  const { push, helper, pure } = context;\n  const {\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent\n  } = node;\n  if (directives) {\n    push(helper(WITH_DIRECTIVES) + `(`);\n  }\n  if (isBlock) {\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\n  }\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);\n  push(helper(callHelper) + `(`, node);\n  genNodeList(\n    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),\n    context\n  );\n  push(`)`);\n  if (isBlock) {\n    push(`)`);\n  }\n  if (directives) {\n    push(`, `);\n    genNode(directives, context);\n    push(`)`);\n  }\n}\nfunction genNullableArgs(args) {\n  let i = args.length;\n  while (i--) {\n    if (args[i] != null)\n      break;\n  }\n  return args.slice(0, i + 1).map((arg) => arg || `null`);\n}\nfunction genCallExpression(node, context) {\n  const { push, helper, pure } = context;\n  const callee = shared.isString(node.callee) ? node.callee : helper(node.callee);\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  push(callee + `(`, node);\n  genNodeList(node.arguments, context);\n  push(`)`);\n}\nfunction genObjectExpression(node, context) {\n  const { push, indent, deindent, newline } = context;\n  const { properties } = node;\n  if (!properties.length) {\n    push(`{}`, node);\n    return;\n  }\n  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);\n  push(multilines ? `{` : `{ `);\n  multilines && indent();\n  for (let i = 0; i < properties.length; i++) {\n    const { key, value } = properties[i];\n    genExpressionAsPropertyKey(key, context);\n    push(`: `);\n    genNode(value, context);\n    if (i < properties.length - 1) {\n      push(`,`);\n      newline();\n    }\n  }\n  multilines && deindent();\n  push(multilines ? `}` : ` }`);\n}\nfunction genArrayExpression(node, context) {\n  genNodeListAsArray(node.elements, context);\n}\nfunction genFunctionExpression(node, context) {\n  const { push, indent, deindent } = context;\n  const { params, returns, body, newline, isSlot } = node;\n  if (isSlot) {\n    push(`_${helperNameMap[WITH_CTX]}(`);\n  }\n  push(`(`, node);\n  if (shared.isArray(params)) {\n    genNodeList(params, context);\n  } else if (params) {\n    genNode(params, context);\n  }\n  push(`) => `);\n  if (newline || body) {\n    push(`{`);\n    indent();\n  }\n  if (returns) {\n    if (newline) {\n      push(`return `);\n    }\n    if (shared.isArray(returns)) {\n      genNodeListAsArray(returns, context);\n    } else {\n      genNode(returns, context);\n    }\n  } else if (body) {\n    genNode(body, context);\n  }\n  if (newline || body) {\n    deindent();\n    push(`}`);\n  }\n  if (isSlot) {\n    if (node.isNonScopedSlot) {\n      push(`, undefined, true`);\n    }\n    push(`)`);\n  }\n}\nfunction genConditionalExpression(node, context) {\n  const { test, consequent, alternate, newline: needNewline } = node;\n  const { push, indent, deindent, newline } = context;\n  if (test.type === 4) {\n    const needsParens = !isSimpleIdentifier(test.content);\n    needsParens && push(`(`);\n    genExpression(test, context);\n    needsParens && push(`)`);\n  } else {\n    push(`(`);\n    genNode(test, context);\n    push(`)`);\n  }\n  needNewline && indent();\n  context.indentLevel++;\n  needNewline || push(` `);\n  push(`? `);\n  genNode(consequent, context);\n  context.indentLevel--;\n  needNewline && newline();\n  needNewline || push(` `);\n  push(`: `);\n  const isNested = alternate.type === 19;\n  if (!isNested) {\n    context.indentLevel++;\n  }\n  genNode(alternate, context);\n  if (!isNested) {\n    context.indentLevel--;\n  }\n  needNewline && deindent(\n    true\n    /* without newline */\n  );\n}\nfunction genCacheExpression(node, context) {\n  const { push, helper, indent, deindent, newline } = context;\n  push(`_cache[${node.index}] || (`);\n  if (node.isVNode) {\n    indent();\n    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\n    newline();\n  }\n  push(`_cache[${node.index}] = `);\n  genNode(node.value, context);\n  if (node.isVNode) {\n    push(`,`);\n    newline();\n    push(`${helper(SET_BLOCK_TRACKING)}(1),`);\n    newline();\n    push(`_cache[${node.index}]`);\n    deindent();\n  }\n  push(`)`);\n}\nfunction genTemplateLiteral(node, context) {\n  const { push, indent, deindent } = context;\n  push(\"`\");\n  const l = node.elements.length;\n  const multilines = l > 3;\n  for (let i = 0; i < l; i++) {\n    const e = node.elements[i];\n    if (shared.isString(e)) {\n      push(e.replace(/(`|\\$|\\\\)/g, \"\\\\$1\"));\n    } else {\n      push(\"${\");\n      if (multilines)\n        indent();\n      genNode(e, context);\n      if (multilines)\n        deindent();\n      push(\"}\");\n    }\n  }\n  push(\"`\");\n}\nfunction genIfStatement(node, context) {\n  const { push, indent, deindent } = context;\n  const { test, consequent, alternate } = node;\n  push(`if (`);\n  genNode(test, context);\n  push(`) {`);\n  indent();\n  genNode(consequent, context);\n  deindent();\n  push(`}`);\n  if (alternate) {\n    push(` else `);\n    if (alternate.type === 23) {\n      genIfStatement(alternate, context);\n    } else {\n      push(`{`);\n      indent();\n      genNode(alternate, context);\n      deindent();\n      push(`}`);\n    }\n  }\n}\nfunction genAssignmentExpression(node, context) {\n  genNode(node.left, context);\n  context.push(` = `);\n  genNode(node.right, context);\n}\nfunction genSequenceExpression(node, context) {\n  context.push(`(`);\n  genNodeList(node.expressions, context);\n  context.push(`)`);\n}\nfunction genReturnStatement({ returns }, context) {\n  context.push(`return `);\n  if (shared.isArray(returns)) {\n    genNodeListAsArray(returns, context);\n  } else {\n    genNode(returns, context);\n  }\n}\n\nfunction walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {\n  const rootExp = root.type === \"Program\" && root.body[0].type === \"ExpressionStatement\" && root.body[0].expression;\n  estreeWalker.walk(root, {\n    enter(node, parent) {\n      parent && parentStack.push(parent);\n      if (parent && parent.type.startsWith(\"TS\") && !TS_NODE_TYPES.includes(parent.type)) {\n        return this.skip();\n      }\n      if (node.type === \"Identifier\") {\n        const isLocal = !!knownIds[node.name];\n        const isRefed = isReferencedIdentifier(node, parent, parentStack);\n        if (includeAll || isRefed && !isLocal) {\n          onIdentifier(node, parent, parentStack, isRefed, isLocal);\n        }\n      } else if (node.type === \"ObjectProperty\" && parent.type === \"ObjectPattern\") {\n        node.inPattern = true;\n      } else if (isFunctionType(node)) {\n        walkFunctionParams(node, (id) => markScopeIdentifier(node, id, knownIds));\n      } else if (node.type === \"BlockStatement\") {\n        walkBlockDeclarations(\n          node,\n          (id) => markScopeIdentifier(node, id, knownIds)\n        );\n      }\n    },\n    leave(node, parent) {\n      parent && parentStack.pop();\n      if (node !== rootExp && node.scopeIds) {\n        for (const id of node.scopeIds) {\n          knownIds[id]--;\n          if (knownIds[id] === 0) {\n            delete knownIds[id];\n          }\n        }\n      }\n    }\n  });\n}\nfunction isReferencedIdentifier(id, parent, parentStack) {\n  if (!parent) {\n    return true;\n  }\n  if (id.name === \"arguments\") {\n    return false;\n  }\n  if (isReferenced(id, parent)) {\n    return true;\n  }\n  switch (parent.type) {\n    case \"AssignmentExpression\":\n    case \"AssignmentPattern\":\n      return true;\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return isInDestructureAssignment(parent, parentStack);\n  }\n  return false;\n}\nfunction isInDestructureAssignment(parent, parentStack) {\n  if (parent && (parent.type === \"ObjectProperty\" || parent.type === \"ArrayPattern\")) {\n    let i = parentStack.length;\n    while (i--) {\n      const p = parentStack[i];\n      if (p.type === \"AssignmentExpression\") {\n        return true;\n      } else if (p.type !== \"ObjectProperty\" && !p.type.endsWith(\"Pattern\")) {\n        break;\n      }\n    }\n  }\n  return false;\n}\nfunction walkFunctionParams(node, onIdent) {\n  for (const p of node.params) {\n    for (const id of extractIdentifiers(p)) {\n      onIdent(id);\n    }\n  }\n}\nfunction walkBlockDeclarations(block, onIdent) {\n  for (const stmt of block.body) {\n    if (stmt.type === \"VariableDeclaration\") {\n      if (stmt.declare)\n        continue;\n      for (const decl of stmt.declarations) {\n        for (const id of extractIdentifiers(decl.id)) {\n          onIdent(id);\n        }\n      }\n    } else if (stmt.type === \"FunctionDeclaration\" || stmt.type === \"ClassDeclaration\") {\n      if (stmt.declare || !stmt.id)\n        continue;\n      onIdent(stmt.id);\n    } else if (stmt.type === \"ForOfStatement\" || stmt.type === \"ForInStatement\" || stmt.type === \"ForStatement\") {\n      const variable = stmt.type === \"ForStatement\" ? stmt.init : stmt.left;\n      if (variable && variable.type === \"VariableDeclaration\") {\n        for (const decl of variable.declarations) {\n          for (const id of extractIdentifiers(decl.id)) {\n            onIdent(id);\n          }\n        }\n      }\n    }\n  }\n}\nfunction extractIdentifiers(param, nodes = []) {\n  switch (param.type) {\n    case \"Identifier\":\n      nodes.push(param);\n      break;\n    case \"MemberExpression\":\n      let object = param;\n      while (object.type === \"MemberExpression\") {\n        object = object.object;\n      }\n      nodes.push(object);\n      break;\n    case \"ObjectPattern\":\n      for (const prop of param.properties) {\n        if (prop.type === \"RestElement\") {\n          extractIdentifiers(prop.argument, nodes);\n        } else {\n          extractIdentifiers(prop.value, nodes);\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      param.elements.forEach((element) => {\n        if (element)\n          extractIdentifiers(element, nodes);\n      });\n      break;\n    case \"RestElement\":\n      extractIdentifiers(param.argument, nodes);\n      break;\n    case \"AssignmentPattern\":\n      extractIdentifiers(param.left, nodes);\n      break;\n  }\n  return nodes;\n}\nfunction markScopeIdentifier(node, child, knownIds) {\n  const { name } = child;\n  if (node.scopeIds && node.scopeIds.has(name)) {\n    return;\n  }\n  if (name in knownIds) {\n    knownIds[name]++;\n  } else {\n    knownIds[name] = 1;\n  }\n  (node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);\n}\nconst isFunctionType = (node) => {\n  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);\n};\nconst isStaticProperty = (node) => node && (node.type === \"ObjectProperty\" || node.type === \"ObjectMethod\") && !node.computed;\nconst isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;\nfunction isReferenced(node, parent, grandparent) {\n  switch (parent.type) {\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n      return parent.object === node;\n    case \"JSXMemberExpression\":\n      return parent.object === node;\n    case \"VariableDeclarator\":\n      return parent.init === node;\n    case \"ArrowFunctionExpression\":\n      return parent.body === node;\n    case \"PrivateName\":\n      return false;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"ObjectMethod\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return false;\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return !grandparent || grandparent.type !== \"ObjectPattern\";\n    case \"ClassProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n    case \"ClassPrivateProperty\":\n      return parent.key !== node;\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.superClass === node;\n    case \"AssignmentExpression\":\n      return parent.right === node;\n    case \"AssignmentPattern\":\n      return parent.right === node;\n    case \"LabeledStatement\":\n      return false;\n    case \"CatchClause\":\n      return false;\n    case \"RestElement\":\n      return false;\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n      return false;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      return false;\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n    case \"ExportSpecifier\":\n      if (grandparent == null ? void 0 : grandparent.source) {\n        return false;\n      }\n      return parent.local === node;\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n    case \"ImportAttribute\":\n      return false;\n    case \"JSXAttribute\":\n      return false;\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n    case \"MetaProperty\":\n      return false;\n    case \"ObjectTypeProperty\":\n      return parent.key !== node;\n    case \"TSEnumMember\":\n      return parent.id !== node;\n    case \"TSPropertySignature\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n  }\n  return true;\n}\nconst TS_NODE_TYPES = [\n  \"TSAsExpression\",\n  // foo as number\n  \"TSTypeAssertion\",\n  // (<number>foo)\n  \"TSNonNullExpression\",\n  // foo!\n  \"TSInstantiationExpression\",\n  // foo<string>\n  \"TSSatisfiesExpression\"\n  // foo satisfies T\n];\n\nconst isLiteralWhitelisted = /* @__PURE__ */ shared.makeMap(\"true,false,null,this\");\nconst constantBailRE = /\\w\\s*\\(|\\.[^\\d]/;\nconst transformExpression = (node, context) => {\n  if (node.type === 5) {\n    node.content = processExpression(\n      node.content,\n      context\n    );\n  } else if (node.type === 1) {\n    for (let i = 0; i < node.props.length; i++) {\n      const dir = node.props[i];\n      if (dir.type === 7 && dir.name !== \"for\") {\n        const exp = dir.exp;\n        const arg = dir.arg;\n        if (exp && exp.type === 4 && !(dir.name === \"on\" && arg)) {\n          dir.exp = processExpression(\n            exp,\n            context,\n            // slot args must be processed as function params\n            dir.name === \"slot\"\n          );\n        }\n        if (arg && arg.type === 4 && !arg.isStatic) {\n          dir.arg = processExpression(arg, context);\n        }\n      }\n    }\n  }\n};\nfunction processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {\n  if (!context.prefixIdentifiers || !node.content.trim()) {\n    return node;\n  }\n  const { inline, bindingMetadata } = context;\n  const rewriteIdentifier = (raw, parent, id) => {\n    const type = shared.hasOwn(bindingMetadata, raw) && bindingMetadata[raw];\n    if (inline) {\n      const isAssignmentLVal = parent && parent.type === \"AssignmentExpression\" && parent.left === id;\n      const isUpdateArg = parent && parent.type === \"UpdateExpression\" && parent.argument === id;\n      const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);\n      if (isConst(type) || type === \"setup-reactive-const\" || localVars[raw]) {\n        return raw;\n      } else if (type === \"setup-ref\") {\n        return `${raw}.value`;\n      } else if (type === \"setup-maybe-ref\") {\n        return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : `${context.helperString(UNREF)}(${raw})`;\n      } else if (type === \"setup-let\") {\n        if (isAssignmentLVal) {\n          const { right: rVal, operator } = parent;\n          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);\n          const rExpString = stringifyExpression(\n            processExpression(\n              createSimpleExpression(rExp, false),\n              context,\n              false,\n              false,\n              knownIds\n            )\n          );\n          return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore\n` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;\n        } else if (isUpdateArg) {\n          id.start = parent.start;\n          id.end = parent.end;\n          const { prefix: isPrefix, operator } = parent;\n          const prefix = isPrefix ? operator : ``;\n          const postfix = isPrefix ? `` : operator;\n          return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore\n` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;\n        } else if (isDestructureAssignment) {\n          return raw;\n        } else {\n          return `${context.helperString(UNREF)}(${raw})`;\n        }\n      } else if (type === \"props\") {\n        return shared.genPropsAccessExp(raw);\n      } else if (type === \"props-aliased\") {\n        return shared.genPropsAccessExp(bindingMetadata.__propsAliases[raw]);\n      }\n    } else {\n      if (type && type.startsWith(\"setup\") || type === \"literal-const\") {\n        return `$setup.${raw}`;\n      } else if (type === \"props-aliased\") {\n        return `$props['${bindingMetadata.__propsAliases[raw]}']`;\n      } else if (type) {\n        return `$${type}.${raw}`;\n      }\n    }\n    return `_ctx.${raw}`;\n  };\n  const rawExp = node.content;\n  const bailConstant = constantBailRE.test(rawExp);\n  if (isSimpleIdentifier(rawExp)) {\n    const isScopeVarReference = context.identifiers[rawExp];\n    const isAllowedGlobal = shared.isGloballyAllowed(rawExp);\n    const isLiteral = isLiteralWhitelisted(rawExp);\n    if (!asParams && !isScopeVarReference && !isLiteral && (!isAllowedGlobal || bindingMetadata[rawExp])) {\n      if (isConst(bindingMetadata[rawExp])) {\n        node.constType = 1;\n      }\n      node.content = rewriteIdentifier(rawExp);\n    } else if (!isScopeVarReference) {\n      if (isLiteral) {\n        node.constType = 3;\n      } else {\n        node.constType = 2;\n      }\n    }\n    return node;\n  }\n  let ast;\n  const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;\n  try {\n    ast = parser.parse(source, {\n      plugins: context.expressionPlugins\n    }).program;\n  } catch (e) {\n    context.onError(\n      createCompilerError(\n        45,\n        node.loc,\n        void 0,\n        e.message\n      )\n    );\n    return node;\n  }\n  const ids = [];\n  const parentStack = [];\n  const knownIds = Object.create(context.identifiers);\n  walkIdentifiers(\n    ast,\n    (node2, parent, _, isReferenced, isLocal) => {\n      if (isStaticPropertyKey(node2, parent)) {\n        return;\n      }\n      if (node2.name.startsWith(\"_filter_\")) {\n        return;\n      }\n      const needPrefix = isReferenced && canPrefix(node2);\n      if (needPrefix && !isLocal) {\n        if (isStaticProperty(parent) && parent.shorthand) {\n          node2.prefix = `${node2.name}: `;\n        }\n        node2.name = rewriteIdentifier(node2.name, parent, node2);\n        ids.push(node2);\n      } else {\n        if (!(needPrefix && isLocal) && !bailConstant) {\n          node2.isConstant = true;\n        }\n        ids.push(node2);\n      }\n    },\n    true,\n    // invoke on ALL identifiers\n    parentStack,\n    knownIds\n  );\n  const children = [];\n  ids.sort((a, b) => a.start - b.start);\n  ids.forEach((id, i) => {\n    const start = id.start - 1;\n    const end = id.end - 1;\n    const last = ids[i - 1];\n    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);\n    if (leadingText.length || id.prefix) {\n      children.push(leadingText + (id.prefix || ``));\n    }\n    const source2 = rawExp.slice(start, end);\n    children.push(\n      createSimpleExpression(\n        id.name,\n        false,\n        {\n          source: source2,\n          start: advancePositionWithClone(node.loc.start, source2, start),\n          end: advancePositionWithClone(node.loc.start, source2, end)\n        },\n        id.isConstant ? 3 : 0\n      )\n    );\n    if (i === ids.length - 1 && end < rawExp.length) {\n      children.push(rawExp.slice(end));\n    }\n  });\n  let ret;\n  if (children.length) {\n    ret = createCompoundExpression(children, node.loc);\n  } else {\n    ret = node;\n    ret.constType = bailConstant ? 0 : 3;\n  }\n  ret.identifiers = Object.keys(knownIds);\n  return ret;\n}\nfunction canPrefix(id) {\n  if (shared.isGloballyAllowed(id.name)) {\n    return false;\n  }\n  if (id.name === \"require\") {\n    return false;\n  }\n  return true;\n}\nfunction stringifyExpression(exp) {\n  if (shared.isString(exp)) {\n    return exp;\n  } else if (exp.type === 4) {\n    return exp.content;\n  } else {\n    return exp.children.map(stringifyExpression).join(\"\");\n  }\n}\nfunction isConst(type) {\n  return type === \"setup-const\" || type === \"literal-const\";\n}\n\nconst transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) => {\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\n      const siblings = context.parent.children;\n      let i = siblings.indexOf(ifNode);\n      let key = 0;\n      while (i-- >= 0) {\n        const sibling = siblings[i];\n        if (sibling && sibling.type === 9) {\n          key += sibling.branches.length;\n        }\n      }\n      return () => {\n        if (isRoot) {\n          ifNode.codegenNode = createCodegenNodeForBranch(\n            branch,\n            key,\n            context\n          );\n        } else {\n          const parentCondition = getParentCondition(ifNode.codegenNode);\n          parentCondition.alternate = createCodegenNodeForBranch(\n            branch,\n            key + ifNode.branches.length - 1,\n            context\n          );\n        }\n      };\n    });\n  }\n);\nfunction processIf(node, dir, context, processCodegen) {\n  if (dir.name !== \"else\" && (!dir.exp || !dir.exp.content.trim())) {\n    const loc = dir.exp ? dir.exp.loc : node.loc;\n    context.onError(\n      createCompilerError(28, dir.loc)\n    );\n    dir.exp = createSimpleExpression(`true`, false, loc);\n  }\n  if (context.prefixIdentifiers && dir.exp) {\n    dir.exp = processExpression(dir.exp, context);\n  }\n  if (dir.name === \"if\") {\n    const branch = createIfBranch(node, dir);\n    const ifNode = {\n      type: 9,\n      loc: node.loc,\n      branches: [branch]\n    };\n    context.replaceNode(ifNode);\n    if (processCodegen) {\n      return processCodegen(ifNode, branch, true);\n    }\n  } else {\n    const siblings = context.parent.children;\n    let i = siblings.indexOf(node);\n    while (i-- >= -1) {\n      const sibling = siblings[i];\n      if (sibling && sibling.type === 3) {\n        context.removeNode(sibling);\n        continue;\n      }\n      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {\n        context.removeNode(sibling);\n        continue;\n      }\n      if (sibling && sibling.type === 9) {\n        if (dir.name === \"else-if\" && sibling.branches[sibling.branches.length - 1].condition === void 0) {\n          context.onError(\n            createCompilerError(30, node.loc)\n          );\n        }\n        context.removeNode();\n        const branch = createIfBranch(node, dir);\n        {\n          const key = branch.userKey;\n          if (key) {\n            sibling.branches.forEach(({ userKey }) => {\n              if (isSameKey(userKey, key)) {\n                context.onError(\n                  createCompilerError(\n                    29,\n                    branch.userKey.loc\n                  )\n                );\n              }\n            });\n          }\n        }\n        sibling.branches.push(branch);\n        const onExit = processCodegen && processCodegen(sibling, branch, false);\n        traverseNode(branch, context);\n        if (onExit)\n          onExit();\n        context.currentNode = null;\n      } else {\n        context.onError(\n          createCompilerError(30, node.loc)\n        );\n      }\n      break;\n    }\n  }\n}\nfunction createIfBranch(node, dir) {\n  const isTemplateIf = node.tagType === 3;\n  return {\n    type: 10,\n    loc: node.loc,\n    condition: dir.name === \"else\" ? void 0 : dir.exp,\n    children: isTemplateIf && !findDir(node, \"for\") ? node.children : [node],\n    userKey: findProp(node, `key`),\n    isTemplateIf\n  };\n}\nfunction createCodegenNodeForBranch(branch, keyIndex, context) {\n  if (branch.condition) {\n    return createConditionalExpression(\n      branch.condition,\n      createChildrenCodegenNode(branch, keyIndex, context),\n      // make sure to pass in asBlock: true so that the comment node call\n      // closes the current block.\n      createCallExpression(context.helper(CREATE_COMMENT), [\n        '\"\"',\n        \"true\"\n      ])\n    );\n  } else {\n    return createChildrenCodegenNode(branch, keyIndex, context);\n  }\n}\nfunction createChildrenCodegenNode(branch, keyIndex, context) {\n  const { helper } = context;\n  const keyProperty = createObjectProperty(\n    `key`,\n    createSimpleExpression(\n      `${keyIndex}`,\n      false,\n      locStub,\n      2\n    )\n  );\n  const { children } = branch;\n  const firstChild = children[0];\n  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;\n  if (needFragmentWrapper) {\n    if (children.length === 1 && firstChild.type === 11) {\n      const vnodeCall = firstChild.codegenNode;\n      injectProp(vnodeCall, keyProperty, context);\n      return vnodeCall;\n    } else {\n      let patchFlag = 64;\n      shared.PatchFlagNames[64];\n      return createVNodeCall(\n        context,\n        helper(FRAGMENT),\n        createObjectExpression([keyProperty]),\n        children,\n        patchFlag + (``),\n        void 0,\n        void 0,\n        true,\n        false,\n        false,\n        branch.loc\n      );\n    }\n  } else {\n    const ret = firstChild.codegenNode;\n    const vnodeCall = getMemoedVNodeCall(ret);\n    if (vnodeCall.type === 13) {\n      convertToBlock(vnodeCall, context);\n    }\n    injectProp(vnodeCall, keyProperty, context);\n    return ret;\n  }\n}\nfunction isSameKey(a, b) {\n  if (!a || a.type !== b.type) {\n    return false;\n  }\n  if (a.type === 6) {\n    if (a.value.content !== b.value.content) {\n      return false;\n    }\n  } else {\n    const exp = a.exp;\n    const branchExp = b.exp;\n    if (exp.type !== branchExp.type) {\n      return false;\n    }\n    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getParentCondition(node) {\n  while (true) {\n    if (node.type === 19) {\n      if (node.alternate.type === 19) {\n        node = node.alternate;\n      } else {\n        return node;\n      }\n    } else if (node.type === 20) {\n      node = node.value;\n    }\n  }\n}\n\nconst transformFor = createStructuralDirectiveTransform(\n  \"for\",\n  (node, dir, context) => {\n    const { helper, removeHelper } = context;\n    return processFor(node, dir, context, (forNode) => {\n      const renderExp = createCallExpression(helper(RENDER_LIST), [\n        forNode.source\n      ]);\n      const isTemplate = isTemplateNode(node);\n      const memo = findDir(node, \"memo\");\n      const keyProp = findProp(node, `key`);\n      const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);\n      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;\n      if (isTemplate) {\n        if (memo) {\n          memo.exp = processExpression(\n            memo.exp,\n            context\n          );\n        }\n        if (keyProperty && keyProp.type !== 6) {\n          keyProperty.value = processExpression(\n            keyProperty.value,\n            context\n          );\n        }\n      }\n      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;\n      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;\n      forNode.codegenNode = createVNodeCall(\n        context,\n        helper(FRAGMENT),\n        void 0,\n        renderExp,\n        fragmentFlag + (``),\n        void 0,\n        void 0,\n        true,\n        !isStableFragment,\n        false,\n        node.loc\n      );\n      return () => {\n        let childBlock;\n        const { children } = forNode;\n        if (isTemplate) {\n          node.children.some((c) => {\n            if (c.type === 1) {\n              const key = findProp(c, \"key\");\n              if (key) {\n                context.onError(\n                  createCompilerError(\n                    33,\n                    key.loc\n                  )\n                );\n                return true;\n              }\n            }\n          });\n        }\n        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;\n        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;\n        if (slotOutlet) {\n          childBlock = slotOutlet.codegenNode;\n          if (isTemplate && keyProperty) {\n            injectProp(childBlock, keyProperty, context);\n          }\n        } else if (needFragmentWrapper) {\n          childBlock = createVNodeCall(\n            context,\n            helper(FRAGMENT),\n            keyProperty ? createObjectExpression([keyProperty]) : void 0,\n            node.children,\n            64 + (``),\n            void 0,\n            void 0,\n            true,\n            void 0,\n            false\n            /* isComponent */\n          );\n        } else {\n          childBlock = children[0].codegenNode;\n          if (isTemplate && keyProperty) {\n            injectProp(childBlock, keyProperty, context);\n          }\n          if (childBlock.isBlock !== !isStableFragment) {\n            if (childBlock.isBlock) {\n              removeHelper(OPEN_BLOCK);\n              removeHelper(\n                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)\n              );\n            } else {\n              removeHelper(\n                getVNodeHelper(context.inSSR, childBlock.isComponent)\n              );\n            }\n          }\n          childBlock.isBlock = !isStableFragment;\n          if (childBlock.isBlock) {\n            helper(OPEN_BLOCK);\n            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));\n          } else {\n            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));\n          }\n        }\n        if (memo) {\n          const loop = createFunctionExpression(\n            createForLoopParams(forNode.parseResult, [\n              createSimpleExpression(`_cached`)\n            ])\n          );\n          loop.body = createBlockStatement([\n            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),\n            createCompoundExpression([\n              `if (_cached`,\n              ...keyExp ? [` && _cached.key === `, keyExp] : [],\n              ` && ${context.helperString(\n                IS_MEMO_SAME\n              )}(_cached, _memo)) return _cached`\n            ]),\n            createCompoundExpression([`const _item = `, childBlock]),\n            createSimpleExpression(`_item.memo = _memo`),\n            createSimpleExpression(`return _item`)\n          ]);\n          renderExp.arguments.push(\n            loop,\n            createSimpleExpression(`_cache`),\n            createSimpleExpression(String(context.cached++))\n          );\n        } else {\n          renderExp.arguments.push(\n            createFunctionExpression(\n              createForLoopParams(forNode.parseResult),\n              childBlock,\n              true\n              /* force newline */\n            )\n          );\n        }\n      };\n    });\n  }\n);\nfunction processFor(node, dir, context, processCodegen) {\n  if (!dir.exp) {\n    context.onError(\n      createCompilerError(31, dir.loc)\n    );\n    return;\n  }\n  const parseResult = parseForExpression(\n    // can only be simple expression because vFor transform is applied\n    // before expression transform.\n    dir.exp,\n    context\n  );\n  if (!parseResult) {\n    context.onError(\n      createCompilerError(32, dir.loc)\n    );\n    return;\n  }\n  const { addIdentifiers, removeIdentifiers, scopes } = context;\n  const { source, value, key, index } = parseResult;\n  const forNode = {\n    type: 11,\n    loc: dir.loc,\n    source,\n    valueAlias: value,\n    keyAlias: key,\n    objectIndexAlias: index,\n    parseResult,\n    children: isTemplateNode(node) ? node.children : [node]\n  };\n  context.replaceNode(forNode);\n  scopes.vFor++;\n  if (context.prefixIdentifiers) {\n    value && addIdentifiers(value);\n    key && addIdentifiers(key);\n    index && addIdentifiers(index);\n  }\n  const onExit = processCodegen && processCodegen(forNode);\n  return () => {\n    scopes.vFor--;\n    if (context.prefixIdentifiers) {\n      value && removeIdentifiers(value);\n      key && removeIdentifiers(key);\n      index && removeIdentifiers(index);\n    }\n    if (onExit)\n      onExit();\n  };\n}\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nconst stripParensRE = /^\\(|\\)$/g;\nfunction parseForExpression(input, context) {\n  const loc = input.loc;\n  const exp = input.content;\n  const inMatch = exp.match(forAliasRE);\n  if (!inMatch)\n    return;\n  const [, LHS, RHS] = inMatch;\n  const result = {\n    source: createAliasExpression(\n      loc,\n      RHS.trim(),\n      exp.indexOf(RHS, LHS.length)\n    ),\n    value: void 0,\n    key: void 0,\n    index: void 0\n  };\n  if (context.prefixIdentifiers) {\n    result.source = processExpression(\n      result.source,\n      context\n    );\n  }\n  let valueContent = LHS.trim().replace(stripParensRE, \"\").trim();\n  const trimmedOffset = LHS.indexOf(valueContent);\n  const iteratorMatch = valueContent.match(forIteratorRE);\n  if (iteratorMatch) {\n    valueContent = valueContent.replace(forIteratorRE, \"\").trim();\n    const keyContent = iteratorMatch[1].trim();\n    let keyOffset;\n    if (keyContent) {\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\n      result.key = createAliasExpression(loc, keyContent, keyOffset);\n      if (context.prefixIdentifiers) {\n        result.key = processExpression(result.key, context, true);\n      }\n    }\n    if (iteratorMatch[2]) {\n      const indexContent = iteratorMatch[2].trim();\n      if (indexContent) {\n        result.index = createAliasExpression(\n          loc,\n          indexContent,\n          exp.indexOf(\n            indexContent,\n            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length\n          )\n        );\n        if (context.prefixIdentifiers) {\n          result.index = processExpression(result.index, context, true);\n        }\n      }\n    }\n  }\n  if (valueContent) {\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset);\n    if (context.prefixIdentifiers) {\n      result.value = processExpression(result.value, context, true);\n    }\n  }\n  return result;\n}\nfunction createAliasExpression(range, content, offset) {\n  return createSimpleExpression(\n    content,\n    false,\n    getInnerRange(range, offset, content.length)\n  );\n}\nfunction createForLoopParams({ value, key, index }, memoArgs = []) {\n  return createParamsList([value, key, index, ...memoArgs]);\n}\nfunction createParamsList(args) {\n  let i = args.length;\n  while (i--) {\n    if (args[i])\n      break;\n  }\n  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));\n}\n\nconst defaultFallback = createSimpleExpression(`undefined`, false);\nconst trackSlotScopes = (node, context) => {\n  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {\n    const vSlot = findDir(node, \"slot\");\n    if (vSlot) {\n      const slotProps = vSlot.exp;\n      if (context.prefixIdentifiers) {\n        slotProps && context.addIdentifiers(slotProps);\n      }\n      context.scopes.vSlot++;\n      return () => {\n        if (context.prefixIdentifiers) {\n          slotProps && context.removeIdentifiers(slotProps);\n        }\n        context.scopes.vSlot--;\n      };\n    }\n  }\n};\nconst trackVForSlotScopes = (node, context) => {\n  let vFor;\n  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, \"for\"))) {\n    const result = vFor.parseResult = parseForExpression(\n      vFor.exp,\n      context\n    );\n    if (result) {\n      const { value, key, index } = result;\n      const { addIdentifiers, removeIdentifiers } = context;\n      value && addIdentifiers(value);\n      key && addIdentifiers(key);\n      index && addIdentifiers(index);\n      return () => {\n        value && removeIdentifiers(value);\n        key && removeIdentifiers(key);\n        index && removeIdentifiers(index);\n      };\n    }\n  }\n};\nconst buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(\n  props,\n  children,\n  false,\n  true,\n  children.length ? children[0].loc : loc\n);\nfunction buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\n  context.helper(WITH_CTX);\n  const { children, loc } = node;\n  const slotsProperties = [];\n  const dynamicSlots = [];\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\n  if (!context.ssr && context.prefixIdentifiers) {\n    hasDynamicSlots = hasScopeRef(node, context.identifiers);\n  }\n  const onComponentSlot = findDir(node, \"slot\", true);\n  if (onComponentSlot) {\n    const { arg, exp } = onComponentSlot;\n    if (arg && !isStaticExp(arg)) {\n      hasDynamicSlots = true;\n    }\n    slotsProperties.push(\n      createObjectProperty(\n        arg || createSimpleExpression(\"default\", true),\n        buildSlotFn(exp, void 0, children, loc)\n      )\n    );\n  }\n  let hasTemplateSlots = false;\n  let hasNamedDefaultSlot = false;\n  const implicitDefaultChildren = [];\n  const seenSlotNames = /* @__PURE__ */ new Set();\n  let conditionalBranchIndex = 0;\n  for (let i = 0; i < children.length; i++) {\n    const slotElement = children[i];\n    let slotDir;\n    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, \"slot\", true))) {\n      if (slotElement.type !== 3) {\n        implicitDefaultChildren.push(slotElement);\n      }\n      continue;\n    }\n    if (onComponentSlot) {\n      context.onError(\n        createCompilerError(37, slotDir.loc)\n      );\n      break;\n    }\n    hasTemplateSlots = true;\n    const { children: slotChildren, loc: slotLoc } = slotElement;\n    const {\n      arg: slotName = createSimpleExpression(`default`, true),\n      exp: slotProps,\n      loc: dirLoc\n    } = slotDir;\n    let staticSlotName;\n    if (isStaticExp(slotName)) {\n      staticSlotName = slotName ? slotName.content : `default`;\n    } else {\n      hasDynamicSlots = true;\n    }\n    const vFor = findDir(slotElement, \"for\");\n    const slotFunction = buildSlotFn(\n      slotProps,\n      vFor == null ? void 0 : vFor.exp,\n      slotChildren,\n      slotLoc\n    );\n    let vIf;\n    let vElse;\n    if (vIf = findDir(slotElement, \"if\")) {\n      hasDynamicSlots = true;\n      dynamicSlots.push(\n        createConditionalExpression(\n          vIf.exp,\n          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),\n          defaultFallback\n        )\n      );\n    } else if (vElse = findDir(\n      slotElement,\n      /^else(-if)?$/,\n      true\n      /* allowEmpty */\n    )) {\n      let j = i;\n      let prev;\n      while (j--) {\n        prev = children[j];\n        if (prev.type !== 3) {\n          break;\n        }\n      }\n      if (prev && isTemplateNode(prev) && findDir(prev, \"if\")) {\n        children.splice(i, 1);\n        i--;\n        let conditional = dynamicSlots[dynamicSlots.length - 1];\n        while (conditional.alternate.type === 19) {\n          conditional = conditional.alternate;\n        }\n        conditional.alternate = vElse.exp ? createConditionalExpression(\n          vElse.exp,\n          buildDynamicSlot(\n            slotName,\n            slotFunction,\n            conditionalBranchIndex++\n          ),\n          defaultFallback\n        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);\n      } else {\n        context.onError(\n          createCompilerError(30, vElse.loc)\n        );\n      }\n    } else if (vFor) {\n      hasDynamicSlots = true;\n      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);\n      if (parseResult) {\n        dynamicSlots.push(\n          createCallExpression(context.helper(RENDER_LIST), [\n            parseResult.source,\n            createFunctionExpression(\n              createForLoopParams(parseResult),\n              buildDynamicSlot(slotName, slotFunction),\n              true\n              /* force newline */\n            )\n          ])\n        );\n      } else {\n        context.onError(\n          createCompilerError(32, vFor.loc)\n        );\n      }\n    } else {\n      if (staticSlotName) {\n        if (seenSlotNames.has(staticSlotName)) {\n          context.onError(\n            createCompilerError(\n              38,\n              dirLoc\n            )\n          );\n          continue;\n        }\n        seenSlotNames.add(staticSlotName);\n        if (staticSlotName === \"default\") {\n          hasNamedDefaultSlot = true;\n        }\n      }\n      slotsProperties.push(createObjectProperty(slotName, slotFunction));\n    }\n  }\n  if (!onComponentSlot) {\n    const buildDefaultSlotProperty = (props, children2) => {\n      const fn = buildSlotFn(props, void 0, children2, loc);\n      if (context.compatConfig) {\n        fn.isNonScopedSlot = true;\n      }\n      return createObjectProperty(`default`, fn);\n    };\n    if (!hasTemplateSlots) {\n      slotsProperties.push(buildDefaultSlotProperty(void 0, children));\n    } else if (implicitDefaultChildren.length && // #3766\n    // with whitespace: 'preserve', whitespaces between slots will end up in\n    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\n    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {\n      if (hasNamedDefaultSlot) {\n        context.onError(\n          createCompilerError(\n            39,\n            implicitDefaultChildren[0].loc\n          )\n        );\n      } else {\n        slotsProperties.push(\n          buildDefaultSlotProperty(void 0, implicitDefaultChildren)\n        );\n      }\n    }\n  }\n  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;\n  let slots = createObjectExpression(\n    slotsProperties.concat(\n      createObjectProperty(\n        `_`,\n        // 2 = compiled but dynamic = can skip normalization, but must run diff\n        // 1 = compiled and static = can skip normalization AND diff as optimized\n        createSimpleExpression(\n          slotFlag + (``),\n          false\n        )\n      )\n    ),\n    loc\n  );\n  if (dynamicSlots.length) {\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\n      slots,\n      createArrayExpression(dynamicSlots)\n    ]);\n  }\n  return {\n    slots,\n    hasDynamicSlots\n  };\n}\nfunction buildDynamicSlot(name, fn, index) {\n  const props = [\n    createObjectProperty(`name`, name),\n    createObjectProperty(`fn`, fn)\n  ];\n  if (index != null) {\n    props.push(\n      createObjectProperty(`key`, createSimpleExpression(String(index), true))\n    );\n  }\n  return createObjectExpression(props);\n}\nfunction hasForwardedSlots(children) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    switch (child.type) {\n      case 1:\n        if (child.tagType === 2 || hasForwardedSlots(child.children)) {\n          return true;\n        }\n        break;\n      case 9:\n        if (hasForwardedSlots(child.branches))\n          return true;\n        break;\n      case 10:\n      case 11:\n        if (hasForwardedSlots(child.children))\n          return true;\n        break;\n    }\n  }\n  return false;\n}\nfunction isNonWhitespaceContent(node) {\n  if (node.type !== 2 && node.type !== 12)\n    return true;\n  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);\n}\n\nconst directiveImportMap = /* @__PURE__ */ new WeakMap();\nconst transformElement = (node, context) => {\n  return function postTransformElement() {\n    node = context.currentNode;\n    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {\n      return;\n    }\n    const { tag, props } = node;\n    const isComponent = node.tagType === 1;\n    let vnodeTag = isComponent ? resolveComponentType(node, context) : `\"${tag}\"`;\n    const isDynamicComponent = shared.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\n    let vnodeProps;\n    let vnodeChildren;\n    let vnodePatchFlag;\n    let patchFlag = 0;\n    let vnodeDynamicProps;\n    let dynamicPropNames;\n    let vnodeDirectives;\n    let shouldUseBlock = (\n      // dynamic component may resolve to plain elements\n      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block\n      // updates inside get proper isSVG flag at runtime. (#639, #643)\n      // This is technically web-specific, but splitting the logic out of core\n      // leads to too much unnecessary complexity.\n      (tag === \"svg\" || tag === \"foreignObject\")\n    );\n    if (props.length > 0) {\n      const propsBuildResult = buildProps(\n        node,\n        context,\n        void 0,\n        isComponent,\n        isDynamicComponent\n      );\n      vnodeProps = propsBuildResult.props;\n      patchFlag = propsBuildResult.patchFlag;\n      dynamicPropNames = propsBuildResult.dynamicPropNames;\n      const directives = propsBuildResult.directives;\n      vnodeDirectives = directives && directives.length ? createArrayExpression(\n        directives.map((dir) => buildDirectiveArgs(dir, context))\n      ) : void 0;\n      if (propsBuildResult.shouldUseBlock) {\n        shouldUseBlock = true;\n      }\n    }\n    if (node.children.length > 0) {\n      if (vnodeTag === KEEP_ALIVE) {\n        shouldUseBlock = true;\n        patchFlag |= 1024;\n      }\n      const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling\n      vnodeTag !== TELEPORT && // explained above.\n      vnodeTag !== KEEP_ALIVE;\n      if (shouldBuildAsSlots) {\n        const { slots, hasDynamicSlots } = buildSlots(node, context);\n        vnodeChildren = slots;\n        if (hasDynamicSlots) {\n          patchFlag |= 1024;\n        }\n      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\n        const child = node.children[0];\n        const type = child.type;\n        const hasDynamicTextChild = type === 5 || type === 8;\n        if (hasDynamicTextChild && getConstantType(child, context) === 0) {\n          patchFlag |= 1;\n        }\n        if (hasDynamicTextChild || type === 2) {\n          vnodeChildren = child;\n        } else {\n          vnodeChildren = node.children;\n        }\n      } else {\n        vnodeChildren = node.children;\n      }\n    }\n    if (patchFlag !== 0) {\n      {\n        vnodePatchFlag = String(patchFlag);\n      }\n      if (dynamicPropNames && dynamicPropNames.length) {\n        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\n      }\n    }\n    node.codegenNode = createVNodeCall(\n      context,\n      vnodeTag,\n      vnodeProps,\n      vnodeChildren,\n      vnodePatchFlag,\n      vnodeDynamicProps,\n      vnodeDirectives,\n      !!shouldUseBlock,\n      false,\n      isComponent,\n      node.loc\n    );\n  };\n};\nfunction resolveComponentType(node, context, ssr = false) {\n  let { tag } = node;\n  const isExplicitDynamic = isComponentTag(tag);\n  const isProp = findProp(node, \"is\");\n  if (isProp) {\n    if (isExplicitDynamic || isCompatEnabled(\n      \"COMPILER_IS_ON_ELEMENT\",\n      context\n    )) {\n      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;\n      if (exp) {\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n          exp\n        ]);\n      }\n    } else if (isProp.type === 6 && isProp.value.content.startsWith(\"vue:\")) {\n      tag = isProp.value.content.slice(4);\n    }\n  }\n  const isDir = !isExplicitDynamic && findDir(node, \"is\");\n  if (isDir && isDir.exp) {\n    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n      isDir.exp\n    ]);\n  }\n  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\n  if (builtIn) {\n    if (!ssr)\n      context.helper(builtIn);\n    return builtIn;\n  }\n  {\n    const fromSetup = resolveSetupReference(tag, context);\n    if (fromSetup) {\n      return fromSetup;\n    }\n    const dotIndex = tag.indexOf(\".\");\n    if (dotIndex > 0) {\n      const ns = resolveSetupReference(tag.slice(0, dotIndex), context);\n      if (ns) {\n        return ns + tag.slice(dotIndex);\n      }\n    }\n  }\n  if (context.selfName && shared.capitalize(shared.camelize(tag)) === context.selfName) {\n    context.helper(RESOLVE_COMPONENT);\n    context.components.add(tag + `__self`);\n    return toValidAssetId(tag, `component`);\n  }\n  context.helper(RESOLVE_COMPONENT);\n  context.components.add(tag);\n  return toValidAssetId(tag, `component`);\n}\nfunction resolveSetupReference(name, context) {\n  const bindings = context.bindingMetadata;\n  if (!bindings || bindings.__isScriptSetup === false) {\n    return;\n  }\n  const camelName = shared.camelize(name);\n  const PascalName = shared.capitalize(camelName);\n  const checkType = (type) => {\n    if (bindings[name] === type) {\n      return name;\n    }\n    if (bindings[camelName] === type) {\n      return camelName;\n    }\n    if (bindings[PascalName] === type) {\n      return PascalName;\n    }\n  };\n  const fromConst = checkType(\"setup-const\") || checkType(\"setup-reactive-const\") || checkType(\"literal-const\");\n  if (fromConst) {\n    return context.inline ? (\n      // in inline mode, const setup bindings (e.g. imports) can be used as-is\n      fromConst\n    ) : `$setup[${JSON.stringify(fromConst)}]`;\n  }\n  const fromMaybeRef = checkType(\"setup-let\") || checkType(\"setup-ref\") || checkType(\"setup-maybe-ref\");\n  if (fromMaybeRef) {\n    return context.inline ? (\n      // setup scope bindings that may be refs need to be unrefed\n      `${context.helperString(UNREF)}(${fromMaybeRef})`\n    ) : `$setup[${JSON.stringify(fromMaybeRef)}]`;\n  }\n}\nfunction buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {\n  const { tag, loc: elementLoc, children } = node;\n  let properties = [];\n  const mergeArgs = [];\n  const runtimeDirectives = [];\n  const hasChildren = children.length > 0;\n  let shouldUseBlock = false;\n  let patchFlag = 0;\n  let hasRef = false;\n  let hasClassBinding = false;\n  let hasStyleBinding = false;\n  let hasHydrationEventBinding = false;\n  let hasDynamicKeys = false;\n  let hasVnodeHook = false;\n  const dynamicPropNames = [];\n  const pushMergeArg = (arg) => {\n    if (properties.length) {\n      mergeArgs.push(\n        createObjectExpression(dedupeProperties(properties), elementLoc)\n      );\n      properties = [];\n    }\n    if (arg)\n      mergeArgs.push(arg);\n  };\n  const analyzePatchFlag = ({ key, value }) => {\n    if (isStaticExp(key)) {\n      const name = key.content;\n      const isEventHandler = shared.isOn(name);\n      if (isEventHandler && (!isComponent || isDynamicComponent) && // omit the flag for click handlers because hydration gives click\n      // dedicated fast path.\n      name.toLowerCase() !== \"onclick\" && // omit v-model handlers\n      name !== \"onUpdate:modelValue\" && // omit onVnodeXXX hooks\n      !shared.isReservedProp(name)) {\n        hasHydrationEventBinding = true;\n      }\n      if (isEventHandler && shared.isReservedProp(name)) {\n        hasVnodeHook = true;\n      }\n      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {\n        return;\n      }\n      if (name === \"ref\") {\n        hasRef = true;\n      } else if (name === \"class\") {\n        hasClassBinding = true;\n      } else if (name === \"style\") {\n        hasStyleBinding = true;\n      } else if (name !== \"key\" && !dynamicPropNames.includes(name)) {\n        dynamicPropNames.push(name);\n      }\n      if (isComponent && (name === \"class\" || name === \"style\") && !dynamicPropNames.includes(name)) {\n        dynamicPropNames.push(name);\n      }\n    } else {\n      hasDynamicKeys = true;\n    }\n  };\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n    if (prop.type === 6) {\n      const { loc, name, value } = prop;\n      let isStatic = true;\n      if (name === \"ref\") {\n        hasRef = true;\n        if (context.scopes.vFor > 0) {\n          properties.push(\n            createObjectProperty(\n              createSimpleExpression(\"ref_for\", true),\n              createSimpleExpression(\"true\")\n            )\n          );\n        }\n        if (value && context.inline) {\n          const binding = context.bindingMetadata[value.content];\n          if (binding === \"setup-let\" || binding === \"setup-ref\" || binding === \"setup-maybe-ref\") {\n            isStatic = false;\n            properties.push(\n              createObjectProperty(\n                createSimpleExpression(\"ref_key\", true),\n                createSimpleExpression(value.content, true, value.loc)\n              )\n            );\n          }\n        }\n      }\n      if (name === \"is\" && (isComponentTag(tag) || value && value.content.startsWith(\"vue:\") || isCompatEnabled(\n        \"COMPILER_IS_ON_ELEMENT\",\n        context\n      ))) {\n        continue;\n      }\n      properties.push(\n        createObjectProperty(\n          createSimpleExpression(\n            name,\n            true,\n            getInnerRange(loc, 0, name.length)\n          ),\n          createSimpleExpression(\n            value ? value.content : \"\",\n            isStatic,\n            value ? value.loc : loc\n          )\n        )\n      );\n    } else {\n      const { name, arg, exp, loc, modifiers } = prop;\n      const isVBind = name === \"bind\";\n      const isVOn = name === \"on\";\n      if (name === \"slot\") {\n        if (!isComponent) {\n          context.onError(\n            createCompilerError(40, loc)\n          );\n        }\n        continue;\n      }\n      if (name === \"once\" || name === \"memo\") {\n        continue;\n      }\n      if (name === \"is\" || isVBind && isStaticArgOf(arg, \"is\") && (isComponentTag(tag) || isCompatEnabled(\n        \"COMPILER_IS_ON_ELEMENT\",\n        context\n      ))) {\n        continue;\n      }\n      if (isVOn && ssr) {\n        continue;\n      }\n      if (\n        // #938: elements with dynamic keys should be forced into blocks\n        isVBind && isStaticArgOf(arg, \"key\") || // inline before-update hooks need to force block so that it is invoked\n        // before children\n        isVOn && hasChildren && isStaticArgOf(arg, \"vue:before-update\")\n      ) {\n        shouldUseBlock = true;\n      }\n      if (isVBind && isStaticArgOf(arg, \"ref\") && context.scopes.vFor > 0) {\n        properties.push(\n          createObjectProperty(\n            createSimpleExpression(\"ref_for\", true),\n            createSimpleExpression(\"true\")\n          )\n        );\n      }\n      if (!arg && (isVBind || isVOn)) {\n        hasDynamicKeys = true;\n        if (exp) {\n          if (isVBind) {\n            pushMergeArg();\n            {\n              if (isCompatEnabled(\n                \"COMPILER_V_BIND_OBJECT_ORDER\",\n                context\n              )) {\n                mergeArgs.unshift(exp);\n                continue;\n              }\n            }\n            mergeArgs.push(exp);\n          } else {\n            pushMergeArg({\n              type: 14,\n              loc,\n              callee: context.helper(TO_HANDLERS),\n              arguments: isComponent ? [exp] : [exp, `true`]\n            });\n          }\n        } else {\n          context.onError(\n            createCompilerError(\n              isVBind ? 34 : 35,\n              loc\n            )\n          );\n        }\n        continue;\n      }\n      if (isVBind && modifiers.includes(\"prop\")) {\n        patchFlag |= 32;\n      }\n      const directiveTransform = context.directiveTransforms[name];\n      if (directiveTransform) {\n        const { props: props2, needRuntime } = directiveTransform(prop, node, context);\n        !ssr && props2.forEach(analyzePatchFlag);\n        if (isVOn && arg && !isStaticExp(arg)) {\n          pushMergeArg(createObjectExpression(props2, elementLoc));\n        } else {\n          properties.push(...props2);\n        }\n        if (needRuntime) {\n          runtimeDirectives.push(prop);\n          if (shared.isSymbol(needRuntime)) {\n            directiveImportMap.set(prop, needRuntime);\n          }\n        }\n      } else if (!shared.isBuiltInDirective(name)) {\n        runtimeDirectives.push(prop);\n        if (hasChildren) {\n          shouldUseBlock = true;\n        }\n      }\n    }\n  }\n  let propsExpression = void 0;\n  if (mergeArgs.length) {\n    pushMergeArg();\n    if (mergeArgs.length > 1) {\n      propsExpression = createCallExpression(\n        context.helper(MERGE_PROPS),\n        mergeArgs,\n        elementLoc\n      );\n    } else {\n      propsExpression = mergeArgs[0];\n    }\n  } else if (properties.length) {\n    propsExpression = createObjectExpression(\n      dedupeProperties(properties),\n      elementLoc\n    );\n  }\n  if (hasDynamicKeys) {\n    patchFlag |= 16;\n  } else {\n    if (hasClassBinding && !isComponent) {\n      patchFlag |= 2;\n    }\n    if (hasStyleBinding && !isComponent) {\n      patchFlag |= 4;\n    }\n    if (dynamicPropNames.length) {\n      patchFlag |= 8;\n    }\n    if (hasHydrationEventBinding) {\n      patchFlag |= 32;\n    }\n  }\n  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\n    patchFlag |= 512;\n  }\n  if (!context.inSSR && propsExpression) {\n    switch (propsExpression.type) {\n      case 15:\n        let classKeyIndex = -1;\n        let styleKeyIndex = -1;\n        let hasDynamicKey = false;\n        for (let i = 0; i < propsExpression.properties.length; i++) {\n          const key = propsExpression.properties[i].key;\n          if (isStaticExp(key)) {\n            if (key.content === \"class\") {\n              classKeyIndex = i;\n            } else if (key.content === \"style\") {\n              styleKeyIndex = i;\n            }\n          } else if (!key.isHandlerKey) {\n            hasDynamicKey = true;\n          }\n        }\n        const classProp = propsExpression.properties[classKeyIndex];\n        const styleProp = propsExpression.properties[styleKeyIndex];\n        if (!hasDynamicKey) {\n          if (classProp && !isStaticExp(classProp.value)) {\n            classProp.value = createCallExpression(\n              context.helper(NORMALIZE_CLASS),\n              [classProp.value]\n            );\n          }\n          if (styleProp && // the static style is compiled into an object,\n          // so use `hasStyleBinding` to ensure that it is a dynamic style binding\n          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,\n          // v-bind:style with static literal object\n          styleProp.value.type === 17)) {\n            styleProp.value = createCallExpression(\n              context.helper(NORMALIZE_STYLE),\n              [styleProp.value]\n            );\n          }\n        } else {\n          propsExpression = createCallExpression(\n            context.helper(NORMALIZE_PROPS),\n            [propsExpression]\n          );\n        }\n        break;\n      case 14:\n        break;\n      default:\n        propsExpression = createCallExpression(\n          context.helper(NORMALIZE_PROPS),\n          [\n            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\n              propsExpression\n            ])\n          ]\n        );\n        break;\n    }\n  }\n  return {\n    props: propsExpression,\n    directives: runtimeDirectives,\n    patchFlag,\n    dynamicPropNames,\n    shouldUseBlock\n  };\n}\nfunction dedupeProperties(properties) {\n  const knownProps = /* @__PURE__ */ new Map();\n  const deduped = [];\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i];\n    if (prop.key.type === 8 || !prop.key.isStatic) {\n      deduped.push(prop);\n      continue;\n    }\n    const name = prop.key.content;\n    const existing = knownProps.get(name);\n    if (existing) {\n      if (name === \"style\" || name === \"class\" || shared.isOn(name)) {\n        mergeAsArray(existing, prop);\n      }\n    } else {\n      knownProps.set(name, prop);\n      deduped.push(prop);\n    }\n  }\n  return deduped;\n}\nfunction mergeAsArray(existing, incoming) {\n  if (existing.value.type === 17) {\n    existing.value.elements.push(incoming.value);\n  } else {\n    existing.value = createArrayExpression(\n      [existing.value, incoming.value],\n      existing.loc\n    );\n  }\n}\nfunction buildDirectiveArgs(dir, context) {\n  const dirArgs = [];\n  const runtime = directiveImportMap.get(dir);\n  if (runtime) {\n    dirArgs.push(context.helperString(runtime));\n  } else {\n    const fromSetup = resolveSetupReference(\"v-\" + dir.name, context);\n    if (fromSetup) {\n      dirArgs.push(fromSetup);\n    } else {\n      context.helper(RESOLVE_DIRECTIVE);\n      context.directives.add(dir.name);\n      dirArgs.push(toValidAssetId(dir.name, `directive`));\n    }\n  }\n  const { loc } = dir;\n  if (dir.exp)\n    dirArgs.push(dir.exp);\n  if (dir.arg) {\n    if (!dir.exp) {\n      dirArgs.push(`void 0`);\n    }\n    dirArgs.push(dir.arg);\n  }\n  if (Object.keys(dir.modifiers).length) {\n    if (!dir.arg) {\n      if (!dir.exp) {\n        dirArgs.push(`void 0`);\n      }\n      dirArgs.push(`void 0`);\n    }\n    const trueExpression = createSimpleExpression(`true`, false, loc);\n    dirArgs.push(\n      createObjectExpression(\n        dir.modifiers.map(\n          (modifier) => createObjectProperty(modifier, trueExpression)\n        ),\n        loc\n      )\n    );\n  }\n  return createArrayExpression(dirArgs, dir.loc);\n}\nfunction stringifyDynamicPropNames(props) {\n  let propsNamesString = `[`;\n  for (let i = 0, l = props.length; i < l; i++) {\n    propsNamesString += JSON.stringify(props[i]);\n    if (i < l - 1)\n      propsNamesString += \", \";\n  }\n  return propsNamesString + `]`;\n}\nfunction isComponentTag(tag) {\n  return tag === \"component\" || tag === \"Component\";\n}\n\nconst transformSlotOutlet = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const { children, loc } = node;\n    const { slotName, slotProps } = processSlotOutlet(node, context);\n    const slotArgs = [\n      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\n      slotName,\n      \"{}\",\n      \"undefined\",\n      \"true\"\n    ];\n    let expectedLen = 2;\n    if (slotProps) {\n      slotArgs[2] = slotProps;\n      expectedLen = 3;\n    }\n    if (children.length) {\n      slotArgs[3] = createFunctionExpression([], children, false, false, loc);\n      expectedLen = 4;\n    }\n    if (context.scopeId && !context.slotted) {\n      expectedLen = 5;\n    }\n    slotArgs.splice(expectedLen);\n    node.codegenNode = createCallExpression(\n      context.helper(RENDER_SLOT),\n      slotArgs,\n      loc\n    );\n  }\n};\nfunction processSlotOutlet(node, context) {\n  let slotName = `\"default\"`;\n  let slotProps = void 0;\n  const nonNameProps = [];\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 6) {\n      if (p.value) {\n        if (p.name === \"name\") {\n          slotName = JSON.stringify(p.value.content);\n        } else {\n          p.name = shared.camelize(p.name);\n          nonNameProps.push(p);\n        }\n      }\n    } else {\n      if (p.name === \"bind\" && isStaticArgOf(p.arg, \"name\")) {\n        if (p.exp)\n          slotName = p.exp;\n      } else {\n        if (p.name === \"bind\" && p.arg && isStaticExp(p.arg)) {\n          p.arg.content = shared.camelize(p.arg.content);\n        }\n        nonNameProps.push(p);\n      }\n    }\n  }\n  if (nonNameProps.length > 0) {\n    const { props, directives } = buildProps(\n      node,\n      context,\n      nonNameProps,\n      false,\n      false\n    );\n    slotProps = props;\n    if (directives.length) {\n      context.onError(\n        createCompilerError(\n          36,\n          directives[0].loc\n        )\n      );\n    }\n  }\n  return {\n    slotName,\n    slotProps\n  };\n}\n\nconst fnExpRE = /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*(:[^=]+)?=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/;\nconst transformOn = (dir, node, context, augmentor) => {\n  const { loc, modifiers, arg } = dir;\n  if (!dir.exp && !modifiers.length) {\n    context.onError(createCompilerError(35, loc));\n  }\n  let eventName;\n  if (arg.type === 4) {\n    if (arg.isStatic) {\n      let rawName = arg.content;\n      if (rawName.startsWith(\"vue:\")) {\n        rawName = `vnode-${rawName.slice(4)}`;\n      }\n      const eventString = node.tagType !== 0 || rawName.startsWith(\"vnode\") || !/[A-Z]/.test(rawName) ? (\n        // for non-element and vnode lifecycle event listeners, auto convert\n        // it to camelCase. See issue #2249\n        shared.toHandlerKey(shared.camelize(rawName))\n      ) : (\n        // preserve case for plain element listeners that have uppercase\n        // letters, as these may be custom elements' custom events\n        `on:${rawName}`\n      );\n      eventName = createSimpleExpression(eventString, true, arg.loc);\n    } else {\n      eventName = createCompoundExpression([\n        `${context.helperString(TO_HANDLER_KEY)}(`,\n        arg,\n        `)`\n      ]);\n    }\n  } else {\n    eventName = arg;\n    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\n    eventName.children.push(`)`);\n  }\n  let exp = dir.exp;\n  if (exp && !exp.content.trim()) {\n    exp = void 0;\n  }\n  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;\n  if (exp) {\n    const isMemberExp = isMemberExpression(exp.content, context);\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\n    const hasMultipleStatements = exp.content.includes(`;`);\n    if (context.prefixIdentifiers) {\n      isInlineStatement && context.addIdentifiers(`$event`);\n      exp = dir.exp = processExpression(\n        exp,\n        context,\n        false,\n        hasMultipleStatements\n      );\n      isInlineStatement && context.removeIdentifiers(`$event`);\n      shouldCache = context.cacheHandlers && // unnecessary to cache inside v-once\n      !context.inVOnce && // runtime constants don't need to be cached\n      // (this is analyzed by compileScript in SFC <script setup>)\n      !(exp.type === 4 && exp.constType > 0) && // #1541 bail if this is a member exp handler passed to a component -\n      // we need to use the original function to preserve arity,\n      // e.g. <transition> relies on checking cb.length to determine\n      // transition end handling. Inline function is ok since its arity\n      // is preserved even when cached.\n      !(isMemberExp && node.tagType === 1) && // bail if the function references closure variables (v-for, v-slot)\n      // it must be passed fresh to avoid stale values.\n      !hasScopeRef(exp, context.identifiers);\n      if (shouldCache && isMemberExp) {\n        if (exp.type === 4) {\n          exp.content = `${exp.content} && ${exp.content}(...args)`;\n        } else {\n          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];\n        }\n      }\n    }\n    if (isInlineStatement || shouldCache && isMemberExp) {\n      exp = createCompoundExpression([\n        `${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `\n//@ts-ignore\n` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\n        exp,\n        hasMultipleStatements ? `}` : `)`\n      ]);\n    }\n  }\n  let ret = {\n    props: [\n      createObjectProperty(\n        eventName,\n        exp || createSimpleExpression(`() => {}`, false, loc)\n      )\n    ]\n  };\n  if (augmentor) {\n    ret = augmentor(ret);\n  }\n  if (shouldCache) {\n    ret.props[0].value = context.cache(ret.props[0].value);\n  }\n  ret.props.forEach((p) => p.key.isHandlerKey = true);\n  return ret;\n};\n\nconst transformBind = (dir, _node, context) => {\n  const { exp, modifiers, loc } = dir;\n  const arg = dir.arg;\n  if (arg.type !== 4) {\n    arg.children.unshift(`(`);\n    arg.children.push(`) || \"\"`);\n  } else if (!arg.isStatic) {\n    arg.content = `${arg.content} || \"\"`;\n  }\n  if (modifiers.includes(\"camel\")) {\n    if (arg.type === 4) {\n      if (arg.isStatic) {\n        arg.content = shared.camelize(arg.content);\n      } else {\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\n      }\n    } else {\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\n      arg.children.push(`)`);\n    }\n  }\n  if (!context.inSSR) {\n    if (modifiers.includes(\"prop\")) {\n      injectPrefix(arg, \".\");\n    }\n    if (modifiers.includes(\"attr\")) {\n      injectPrefix(arg, \"^\");\n    }\n  }\n  if (!exp || exp.type === 4 && !exp.content.trim()) {\n    context.onError(createCompilerError(34, loc));\n    return {\n      props: [createObjectProperty(arg, createSimpleExpression(\"\", true, loc))]\n    };\n  }\n  return {\n    props: [createObjectProperty(arg, exp)]\n  };\n};\nconst injectPrefix = (arg, prefix) => {\n  if (arg.type === 4) {\n    if (arg.isStatic) {\n      arg.content = prefix + arg.content;\n    } else {\n      arg.content = `\\`${prefix}\\${${arg.content}}\\``;\n    }\n  } else {\n    arg.children.unshift(`'${prefix}' + (`);\n    arg.children.push(`)`);\n  }\n};\n\nconst transformText = (node, context) => {\n  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {\n    return () => {\n      const children = node.children;\n      let currentContainer = void 0;\n      let hasText = false;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (isText$1(child)) {\n          hasText = true;\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j];\n            if (isText$1(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = createCompoundExpression(\n                  [child],\n                  child.loc\n                );\n              }\n              currentContainer.children.push(` + `, next);\n              children.splice(j, 1);\n              j--;\n            } else {\n              currentContainer = void 0;\n              break;\n            }\n          }\n        }\n      }\n      if (!hasText || // if this is a plain element with a single text child, leave it\n      // as-is since the runtime has dedicated fast path for this by directly\n      // setting textContent of the element.\n      // for component root it's always normalized anyway.\n      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756\n      // custom directives can potentially add DOM elements arbitrarily,\n      // we need to avoid setting textContent of the element at runtime\n      // to avoid accidentally overwriting the DOM elements added\n      // by the user through custom directives.\n      !node.props.find(\n        (p) => p.type === 7 && !context.directiveTransforms[p.name]\n      ) && // in compat mode, <template> tags with no special directives\n      // will be rendered as a fragment so its children must be\n      // converted into vnodes.\n      !(node.tag === \"template\"))) {\n        return;\n      }\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (isText$1(child) || child.type === 8) {\n          const callArgs = [];\n          if (child.type !== 2 || child.content !== \" \") {\n            callArgs.push(child);\n          }\n          if (!context.ssr && getConstantType(child, context) === 0) {\n            callArgs.push(\n              1 + (``)\n            );\n          }\n          children[i] = {\n            type: 12,\n            content: child,\n            loc: child.loc,\n            codegenNode: createCallExpression(\n              context.helper(CREATE_TEXT),\n              callArgs\n            )\n          };\n        }\n      }\n    };\n  }\n};\n\nconst seen$1 = /* @__PURE__ */ new WeakSet();\nconst transformOnce = (node, context) => {\n  if (node.type === 1 && findDir(node, \"once\", true)) {\n    if (seen$1.has(node) || context.inVOnce || context.inSSR) {\n      return;\n    }\n    seen$1.add(node);\n    context.inVOnce = true;\n    context.helper(SET_BLOCK_TRACKING);\n    return () => {\n      context.inVOnce = false;\n      const cur = context.currentNode;\n      if (cur.codegenNode) {\n        cur.codegenNode = context.cache(\n          cur.codegenNode,\n          true\n          /* isVNode */\n        );\n      }\n    };\n  }\n};\n\nconst transformModel = (dir, node, context) => {\n  const { exp, arg } = dir;\n  if (!exp) {\n    context.onError(\n      createCompilerError(41, dir.loc)\n    );\n    return createTransformProps();\n  }\n  const rawExp = exp.loc.source;\n  const expString = exp.type === 4 ? exp.content : rawExp;\n  const bindingType = context.bindingMetadata[rawExp];\n  if (bindingType === \"props\" || bindingType === \"props-aliased\") {\n    context.onError(createCompilerError(44, exp.loc));\n    return createTransformProps();\n  }\n  const maybeRef = context.inline && (bindingType === \"setup-let\" || bindingType === \"setup-ref\" || bindingType === \"setup-maybe-ref\");\n  if (!expString.trim() || !isMemberExpression(expString, context) && !maybeRef) {\n    context.onError(\n      createCompilerError(42, exp.loc)\n    );\n    return createTransformProps();\n  }\n  if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {\n    context.onError(\n      createCompilerError(43, exp.loc)\n    );\n    return createTransformProps();\n  }\n  const propName = arg ? arg : createSimpleExpression(\"modelValue\", true);\n  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${shared.camelize(arg.content)}` : createCompoundExpression(['\"onUpdate:\" + ', arg]) : `onUpdate:modelValue`;\n  let assignmentExp;\n  const eventArg = context.isTS ? `($event: any)` : `$event`;\n  if (maybeRef) {\n    if (bindingType === \"setup-ref\") {\n      assignmentExp = createCompoundExpression([\n        `${eventArg} => ((`,\n        createSimpleExpression(rawExp, false, exp.loc),\n        `).value = $event)`\n      ]);\n    } else {\n      const altAssignment = bindingType === \"setup-let\" ? `${rawExp} = $event` : `null`;\n      assignmentExp = createCompoundExpression([\n        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,\n        createSimpleExpression(rawExp, false, exp.loc),\n        `).value = $event : ${altAssignment})`\n      ]);\n    }\n  } else {\n    assignmentExp = createCompoundExpression([\n      `${eventArg} => ((`,\n      exp,\n      `) = $event)`\n    ]);\n  }\n  const props = [\n    // modelValue: foo\n    createObjectProperty(propName, dir.exp),\n    // \"onUpdate:modelValue\": $event => (foo = $event)\n    createObjectProperty(eventName, assignmentExp)\n  ];\n  if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) {\n    props[1].value = context.cache(props[1].value);\n  }\n  if (dir.modifiers.length && node.tagType === 1) {\n    const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);\n    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + \"Modifiers\"']) : `modelModifiers`;\n    props.push(\n      createObjectProperty(\n        modifiersKey,\n        createSimpleExpression(\n          `{ ${modifiers} }`,\n          false,\n          dir.loc,\n          2\n        )\n      )\n    );\n  }\n  return createTransformProps(props);\n};\nfunction createTransformProps(props = []) {\n  return { props };\n}\n\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/;\nconst transformFilter = (node, context) => {\n  if (!isCompatEnabled(\"COMPILER_FILTER\", context)) {\n    return;\n  }\n  if (node.type === 5) {\n    rewriteFilter(node.content, context);\n  }\n  if (node.type === 1) {\n    node.props.forEach((prop) => {\n      if (prop.type === 7 && prop.name !== \"for\" && prop.exp) {\n        rewriteFilter(prop.exp, context);\n      }\n    });\n  }\n};\nfunction rewriteFilter(node, context) {\n  if (node.type === 4) {\n    parseFilter(node, context);\n  } else {\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n      if (typeof child !== \"object\")\n        continue;\n      if (child.type === 4) {\n        parseFilter(child, context);\n      } else if (child.type === 8) {\n        rewriteFilter(node, context);\n      } else if (child.type === 5) {\n        rewriteFilter(child.content, context);\n      }\n    }\n  }\n}\nfunction parseFilter(node, context) {\n  const exp = node.content;\n  let inSingle = false;\n  let inDouble = false;\n  let inTemplateString = false;\n  let inRegex = false;\n  let curly = 0;\n  let square = 0;\n  let paren = 0;\n  let lastFilterIndex = 0;\n  let c, prev, i, expression, filters = [];\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 39 && prev !== 92)\n        inSingle = false;\n    } else if (inDouble) {\n      if (c === 34 && prev !== 92)\n        inDouble = false;\n    } else if (inTemplateString) {\n      if (c === 96 && prev !== 92)\n        inTemplateString = false;\n    } else if (inRegex) {\n      if (c === 47 && prev !== 92)\n        inRegex = false;\n    } else if (c === 124 && // pipe\n    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {\n      if (expression === void 0) {\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 34:\n          inDouble = true;\n          break;\n        case 39:\n          inSingle = true;\n          break;\n        case 96:\n          inTemplateString = true;\n          break;\n        case 40:\n          paren++;\n          break;\n        case 41:\n          paren--;\n          break;\n        case 91:\n          square++;\n          break;\n        case 93:\n          square--;\n          break;\n        case 123:\n          curly++;\n          break;\n        case 125:\n          curly--;\n          break;\n      }\n      if (c === 47) {\n        let j = i - 1;\n        let p;\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== \" \")\n            break;\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n  if (expression === void 0) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n  function pushFilter() {\n    filters.push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n  if (filters.length) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i], context);\n    }\n    node.content = expression;\n  }\n}\nfunction wrapFilter(exp, filter, context) {\n  context.helper(RESOLVE_FILTER);\n  const i = filter.indexOf(\"(\");\n  if (i < 0) {\n    context.filters.add(filter);\n    return `${toValidAssetId(filter, \"filter\")}(${exp})`;\n  } else {\n    const name = filter.slice(0, i);\n    const args = filter.slice(i + 1);\n    context.filters.add(name);\n    return `${toValidAssetId(name, \"filter\")}(${exp}${args !== \")\" ? \",\" + args : args}`;\n  }\n}\n\nconst seen = /* @__PURE__ */ new WeakSet();\nconst transformMemo = (node, context) => {\n  if (node.type === 1) {\n    const dir = findDir(node, \"memo\");\n    if (!dir || seen.has(node)) {\n      return;\n    }\n    seen.add(node);\n    return () => {\n      const codegenNode = node.codegenNode || context.currentNode.codegenNode;\n      if (codegenNode && codegenNode.type === 13) {\n        if (node.tagType !== 1) {\n          convertToBlock(codegenNode, context);\n        }\n        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\n          dir.exp,\n          createFunctionExpression(void 0, codegenNode),\n          `_cache`,\n          String(context.cached++)\n        ]);\n      }\n    };\n  }\n};\n\nfunction getBaseTransformPreset(prefixIdentifiers) {\n  return [\n    [\n      transformOnce,\n      transformIf,\n      transformMemo,\n      transformFor,\n      ...[transformFilter] ,\n      ...prefixIdentifiers ? [\n        // order is important\n        trackVForSlotScopes,\n        transformExpression\n      ] : [],\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText\n    ],\n    {\n      on: transformOn,\n      bind: transformBind,\n      model: transformModel\n    }\n  ];\n}\nfunction baseCompile(template, options = {}) {\n  const onError = options.onError || defaultOnError;\n  const isModuleMode = options.mode === \"module\";\n  const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;\n  if (!prefixIdentifiers && options.cacheHandlers) {\n    onError(createCompilerError(49));\n  }\n  if (options.scopeId && !isModuleMode) {\n    onError(createCompilerError(50));\n  }\n  const ast = shared.isString(template) ? baseParse(template, options) : template;\n  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);\n  if (options.isTS) {\n    const { expressionPlugins } = options;\n    if (!expressionPlugins || !expressionPlugins.includes(\"typescript\")) {\n      options.expressionPlugins = [...expressionPlugins || [], \"typescript\"];\n    }\n  }\n  transform(\n    ast,\n    shared.extend({}, options, {\n      prefixIdentifiers,\n      nodeTransforms: [\n        ...nodeTransforms,\n        ...options.nodeTransforms || []\n        // user transforms\n      ],\n      directiveTransforms: shared.extend(\n        {},\n        directiveTransforms,\n        options.directiveTransforms || {}\n        // user transforms\n      )\n    })\n  );\n  return generate(\n    ast,\n    shared.extend({}, options, {\n      prefixIdentifiers\n    })\n  );\n}\n\nconst noopDirectiveTransform = () => ({ props: [] });\n\nexports.generateCodeFrame = shared.generateCodeFrame;\nexports.BASE_TRANSITION = BASE_TRANSITION;\nexports.CAMELIZE = CAMELIZE;\nexports.CAPITALIZE = CAPITALIZE;\nexports.CREATE_BLOCK = CREATE_BLOCK;\nexports.CREATE_COMMENT = CREATE_COMMENT;\nexports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;\nexports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;\nexports.CREATE_SLOTS = CREATE_SLOTS;\nexports.CREATE_STATIC = CREATE_STATIC;\nexports.CREATE_TEXT = CREATE_TEXT;\nexports.CREATE_VNODE = CREATE_VNODE;\nexports.FRAGMENT = FRAGMENT;\nexports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;\nexports.IS_MEMO_SAME = IS_MEMO_SAME;\nexports.IS_REF = IS_REF;\nexports.KEEP_ALIVE = KEEP_ALIVE;\nexports.MERGE_PROPS = MERGE_PROPS;\nexports.NORMALIZE_CLASS = NORMALIZE_CLASS;\nexports.NORMALIZE_PROPS = NORMALIZE_PROPS;\nexports.NORMALIZE_STYLE = NORMALIZE_STYLE;\nexports.OPEN_BLOCK = OPEN_BLOCK;\nexports.POP_SCOPE_ID = POP_SCOPE_ID;\nexports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;\nexports.RENDER_LIST = RENDER_LIST;\nexports.RENDER_SLOT = RENDER_SLOT;\nexports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;\nexports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;\nexports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;\nexports.RESOLVE_FILTER = RESOLVE_FILTER;\nexports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;\nexports.SUSPENSE = SUSPENSE;\nexports.TELEPORT = TELEPORT;\nexports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;\nexports.TO_HANDLERS = TO_HANDLERS;\nexports.TO_HANDLER_KEY = TO_HANDLER_KEY;\nexports.TS_NODE_TYPES = TS_NODE_TYPES;\nexports.UNREF = UNREF;\nexports.WITH_CTX = WITH_CTX;\nexports.WITH_DIRECTIVES = WITH_DIRECTIVES;\nexports.WITH_MEMO = WITH_MEMO;\nexports.advancePositionWithClone = advancePositionWithClone;\nexports.advancePositionWithMutation = advancePositionWithMutation;\nexports.assert = assert;\nexports.baseCompile = baseCompile;\nexports.baseParse = baseParse;\nexports.buildDirectiveArgs = buildDirectiveArgs;\nexports.buildProps = buildProps;\nexports.buildSlots = buildSlots;\nexports.checkCompatEnabled = checkCompatEnabled;\nexports.convertToBlock = convertToBlock;\nexports.createArrayExpression = createArrayExpression;\nexports.createAssignmentExpression = createAssignmentExpression;\nexports.createBlockStatement = createBlockStatement;\nexports.createCacheExpression = createCacheExpression;\nexports.createCallExpression = createCallExpression;\nexports.createCompilerError = createCompilerError;\nexports.createCompoundExpression = createCompoundExpression;\nexports.createConditionalExpression = createConditionalExpression;\nexports.createForLoopParams = createForLoopParams;\nexports.createFunctionExpression = createFunctionExpression;\nexports.createIfStatement = createIfStatement;\nexports.createInterpolation = createInterpolation;\nexports.createObjectExpression = createObjectExpression;\nexports.createObjectProperty = createObjectProperty;\nexports.createReturnStatement = createReturnStatement;\nexports.createRoot = createRoot;\nexports.createSequenceExpression = createSequenceExpression;\nexports.createSimpleExpression = createSimpleExpression;\nexports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;\nexports.createTemplateLiteral = createTemplateLiteral;\nexports.createTransformContext = createTransformContext;\nexports.createVNodeCall = createVNodeCall;\nexports.extractIdentifiers = extractIdentifiers;\nexports.findDir = findDir;\nexports.findProp = findProp;\nexports.forAliasRE = forAliasRE;\nexports.generate = generate;\nexports.getBaseTransformPreset = getBaseTransformPreset;\nexports.getConstantType = getConstantType;\nexports.getInnerRange = getInnerRange;\nexports.getMemoedVNodeCall = getMemoedVNodeCall;\nexports.getVNodeBlockHelper = getVNodeBlockHelper;\nexports.getVNodeHelper = getVNodeHelper;\nexports.hasDynamicKeyVBind = hasDynamicKeyVBind;\nexports.hasScopeRef = hasScopeRef;\nexports.helperNameMap = helperNameMap;\nexports.injectProp = injectProp;\nexports.isBuiltInType = isBuiltInType;\nexports.isCoreComponent = isCoreComponent;\nexports.isFunctionType = isFunctionType;\nexports.isInDestructureAssignment = isInDestructureAssignment;\nexports.isMemberExpression = isMemberExpression;\nexports.isMemberExpressionBrowser = isMemberExpressionBrowser;\nexports.isMemberExpressionNode = isMemberExpressionNode;\nexports.isReferencedIdentifier = isReferencedIdentifier;\nexports.isSimpleIdentifier = isSimpleIdentifier;\nexports.isSlotOutlet = isSlotOutlet;\nexports.isStaticArgOf = isStaticArgOf;\nexports.isStaticExp = isStaticExp;\nexports.isStaticProperty = isStaticProperty;\nexports.isStaticPropertyKey = isStaticPropertyKey;\nexports.isTemplateNode = isTemplateNode;\nexports.isText = isText$1;\nexports.isVSlot = isVSlot;\nexports.locStub = locStub;\nexports.noopDirectiveTransform = noopDirectiveTransform;\nexports.processExpression = processExpression;\nexports.processFor = processFor;\nexports.processIf = processIf;\nexports.processSlotOutlet = processSlotOutlet;\nexports.registerRuntimeHelpers = registerRuntimeHelpers;\nexports.resolveComponentType = resolveComponentType;\nexports.stringifyExpression = stringifyExpression;\nexports.toValidAssetId = toValidAssetId;\nexports.trackSlotScopes = trackSlotScopes;\nexports.trackVForSlotScopes = trackVForSlotScopes;\nexports.transform = transform;\nexports.transformBind = transformBind;\nexports.transformElement = transformElement;\nexports.transformExpression = transformExpression;\nexports.transformModel = transformModel;\nexports.transformOn = transformOn;\nexports.traverseNode = traverseNode;\nexports.walkBlockDeclarations = walkBlockDeclarations;\nexports.walkFunctionParams = walkFunctionParams;\nexports.walkIdentifiers = walkIdentifiers;\nexports.warnDeprecation = warnDeprecation;\n", "'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/compiler-core.cjs.prod.js')\n} else {\n  module.exports = require('./dist/compiler-core.cjs.js')\n}\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar compilerCore = require('@vue/compiler-core');\nvar shared = require('@vue/shared');\n\nconst V_MODEL_RADIO = Symbol(``);\nconst V_MODEL_CHECKBOX = Symbol(``);\nconst V_MODEL_TEXT = Symbol(``);\nconst V_MODEL_SELECT = Symbol(``);\nconst V_MODEL_DYNAMIC = Symbol(``);\nconst V_ON_WITH_MODIFIERS = Symbol(``);\nconst V_ON_WITH_KEYS = Symbol(``);\nconst V_SHOW = Symbol(``);\nconst TRANSITION = Symbol(``);\nconst TRANSITION_GROUP = Symbol(``);\ncompilerCore.registerRuntimeHelpers({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`,\n  [V_SHOW]: `vShow`,\n  [TRANSITION]: `Transition`,\n  [TRANSITION_GROUP]: `TransitionGroup`\n});\n\nvar namedCharacterReferences = {\n\tGT: \">\",\n\tgt: \">\",\n\tLT: \"<\",\n\tlt: \"<\",\n\t\"ac;\": \"\u223E\",\n\t\"af;\": \"\u2061\",\n\tAMP: \"&\",\n\tamp: \"&\",\n\t\"ap;\": \"\u2248\",\n\t\"DD;\": \"\u2145\",\n\t\"dd;\": \"\u2146\",\n\tdeg: \"\u00B0\",\n\t\"ee;\": \"\u2147\",\n\t\"eg;\": \"\u2A9A\",\n\t\"el;\": \"\u2A99\",\n\tETH: \"\u00D0\",\n\teth: \"\u00F0\",\n\t\"gE;\": \"\u2267\",\n\t\"ge;\": \"\u2265\",\n\t\"Gg;\": \"\u22D9\",\n\t\"gg;\": \"\u226B\",\n\t\"gl;\": \"\u2277\",\n\t\"GT;\": \">\",\n\t\"Gt;\": \"\u226B\",\n\t\"gt;\": \">\",\n\t\"ic;\": \"\u2063\",\n\t\"ii;\": \"\u2148\",\n\t\"Im;\": \"\u2111\",\n\t\"in;\": \"\u2208\",\n\t\"it;\": \"\u2062\",\n\t\"lE;\": \"\u2266\",\n\t\"le;\": \"\u2264\",\n\t\"lg;\": \"\u2276\",\n\t\"Ll;\": \"\u22D8\",\n\t\"ll;\": \"\u226A\",\n\t\"LT;\": \"<\",\n\t\"Lt;\": \"\u226A\",\n\t\"lt;\": \"<\",\n\t\"mp;\": \"\u2213\",\n\t\"Mu;\": \"\u039C\",\n\t\"mu;\": \"\u03BC\",\n\t\"ne;\": \"\u2260\",\n\t\"ni;\": \"\u220B\",\n\tnot: \"\u00AC\",\n\t\"Nu;\": \"\u039D\",\n\t\"nu;\": \"\u03BD\",\n\t\"Or;\": \"\u2A54\",\n\t\"or;\": \"\u2228\",\n\t\"oS;\": \"\u24C8\",\n\t\"Pi;\": \"\u03A0\",\n\t\"pi;\": \"\u03C0\",\n\t\"pm;\": \"\u00B1\",\n\t\"Pr;\": \"\u2ABB\",\n\t\"pr;\": \"\u227A\",\n\t\"Re;\": \"\u211C\",\n\tREG: \"\u00AE\",\n\treg: \"\u00AE\",\n\t\"rx;\": \"\u211E\",\n\t\"Sc;\": \"\u2ABC\",\n\t\"sc;\": \"\u227B\",\n\tshy: \"\u00AD\",\n\tuml: \"\u00A8\",\n\t\"wp;\": \"\u2118\",\n\t\"wr;\": \"\u2240\",\n\t\"Xi;\": \"\u039E\",\n\t\"xi;\": \"\u03BE\",\n\tyen: \"\u00A5\",\n\t\"acd;\": \"\u223F\",\n\t\"acE;\": \"\u223E\u0333\",\n\t\"Acy;\": \"\u0410\",\n\t\"acy;\": \"\u0430\",\n\t\"Afr;\": \"\uD835\uDD04\",\n\t\"afr;\": \"\uD835\uDD1E\",\n\t\"AMP;\": \"&\",\n\t\"amp;\": \"&\",\n\t\"And;\": \"\u2A53\",\n\t\"and;\": \"\u2227\",\n\t\"ang;\": \"\u2220\",\n\t\"apE;\": \"\u2A70\",\n\t\"ape;\": \"\u224A\",\n\t\"ast;\": \"*\",\n\tAuml: \"\u00C4\",\n\tauml: \"\u00E4\",\n\t\"Bcy;\": \"\u0411\",\n\t\"bcy;\": \"\u0431\",\n\t\"Bfr;\": \"\uD835\uDD05\",\n\t\"bfr;\": \"\uD835\uDD1F\",\n\t\"bne;\": \"=\u20E5\",\n\t\"bot;\": \"\u22A5\",\n\t\"Cap;\": \"\u22D2\",\n\t\"cap;\": \"\u2229\",\n\tcent: \"\u00A2\",\n\t\"Cfr;\": \"\u212D\",\n\t\"cfr;\": \"\uD835\uDD20\",\n\t\"Chi;\": \"\u03A7\",\n\t\"chi;\": \"\u03C7\",\n\t\"cir;\": \"\u25CB\",\n\tCOPY: \"\u00A9\",\n\tcopy: \"\u00A9\",\n\t\"Cup;\": \"\u22D3\",\n\t\"cup;\": \"\u222A\",\n\t\"Dcy;\": \"\u0414\",\n\t\"dcy;\": \"\u0434\",\n\t\"deg;\": \"\u00B0\",\n\t\"Del;\": \"\u2207\",\n\t\"Dfr;\": \"\uD835\uDD07\",\n\t\"dfr;\": \"\uD835\uDD21\",\n\t\"die;\": \"\u00A8\",\n\t\"div;\": \"\u00F7\",\n\t\"Dot;\": \"\u00A8\",\n\t\"dot;\": \"\u02D9\",\n\t\"Ecy;\": \"\u042D\",\n\t\"ecy;\": \"\u044D\",\n\t\"Efr;\": \"\uD835\uDD08\",\n\t\"efr;\": \"\uD835\uDD22\",\n\t\"egs;\": \"\u2A96\",\n\t\"ell;\": \"\u2113\",\n\t\"els;\": \"\u2A95\",\n\t\"ENG;\": \"\u014A\",\n\t\"eng;\": \"\u014B\",\n\t\"Eta;\": \"\u0397\",\n\t\"eta;\": \"\u03B7\",\n\t\"ETH;\": \"\u00D0\",\n\t\"eth;\": \"\u00F0\",\n\tEuml: \"\u00CB\",\n\teuml: \"\u00EB\",\n\t\"Fcy;\": \"\u0424\",\n\t\"fcy;\": \"\u0444\",\n\t\"Ffr;\": \"\uD835\uDD09\",\n\t\"ffr;\": \"\uD835\uDD23\",\n\t\"gap;\": \"\u2A86\",\n\t\"Gcy;\": \"\u0413\",\n\t\"gcy;\": \"\u0433\",\n\t\"gEl;\": \"\u2A8C\",\n\t\"gel;\": \"\u22DB\",\n\t\"geq;\": \"\u2265\",\n\t\"ges;\": \"\u2A7E\",\n\t\"Gfr;\": \"\uD835\uDD0A\",\n\t\"gfr;\": \"\uD835\uDD24\",\n\t\"ggg;\": \"\u22D9\",\n\t\"gla;\": \"\u2AA5\",\n\t\"glE;\": \"\u2A92\",\n\t\"glj;\": \"\u2AA4\",\n\t\"gnE;\": \"\u2269\",\n\t\"gne;\": \"\u2A88\",\n\t\"Hat;\": \"^\",\n\t\"Hfr;\": \"\u210C\",\n\t\"hfr;\": \"\uD835\uDD25\",\n\t\"Icy;\": \"\u0418\",\n\t\"icy;\": \"\u0438\",\n\t\"iff;\": \"\u21D4\",\n\t\"Ifr;\": \"\u2111\",\n\t\"ifr;\": \"\uD835\uDD26\",\n\t\"Int;\": \"\u222C\",\n\t\"int;\": \"\u222B\",\n\tIuml: \"\u00CF\",\n\tiuml: \"\u00EF\",\n\t\"Jcy;\": \"\u0419\",\n\t\"jcy;\": \"\u0439\",\n\t\"Jfr;\": \"\uD835\uDD0D\",\n\t\"jfr;\": \"\uD835\uDD27\",\n\t\"Kcy;\": \"\u041A\",\n\t\"kcy;\": \"\u043A\",\n\t\"Kfr;\": \"\uD835\uDD0E\",\n\t\"kfr;\": \"\uD835\uDD28\",\n\t\"lap;\": \"\u2A85\",\n\t\"lat;\": \"\u2AAB\",\n\t\"Lcy;\": \"\u041B\",\n\t\"lcy;\": \"\u043B\",\n\t\"lEg;\": \"\u2A8B\",\n\t\"leg;\": \"\u22DA\",\n\t\"leq;\": \"\u2264\",\n\t\"les;\": \"\u2A7D\",\n\t\"Lfr;\": \"\uD835\uDD0F\",\n\t\"lfr;\": \"\uD835\uDD29\",\n\t\"lgE;\": \"\u2A91\",\n\t\"lnE;\": \"\u2268\",\n\t\"lne;\": \"\u2A87\",\n\t\"loz;\": \"\u25CA\",\n\t\"lrm;\": \"\u200E\",\n\t\"Lsh;\": \"\u21B0\",\n\t\"lsh;\": \"\u21B0\",\n\tmacr: \"\u00AF\",\n\t\"Map;\": \"\u2905\",\n\t\"map;\": \"\u21A6\",\n\t\"Mcy;\": \"\u041C\",\n\t\"mcy;\": \"\u043C\",\n\t\"Mfr;\": \"\uD835\uDD10\",\n\t\"mfr;\": \"\uD835\uDD2A\",\n\t\"mho;\": \"\u2127\",\n\t\"mid;\": \"\u2223\",\n\t\"nap;\": \"\u2249\",\n\tnbsp: \"\u00A0\",\n\t\"Ncy;\": \"\u041D\",\n\t\"ncy;\": \"\u043D\",\n\t\"Nfr;\": \"\uD835\uDD11\",\n\t\"nfr;\": \"\uD835\uDD2B\",\n\t\"ngE;\": \"\u2267\u0338\",\n\t\"nge;\": \"\u2271\",\n\t\"nGg;\": \"\u22D9\u0338\",\n\t\"nGt;\": \"\u226B\u20D2\",\n\t\"ngt;\": \"\u226F\",\n\t\"nis;\": \"\u22FC\",\n\t\"niv;\": \"\u220B\",\n\t\"nlE;\": \"\u2266\u0338\",\n\t\"nle;\": \"\u2270\",\n\t\"nLl;\": \"\u22D8\u0338\",\n\t\"nLt;\": \"\u226A\u20D2\",\n\t\"nlt;\": \"\u226E\",\n\t\"Not;\": \"\u2AEC\",\n\t\"not;\": \"\u00AC\",\n\t\"npr;\": \"\u2280\",\n\t\"nsc;\": \"\u2281\",\n\t\"num;\": \"#\",\n\t\"Ocy;\": \"\u041E\",\n\t\"ocy;\": \"\u043E\",\n\t\"Ofr;\": \"\uD835\uDD12\",\n\t\"ofr;\": \"\uD835\uDD2C\",\n\t\"ogt;\": \"\u29C1\",\n\t\"ohm;\": \"\u03A9\",\n\t\"olt;\": \"\u29C0\",\n\t\"ord;\": \"\u2A5D\",\n\tordf: \"\u00AA\",\n\tordm: \"\u00BA\",\n\t\"orv;\": \"\u2A5B\",\n\tOuml: \"\u00D6\",\n\touml: \"\u00F6\",\n\t\"par;\": \"\u2225\",\n\tpara: \"\u00B6\",\n\t\"Pcy;\": \"\u041F\",\n\t\"pcy;\": \"\u043F\",\n\t\"Pfr;\": \"\uD835\uDD13\",\n\t\"pfr;\": \"\uD835\uDD2D\",\n\t\"Phi;\": \"\u03A6\",\n\t\"phi;\": \"\u03C6\",\n\t\"piv;\": \"\u03D6\",\n\t\"prE;\": \"\u2AB3\",\n\t\"pre;\": \"\u2AAF\",\n\t\"Psi;\": \"\u03A8\",\n\t\"psi;\": \"\u03C8\",\n\t\"Qfr;\": \"\uD835\uDD14\",\n\t\"qfr;\": \"\uD835\uDD2E\",\n\tQUOT: \"\\\"\",\n\tquot: \"\\\"\",\n\t\"Rcy;\": \"\u0420\",\n\t\"rcy;\": \"\u0440\",\n\t\"REG;\": \"\u00AE\",\n\t\"reg;\": \"\u00AE\",\n\t\"Rfr;\": \"\u211C\",\n\t\"rfr;\": \"\uD835\uDD2F\",\n\t\"Rho;\": \"\u03A1\",\n\t\"rho;\": \"\u03C1\",\n\t\"rlm;\": \"\u200F\",\n\t\"Rsh;\": \"\u21B1\",\n\t\"rsh;\": \"\u21B1\",\n\t\"scE;\": \"\u2AB4\",\n\t\"sce;\": \"\u2AB0\",\n\t\"Scy;\": \"\u0421\",\n\t\"scy;\": \"\u0441\",\n\tsect: \"\u00A7\",\n\t\"Sfr;\": \"\uD835\uDD16\",\n\t\"sfr;\": \"\uD835\uDD30\",\n\t\"shy;\": \"\u00AD\",\n\t\"sim;\": \"\u223C\",\n\t\"smt;\": \"\u2AAA\",\n\t\"sol;\": \"/\",\n\t\"squ;\": \"\u25A1\",\n\t\"Sub;\": \"\u22D0\",\n\t\"sub;\": \"\u2282\",\n\t\"Sum;\": \"\u2211\",\n\t\"sum;\": \"\u2211\",\n\t\"Sup;\": \"\u22D1\",\n\t\"sup;\": \"\u2283\",\n\tsup1: \"\u00B9\",\n\tsup2: \"\u00B2\",\n\tsup3: \"\u00B3\",\n\t\"Tab;\": \"\\t\",\n\t\"Tau;\": \"\u03A4\",\n\t\"tau;\": \"\u03C4\",\n\t\"Tcy;\": \"\u0422\",\n\t\"tcy;\": \"\u0442\",\n\t\"Tfr;\": \"\uD835\uDD17\",\n\t\"tfr;\": \"\uD835\uDD31\",\n\t\"top;\": \"\u22A4\",\n\t\"Ucy;\": \"\u0423\",\n\t\"ucy;\": \"\u0443\",\n\t\"Ufr;\": \"\uD835\uDD18\",\n\t\"ufr;\": \"\uD835\uDD32\",\n\t\"uml;\": \"\u00A8\",\n\tUuml: \"\u00DC\",\n\tuuml: \"\u00FC\",\n\t\"Vcy;\": \"\u0412\",\n\t\"vcy;\": \"\u0432\",\n\t\"Vee;\": \"\u22C1\",\n\t\"vee;\": \"\u2228\",\n\t\"Vfr;\": \"\uD835\uDD19\",\n\t\"vfr;\": \"\uD835\uDD33\",\n\t\"Wfr;\": \"\uD835\uDD1A\",\n\t\"wfr;\": \"\uD835\uDD34\",\n\t\"Xfr;\": \"\uD835\uDD1B\",\n\t\"xfr;\": \"\uD835\uDD35\",\n\t\"Ycy;\": \"\u042B\",\n\t\"ycy;\": \"\u044B\",\n\t\"yen;\": \"\u00A5\",\n\t\"Yfr;\": \"\uD835\uDD1C\",\n\t\"yfr;\": \"\uD835\uDD36\",\n\tyuml: \"\u00FF\",\n\t\"Zcy;\": \"\u0417\",\n\t\"zcy;\": \"\u0437\",\n\t\"Zfr;\": \"\u2128\",\n\t\"zfr;\": \"\uD835\uDD37\",\n\t\"zwj;\": \"\u200D\",\n\tAcirc: \"\u00C2\",\n\tacirc: \"\u00E2\",\n\tacute: \"\u00B4\",\n\tAElig: \"\u00C6\",\n\taelig: \"\u00E6\",\n\t\"andd;\": \"\u2A5C\",\n\t\"andv;\": \"\u2A5A\",\n\t\"ange;\": \"\u29A4\",\n\t\"Aopf;\": \"\uD835\uDD38\",\n\t\"aopf;\": \"\uD835\uDD52\",\n\t\"apid;\": \"\u224B\",\n\t\"apos;\": \"'\",\n\tAring: \"\u00C5\",\n\taring: \"\u00E5\",\n\t\"Ascr;\": \"\uD835\uDC9C\",\n\t\"ascr;\": \"\uD835\uDCB6\",\n\t\"Auml;\": \"\u00C4\",\n\t\"auml;\": \"\u00E4\",\n\t\"Barv;\": \"\u2AE7\",\n\t\"bbrk;\": \"\u23B5\",\n\t\"Beta;\": \"\u0392\",\n\t\"beta;\": \"\u03B2\",\n\t\"beth;\": \"\u2136\",\n\t\"bNot;\": \"\u2AED\",\n\t\"bnot;\": \"\u2310\",\n\t\"Bopf;\": \"\uD835\uDD39\",\n\t\"bopf;\": \"\uD835\uDD53\",\n\t\"boxH;\": \"\u2550\",\n\t\"boxh;\": \"\u2500\",\n\t\"boxV;\": \"\u2551\",\n\t\"boxv;\": \"\u2502\",\n\t\"Bscr;\": \"\u212C\",\n\t\"bscr;\": \"\uD835\uDCB7\",\n\t\"bsim;\": \"\u223D\",\n\t\"bsol;\": \"\\\\\",\n\t\"bull;\": \"\u2022\",\n\t\"bump;\": \"\u224E\",\n\t\"caps;\": \"\u2229\uFE00\",\n\t\"Cdot;\": \"\u010A\",\n\t\"cdot;\": \"\u010B\",\n\tcedil: \"\u00B8\",\n\t\"cent;\": \"\u00A2\",\n\t\"CHcy;\": \"\u0427\",\n\t\"chcy;\": \"\u0447\",\n\t\"circ;\": \"\u02C6\",\n\t\"cirE;\": \"\u29C3\",\n\t\"cire;\": \"\u2257\",\n\t\"comp;\": \"\u2201\",\n\t\"cong;\": \"\u2245\",\n\t\"Copf;\": \"\u2102\",\n\t\"copf;\": \"\uD835\uDD54\",\n\t\"COPY;\": \"\u00A9\",\n\t\"copy;\": \"\u00A9\",\n\t\"Cscr;\": \"\uD835\uDC9E\",\n\t\"cscr;\": \"\uD835\uDCB8\",\n\t\"csub;\": \"\u2ACF\",\n\t\"csup;\": \"\u2AD0\",\n\t\"cups;\": \"\u222A\uFE00\",\n\t\"Darr;\": \"\u21A1\",\n\t\"dArr;\": \"\u21D3\",\n\t\"darr;\": \"\u2193\",\n\t\"dash;\": \"\u2010\",\n\t\"dHar;\": \"\u2965\",\n\t\"diam;\": \"\u22C4\",\n\t\"DJcy;\": \"\u0402\",\n\t\"djcy;\": \"\u0452\",\n\t\"Dopf;\": \"\uD835\uDD3B\",\n\t\"dopf;\": \"\uD835\uDD55\",\n\t\"Dscr;\": \"\uD835\uDC9F\",\n\t\"dscr;\": \"\uD835\uDCB9\",\n\t\"DScy;\": \"\u0405\",\n\t\"dscy;\": \"\u0455\",\n\t\"dsol;\": \"\u29F6\",\n\t\"dtri;\": \"\u25BF\",\n\t\"DZcy;\": \"\u040F\",\n\t\"dzcy;\": \"\u045F\",\n\t\"ecir;\": \"\u2256\",\n\tEcirc: \"\u00CA\",\n\tecirc: \"\u00EA\",\n\t\"Edot;\": \"\u0116\",\n\t\"eDot;\": \"\u2251\",\n\t\"edot;\": \"\u0117\",\n\t\"emsp;\": \"\u2003\",\n\t\"ensp;\": \"\u2002\",\n\t\"Eopf;\": \"\uD835\uDD3C\",\n\t\"eopf;\": \"\uD835\uDD56\",\n\t\"epar;\": \"\u22D5\",\n\t\"epsi;\": \"\u03B5\",\n\t\"Escr;\": \"\u2130\",\n\t\"escr;\": \"\u212F\",\n\t\"Esim;\": \"\u2A73\",\n\t\"esim;\": \"\u2242\",\n\t\"Euml;\": \"\u00CB\",\n\t\"euml;\": \"\u00EB\",\n\t\"euro;\": \"\u20AC\",\n\t\"excl;\": \"!\",\n\t\"flat;\": \"\u266D\",\n\t\"fnof;\": \"\u0192\",\n\t\"Fopf;\": \"\uD835\uDD3D\",\n\t\"fopf;\": \"\uD835\uDD57\",\n\t\"fork;\": \"\u22D4\",\n\t\"Fscr;\": \"\u2131\",\n\t\"fscr;\": \"\uD835\uDCBB\",\n\t\"Gdot;\": \"\u0120\",\n\t\"gdot;\": \"\u0121\",\n\t\"geqq;\": \"\u2267\",\n\t\"gesl;\": \"\u22DB\uFE00\",\n\t\"GJcy;\": \"\u0403\",\n\t\"gjcy;\": \"\u0453\",\n\t\"gnap;\": \"\u2A8A\",\n\t\"gneq;\": \"\u2A88\",\n\t\"Gopf;\": \"\uD835\uDD3E\",\n\t\"gopf;\": \"\uD835\uDD58\",\n\t\"Gscr;\": \"\uD835\uDCA2\",\n\t\"gscr;\": \"\u210A\",\n\t\"gsim;\": \"\u2273\",\n\t\"gtcc;\": \"\u2AA7\",\n\t\"gvnE;\": \"\u2269\uFE00\",\n\t\"half;\": \"\u00BD\",\n\t\"hArr;\": \"\u21D4\",\n\t\"harr;\": \"\u2194\",\n\t\"hbar;\": \"\u210F\",\n\t\"Hopf;\": \"\u210D\",\n\t\"hopf;\": \"\uD835\uDD59\",\n\t\"Hscr;\": \"\u210B\",\n\t\"hscr;\": \"\uD835\uDCBD\",\n\tIcirc: \"\u00CE\",\n\ticirc: \"\u00EE\",\n\t\"Idot;\": \"\u0130\",\n\t\"IEcy;\": \"\u0415\",\n\t\"iecy;\": \"\u0435\",\n\tiexcl: \"\u00A1\",\n\t\"imof;\": \"\u22B7\",\n\t\"IOcy;\": \"\u0401\",\n\t\"iocy;\": \"\u0451\",\n\t\"Iopf;\": \"\uD835\uDD40\",\n\t\"iopf;\": \"\uD835\uDD5A\",\n\t\"Iota;\": \"\u0399\",\n\t\"iota;\": \"\u03B9\",\n\t\"Iscr;\": \"\u2110\",\n\t\"iscr;\": \"\uD835\uDCBE\",\n\t\"isin;\": \"\u2208\",\n\t\"Iuml;\": \"\u00CF\",\n\t\"iuml;\": \"\u00EF\",\n\t\"Jopf;\": \"\uD835\uDD41\",\n\t\"jopf;\": \"\uD835\uDD5B\",\n\t\"Jscr;\": \"\uD835\uDCA5\",\n\t\"jscr;\": \"\uD835\uDCBF\",\n\t\"KHcy;\": \"\u0425\",\n\t\"khcy;\": \"\u0445\",\n\t\"KJcy;\": \"\u040C\",\n\t\"kjcy;\": \"\u045C\",\n\t\"Kopf;\": \"\uD835\uDD42\",\n\t\"kopf;\": \"\uD835\uDD5C\",\n\t\"Kscr;\": \"\uD835\uDCA6\",\n\t\"kscr;\": \"\uD835\uDCC0\",\n\t\"Lang;\": \"\u27EA\",\n\t\"lang;\": \"\u27E8\",\n\tlaquo: \"\u00AB\",\n\t\"Larr;\": \"\u219E\",\n\t\"lArr;\": \"\u21D0\",\n\t\"larr;\": \"\u2190\",\n\t\"late;\": \"\u2AAD\",\n\t\"lcub;\": \"{\",\n\t\"ldca;\": \"\u2936\",\n\t\"ldsh;\": \"\u21B2\",\n\t\"leqq;\": \"\u2266\",\n\t\"lesg;\": \"\u22DA\uFE00\",\n\t\"lHar;\": \"\u2962\",\n\t\"LJcy;\": \"\u0409\",\n\t\"ljcy;\": \"\u0459\",\n\t\"lnap;\": \"\u2A89\",\n\t\"lneq;\": \"\u2A87\",\n\t\"Lopf;\": \"\uD835\uDD43\",\n\t\"lopf;\": \"\uD835\uDD5D\",\n\t\"lozf;\": \"\u29EB\",\n\t\"lpar;\": \"(\",\n\t\"Lscr;\": \"\u2112\",\n\t\"lscr;\": \"\uD835\uDCC1\",\n\t\"lsim;\": \"\u2272\",\n\t\"lsqb;\": \"[\",\n\t\"ltcc;\": \"\u2AA6\",\n\t\"ltri;\": \"\u25C3\",\n\t\"lvnE;\": \"\u2268\uFE00\",\n\t\"macr;\": \"\u00AF\",\n\t\"male;\": \"\u2642\",\n\t\"malt;\": \"\u2720\",\n\tmicro: \"\u00B5\",\n\t\"mlcp;\": \"\u2ADB\",\n\t\"mldr;\": \"\u2026\",\n\t\"Mopf;\": \"\uD835\uDD44\",\n\t\"mopf;\": \"\uD835\uDD5E\",\n\t\"Mscr;\": \"\u2133\",\n\t\"mscr;\": \"\uD835\uDCC2\",\n\t\"nang;\": \"\u2220\u20D2\",\n\t\"napE;\": \"\u2A70\u0338\",\n\t\"nbsp;\": \"\u00A0\",\n\t\"ncap;\": \"\u2A43\",\n\t\"ncup;\": \"\u2A42\",\n\t\"ngeq;\": \"\u2271\",\n\t\"nges;\": \"\u2A7E\u0338\",\n\t\"ngtr;\": \"\u226F\",\n\t\"nGtv;\": \"\u226B\u0338\",\n\t\"nisd;\": \"\u22FA\",\n\t\"NJcy;\": \"\u040A\",\n\t\"njcy;\": \"\u045A\",\n\t\"nldr;\": \"\u2025\",\n\t\"nleq;\": \"\u2270\",\n\t\"nles;\": \"\u2A7D\u0338\",\n\t\"nLtv;\": \"\u226A\u0338\",\n\t\"nmid;\": \"\u2224\",\n\t\"Nopf;\": \"\u2115\",\n\t\"nopf;\": \"\uD835\uDD5F\",\n\t\"npar;\": \"\u2226\",\n\t\"npre;\": \"\u2AAF\u0338\",\n\t\"nsce;\": \"\u2AB0\u0338\",\n\t\"Nscr;\": \"\uD835\uDCA9\",\n\t\"nscr;\": \"\uD835\uDCC3\",\n\t\"nsim;\": \"\u2241\",\n\t\"nsub;\": \"\u2284\",\n\t\"nsup;\": \"\u2285\",\n\t\"ntgl;\": \"\u2279\",\n\t\"ntlg;\": \"\u2278\",\n\t\"nvap;\": \"\u224D\u20D2\",\n\t\"nvge;\": \"\u2265\u20D2\",\n\t\"nvgt;\": \">\u20D2\",\n\t\"nvle;\": \"\u2264\u20D2\",\n\t\"nvlt;\": \"<\u20D2\",\n\t\"oast;\": \"\u229B\",\n\t\"ocir;\": \"\u229A\",\n\tOcirc: \"\u00D4\",\n\tocirc: \"\u00F4\",\n\t\"odiv;\": \"\u2A38\",\n\t\"odot;\": \"\u2299\",\n\t\"ogon;\": \"\u02DB\",\n\t\"oint;\": \"\u222E\",\n\t\"omid;\": \"\u29B6\",\n\t\"Oopf;\": \"\uD835\uDD46\",\n\t\"oopf;\": \"\uD835\uDD60\",\n\t\"opar;\": \"\u29B7\",\n\t\"ordf;\": \"\u00AA\",\n\t\"ordm;\": \"\u00BA\",\n\t\"oror;\": \"\u2A56\",\n\t\"Oscr;\": \"\uD835\uDCAA\",\n\t\"oscr;\": \"\u2134\",\n\t\"osol;\": \"\u2298\",\n\t\"Ouml;\": \"\u00D6\",\n\t\"ouml;\": \"\u00F6\",\n\t\"para;\": \"\u00B6\",\n\t\"part;\": \"\u2202\",\n\t\"perp;\": \"\u22A5\",\n\t\"phiv;\": \"\u03D5\",\n\t\"plus;\": \"+\",\n\t\"Popf;\": \"\u2119\",\n\t\"popf;\": \"\uD835\uDD61\",\n\tpound: \"\u00A3\",\n\t\"prap;\": \"\u2AB7\",\n\t\"prec;\": \"\u227A\",\n\t\"prnE;\": \"\u2AB5\",\n\t\"prod;\": \"\u220F\",\n\t\"prop;\": \"\u221D\",\n\t\"Pscr;\": \"\uD835\uDCAB\",\n\t\"pscr;\": \"\uD835\uDCC5\",\n\t\"qint;\": \"\u2A0C\",\n\t\"Qopf;\": \"\u211A\",\n\t\"qopf;\": \"\uD835\uDD62\",\n\t\"Qscr;\": \"\uD835\uDCAC\",\n\t\"qscr;\": \"\uD835\uDCC6\",\n\t\"QUOT;\": \"\\\"\",\n\t\"quot;\": \"\\\"\",\n\t\"race;\": \"\u223D\u0331\",\n\t\"Rang;\": \"\u27EB\",\n\t\"rang;\": \"\u27E9\",\n\traquo: \"\u00BB\",\n\t\"Rarr;\": \"\u21A0\",\n\t\"rArr;\": \"\u21D2\",\n\t\"rarr;\": \"\u2192\",\n\t\"rcub;\": \"}\",\n\t\"rdca;\": \"\u2937\",\n\t\"rdsh;\": \"\u21B3\",\n\t\"real;\": \"\u211C\",\n\t\"rect;\": \"\u25AD\",\n\t\"rHar;\": \"\u2964\",\n\t\"rhov;\": \"\u03F1\",\n\t\"ring;\": \"\u02DA\",\n\t\"Ropf;\": \"\u211D\",\n\t\"ropf;\": \"\uD835\uDD63\",\n\t\"rpar;\": \")\",\n\t\"Rscr;\": \"\u211B\",\n\t\"rscr;\": \"\uD835\uDCC7\",\n\t\"rsqb;\": \"]\",\n\t\"rtri;\": \"\u25B9\",\n\t\"scap;\": \"\u2AB8\",\n\t\"scnE;\": \"\u2AB6\",\n\t\"sdot;\": \"\u22C5\",\n\t\"sect;\": \"\u00A7\",\n\t\"semi;\": \";\",\n\t\"sext;\": \"\u2736\",\n\t\"SHcy;\": \"\u0428\",\n\t\"shcy;\": \"\u0448\",\n\t\"sime;\": \"\u2243\",\n\t\"simg;\": \"\u2A9E\",\n\t\"siml;\": \"\u2A9D\",\n\t\"smid;\": \"\u2223\",\n\t\"smte;\": \"\u2AAC\",\n\t\"solb;\": \"\u29C4\",\n\t\"Sopf;\": \"\uD835\uDD4A\",\n\t\"sopf;\": \"\uD835\uDD64\",\n\t\"spar;\": \"\u2225\",\n\t\"Sqrt;\": \"\u221A\",\n\t\"squf;\": \"\u25AA\",\n\t\"Sscr;\": \"\uD835\uDCAE\",\n\t\"sscr;\": \"\uD835\uDCC8\",\n\t\"Star;\": \"\u22C6\",\n\t\"star;\": \"\u2606\",\n\t\"subE;\": \"\u2AC5\",\n\t\"sube;\": \"\u2286\",\n\t\"succ;\": \"\u227B\",\n\t\"sung;\": \"\u266A\",\n\t\"sup1;\": \"\u00B9\",\n\t\"sup2;\": \"\u00B2\",\n\t\"sup3;\": \"\u00B3\",\n\t\"supE;\": \"\u2AC6\",\n\t\"supe;\": \"\u2287\",\n\tszlig: \"\u00DF\",\n\t\"tbrk;\": \"\u23B4\",\n\t\"tdot;\": \"\u20DB\",\n\tTHORN: \"\u00DE\",\n\tthorn: \"\u00FE\",\n\ttimes: \"\u00D7\",\n\t\"tint;\": \"\u222D\",\n\t\"toea;\": \"\u2928\",\n\t\"Topf;\": \"\uD835\uDD4B\",\n\t\"topf;\": \"\uD835\uDD65\",\n\t\"tosa;\": \"\u2929\",\n\t\"trie;\": \"\u225C\",\n\t\"Tscr;\": \"\uD835\uDCAF\",\n\t\"tscr;\": \"\uD835\uDCC9\",\n\t\"TScy;\": \"\u0426\",\n\t\"tscy;\": \"\u0446\",\n\t\"Uarr;\": \"\u219F\",\n\t\"uArr;\": \"\u21D1\",\n\t\"uarr;\": \"\u2191\",\n\tUcirc: \"\u00DB\",\n\tucirc: \"\u00FB\",\n\t\"uHar;\": \"\u2963\",\n\t\"Uopf;\": \"\uD835\uDD4C\",\n\t\"uopf;\": \"\uD835\uDD66\",\n\t\"Upsi;\": \"\u03D2\",\n\t\"upsi;\": \"\u03C5\",\n\t\"Uscr;\": \"\uD835\uDCB0\",\n\t\"uscr;\": \"\uD835\uDCCA\",\n\t\"utri;\": \"\u25B5\",\n\t\"Uuml;\": \"\u00DC\",\n\t\"uuml;\": \"\u00FC\",\n\t\"vArr;\": \"\u21D5\",\n\t\"varr;\": \"\u2195\",\n\t\"Vbar;\": \"\u2AEB\",\n\t\"vBar;\": \"\u2AE8\",\n\t\"Vert;\": \"\u2016\",\n\t\"vert;\": \"|\",\n\t\"Vopf;\": \"\uD835\uDD4D\",\n\t\"vopf;\": \"\uD835\uDD67\",\n\t\"Vscr;\": \"\uD835\uDCB1\",\n\t\"vscr;\": \"\uD835\uDCCB\",\n\t\"Wopf;\": \"\uD835\uDD4E\",\n\t\"wopf;\": \"\uD835\uDD68\",\n\t\"Wscr;\": \"\uD835\uDCB2\",\n\t\"wscr;\": \"\uD835\uDCCC\",\n\t\"xcap;\": \"\u22C2\",\n\t\"xcup;\": \"\u22C3\",\n\t\"xmap;\": \"\u27FC\",\n\t\"xnis;\": \"\u22FB\",\n\t\"Xopf;\": \"\uD835\uDD4F\",\n\t\"xopf;\": \"\uD835\uDD69\",\n\t\"Xscr;\": \"\uD835\uDCB3\",\n\t\"xscr;\": \"\uD835\uDCCD\",\n\t\"xvee;\": \"\u22C1\",\n\t\"YAcy;\": \"\u042F\",\n\t\"yacy;\": \"\u044F\",\n\t\"YIcy;\": \"\u0407\",\n\t\"yicy;\": \"\u0457\",\n\t\"Yopf;\": \"\uD835\uDD50\",\n\t\"yopf;\": \"\uD835\uDD6A\",\n\t\"Yscr;\": \"\uD835\uDCB4\",\n\t\"yscr;\": \"\uD835\uDCCE\",\n\t\"YUcy;\": \"\u042E\",\n\t\"yucy;\": \"\u044E\",\n\t\"Yuml;\": \"\u0178\",\n\t\"yuml;\": \"\u00FF\",\n\t\"Zdot;\": \"\u017B\",\n\t\"zdot;\": \"\u017C\",\n\t\"Zeta;\": \"\u0396\",\n\t\"zeta;\": \"\u03B6\",\n\t\"ZHcy;\": \"\u0416\",\n\t\"zhcy;\": \"\u0436\",\n\t\"Zopf;\": \"\u2124\",\n\t\"zopf;\": \"\uD835\uDD6B\",\n\t\"Zscr;\": \"\uD835\uDCB5\",\n\t\"zscr;\": \"\uD835\uDCCF\",\n\t\"zwnj;\": \"\u200C\",\n\tAacute: \"\u00C1\",\n\taacute: \"\u00E1\",\n\t\"Acirc;\": \"\u00C2\",\n\t\"acirc;\": \"\u00E2\",\n\t\"acute;\": \"\u00B4\",\n\t\"AElig;\": \"\u00C6\",\n\t\"aelig;\": \"\u00E6\",\n\tAgrave: \"\u00C0\",\n\tagrave: \"\u00E0\",\n\t\"aleph;\": \"\u2135\",\n\t\"Alpha;\": \"\u0391\",\n\t\"alpha;\": \"\u03B1\",\n\t\"Amacr;\": \"\u0100\",\n\t\"amacr;\": \"\u0101\",\n\t\"amalg;\": \"\u2A3F\",\n\t\"angle;\": \"\u2220\",\n\t\"angrt;\": \"\u221F\",\n\t\"angst;\": \"\u00C5\",\n\t\"Aogon;\": \"\u0104\",\n\t\"aogon;\": \"\u0105\",\n\t\"Aring;\": \"\u00C5\",\n\t\"aring;\": \"\u00E5\",\n\t\"asymp;\": \"\u2248\",\n\tAtilde: \"\u00C3\",\n\tatilde: \"\u00E3\",\n\t\"awint;\": \"\u2A11\",\n\t\"bcong;\": \"\u224C\",\n\t\"bdquo;\": \"\u201E\",\n\t\"bepsi;\": \"\u03F6\",\n\t\"blank;\": \"\u2423\",\n\t\"blk12;\": \"\u2592\",\n\t\"blk14;\": \"\u2591\",\n\t\"blk34;\": \"\u2593\",\n\t\"block;\": \"\u2588\",\n\t\"boxDL;\": \"\u2557\",\n\t\"boxDl;\": \"\u2556\",\n\t\"boxdL;\": \"\u2555\",\n\t\"boxdl;\": \"\u2510\",\n\t\"boxDR;\": \"\u2554\",\n\t\"boxDr;\": \"\u2553\",\n\t\"boxdR;\": \"\u2552\",\n\t\"boxdr;\": \"\u250C\",\n\t\"boxHD;\": \"\u2566\",\n\t\"boxHd;\": \"\u2564\",\n\t\"boxhD;\": \"\u2565\",\n\t\"boxhd;\": \"\u252C\",\n\t\"boxHU;\": \"\u2569\",\n\t\"boxHu;\": \"\u2567\",\n\t\"boxhU;\": \"\u2568\",\n\t\"boxhu;\": \"\u2534\",\n\t\"boxUL;\": \"\u255D\",\n\t\"boxUl;\": \"\u255C\",\n\t\"boxuL;\": \"\u255B\",\n\t\"boxul;\": \"\u2518\",\n\t\"boxUR;\": \"\u255A\",\n\t\"boxUr;\": \"\u2559\",\n\t\"boxuR;\": \"\u2558\",\n\t\"boxur;\": \"\u2514\",\n\t\"boxVH;\": \"\u256C\",\n\t\"boxVh;\": \"\u256B\",\n\t\"boxvH;\": \"\u256A\",\n\t\"boxvh;\": \"\u253C\",\n\t\"boxVL;\": \"\u2563\",\n\t\"boxVl;\": \"\u2562\",\n\t\"boxvL;\": \"\u2561\",\n\t\"boxvl;\": \"\u2524\",\n\t\"boxVR;\": \"\u2560\",\n\t\"boxVr;\": \"\u255F\",\n\t\"boxvR;\": \"\u255E\",\n\t\"boxvr;\": \"\u251C\",\n\t\"Breve;\": \"\u02D8\",\n\t\"breve;\": \"\u02D8\",\n\tbrvbar: \"\u00A6\",\n\t\"bsemi;\": \"\u204F\",\n\t\"bsime;\": \"\u22CD\",\n\t\"bsolb;\": \"\u29C5\",\n\t\"bumpE;\": \"\u2AAE\",\n\t\"bumpe;\": \"\u224F\",\n\t\"caret;\": \"\u2041\",\n\t\"caron;\": \"\u02C7\",\n\t\"ccaps;\": \"\u2A4D\",\n\tCcedil: \"\u00C7\",\n\tccedil: \"\u00E7\",\n\t\"Ccirc;\": \"\u0108\",\n\t\"ccirc;\": \"\u0109\",\n\t\"ccups;\": \"\u2A4C\",\n\t\"cedil;\": \"\u00B8\",\n\t\"check;\": \"\u2713\",\n\t\"clubs;\": \"\u2663\",\n\t\"Colon;\": \"\u2237\",\n\t\"colon;\": \":\",\n\t\"comma;\": \",\",\n\t\"crarr;\": \"\u21B5\",\n\t\"Cross;\": \"\u2A2F\",\n\t\"cross;\": \"\u2717\",\n\t\"csube;\": \"\u2AD1\",\n\t\"csupe;\": \"\u2AD2\",\n\t\"ctdot;\": \"\u22EF\",\n\t\"cuepr;\": \"\u22DE\",\n\t\"cuesc;\": \"\u22DF\",\n\t\"cupor;\": \"\u2A45\",\n\tcurren: \"\u00A4\",\n\t\"cuvee;\": \"\u22CE\",\n\t\"cuwed;\": \"\u22CF\",\n\t\"cwint;\": \"\u2231\",\n\t\"Dashv;\": \"\u2AE4\",\n\t\"dashv;\": \"\u22A3\",\n\t\"dblac;\": \"\u02DD\",\n\t\"ddarr;\": \"\u21CA\",\n\t\"Delta;\": \"\u0394\",\n\t\"delta;\": \"\u03B4\",\n\t\"dharl;\": \"\u21C3\",\n\t\"dharr;\": \"\u21C2\",\n\t\"diams;\": \"\u2666\",\n\t\"disin;\": \"\u22F2\",\n\tdivide: \"\u00F7\",\n\t\"doteq;\": \"\u2250\",\n\t\"dtdot;\": \"\u22F1\",\n\t\"dtrif;\": \"\u25BE\",\n\t\"duarr;\": \"\u21F5\",\n\t\"duhar;\": \"\u296F\",\n\tEacute: \"\u00C9\",\n\teacute: \"\u00E9\",\n\t\"Ecirc;\": \"\u00CA\",\n\t\"ecirc;\": \"\u00EA\",\n\t\"eDDot;\": \"\u2A77\",\n\t\"efDot;\": \"\u2252\",\n\tEgrave: \"\u00C8\",\n\tegrave: \"\u00E8\",\n\t\"Emacr;\": \"\u0112\",\n\t\"emacr;\": \"\u0113\",\n\t\"empty;\": \"\u2205\",\n\t\"Eogon;\": \"\u0118\",\n\t\"eogon;\": \"\u0119\",\n\t\"eplus;\": \"\u2A71\",\n\t\"epsiv;\": \"\u03F5\",\n\t\"eqsim;\": \"\u2242\",\n\t\"Equal;\": \"\u2A75\",\n\t\"equiv;\": \"\u2261\",\n\t\"erarr;\": \"\u2971\",\n\t\"erDot;\": \"\u2253\",\n\t\"esdot;\": \"\u2250\",\n\t\"exist;\": \"\u2203\",\n\t\"fflig;\": \"\uFB00\",\n\t\"filig;\": \"\uFB01\",\n\t\"fjlig;\": \"fj\",\n\t\"fllig;\": \"\uFB02\",\n\t\"fltns;\": \"\u25B1\",\n\t\"forkv;\": \"\u2AD9\",\n\tfrac12: \"\u00BD\",\n\tfrac14: \"\u00BC\",\n\tfrac34: \"\u00BE\",\n\t\"frasl;\": \"\u2044\",\n\t\"frown;\": \"\u2322\",\n\t\"Gamma;\": \"\u0393\",\n\t\"gamma;\": \"\u03B3\",\n\t\"Gcirc;\": \"\u011C\",\n\t\"gcirc;\": \"\u011D\",\n\t\"gescc;\": \"\u2AA9\",\n\t\"gimel;\": \"\u2137\",\n\t\"gneqq;\": \"\u2269\",\n\t\"gnsim;\": \"\u22E7\",\n\t\"grave;\": \"`\",\n\t\"gsime;\": \"\u2A8E\",\n\t\"gsiml;\": \"\u2A90\",\n\t\"gtcir;\": \"\u2A7A\",\n\t\"gtdot;\": \"\u22D7\",\n\t\"Hacek;\": \"\u02C7\",\n\t\"harrw;\": \"\u21AD\",\n\t\"Hcirc;\": \"\u0124\",\n\t\"hcirc;\": \"\u0125\",\n\t\"hoarr;\": \"\u21FF\",\n\tIacute: \"\u00CD\",\n\tiacute: \"\u00ED\",\n\t\"Icirc;\": \"\u00CE\",\n\t\"icirc;\": \"\u00EE\",\n\t\"iexcl;\": \"\u00A1\",\n\tIgrave: \"\u00CC\",\n\tigrave: \"\u00EC\",\n\t\"iiint;\": \"\u222D\",\n\t\"iiota;\": \"\u2129\",\n\t\"IJlig;\": \"\u0132\",\n\t\"ijlig;\": \"\u0133\",\n\t\"Imacr;\": \"\u012A\",\n\t\"imacr;\": \"\u012B\",\n\t\"image;\": \"\u2111\",\n\t\"imath;\": \"\u0131\",\n\t\"imped;\": \"\u01B5\",\n\t\"infin;\": \"\u221E\",\n\t\"Iogon;\": \"\u012E\",\n\t\"iogon;\": \"\u012F\",\n\t\"iprod;\": \"\u2A3C\",\n\tiquest: \"\u00BF\",\n\t\"isinE;\": \"\u22F9\",\n\t\"isins;\": \"\u22F4\",\n\t\"isinv;\": \"\u2208\",\n\t\"Iukcy;\": \"\u0406\",\n\t\"iukcy;\": \"\u0456\",\n\t\"Jcirc;\": \"\u0134\",\n\t\"jcirc;\": \"\u0135\",\n\t\"jmath;\": \"\u0237\",\n\t\"Jukcy;\": \"\u0404\",\n\t\"jukcy;\": \"\u0454\",\n\t\"Kappa;\": \"\u039A\",\n\t\"kappa;\": \"\u03BA\",\n\t\"lAarr;\": \"\u21DA\",\n\t\"langd;\": \"\u2991\",\n\t\"laquo;\": \"\u00AB\",\n\t\"larrb;\": \"\u21E4\",\n\t\"lates;\": \"\u2AAD\uFE00\",\n\t\"lBarr;\": \"\u290E\",\n\t\"lbarr;\": \"\u290C\",\n\t\"lbbrk;\": \"\u2772\",\n\t\"lbrke;\": \"\u298B\",\n\t\"lceil;\": \"\u2308\",\n\t\"ldquo;\": \"\u201C\",\n\t\"lescc;\": \"\u2AA8\",\n\t\"lhard;\": \"\u21BD\",\n\t\"lharu;\": \"\u21BC\",\n\t\"lhblk;\": \"\u2584\",\n\t\"llarr;\": \"\u21C7\",\n\t\"lltri;\": \"\u25FA\",\n\t\"lneqq;\": \"\u2268\",\n\t\"lnsim;\": \"\u22E6\",\n\t\"loang;\": \"\u27EC\",\n\t\"loarr;\": \"\u21FD\",\n\t\"lobrk;\": \"\u27E6\",\n\t\"lopar;\": \"\u2985\",\n\t\"lrarr;\": \"\u21C6\",\n\t\"lrhar;\": \"\u21CB\",\n\t\"lrtri;\": \"\u22BF\",\n\t\"lsime;\": \"\u2A8D\",\n\t\"lsimg;\": \"\u2A8F\",\n\t\"lsquo;\": \"\u2018\",\n\t\"ltcir;\": \"\u2A79\",\n\t\"ltdot;\": \"\u22D6\",\n\t\"ltrie;\": \"\u22B4\",\n\t\"ltrif;\": \"\u25C2\",\n\t\"mdash;\": \"\u2014\",\n\t\"mDDot;\": \"\u223A\",\n\t\"micro;\": \"\u00B5\",\n\tmiddot: \"\u00B7\",\n\t\"minus;\": \"\u2212\",\n\t\"mumap;\": \"\u22B8\",\n\t\"nabla;\": \"\u2207\",\n\t\"napid;\": \"\u224B\u0338\",\n\t\"napos;\": \"\u0149\",\n\t\"natur;\": \"\u266E\",\n\t\"nbump;\": \"\u224E\u0338\",\n\t\"ncong;\": \"\u2247\",\n\t\"ndash;\": \"\u2013\",\n\t\"neArr;\": \"\u21D7\",\n\t\"nearr;\": \"\u2197\",\n\t\"nedot;\": \"\u2250\u0338\",\n\t\"nesim;\": \"\u2242\u0338\",\n\t\"ngeqq;\": \"\u2267\u0338\",\n\t\"ngsim;\": \"\u2275\",\n\t\"nhArr;\": \"\u21CE\",\n\t\"nharr;\": \"\u21AE\",\n\t\"nhpar;\": \"\u2AF2\",\n\t\"nlArr;\": \"\u21CD\",\n\t\"nlarr;\": \"\u219A\",\n\t\"nleqq;\": \"\u2266\u0338\",\n\t\"nless;\": \"\u226E\",\n\t\"nlsim;\": \"\u2274\",\n\t\"nltri;\": \"\u22EA\",\n\t\"notin;\": \"\u2209\",\n\t\"notni;\": \"\u220C\",\n\t\"npart;\": \"\u2202\u0338\",\n\t\"nprec;\": \"\u2280\",\n\t\"nrArr;\": \"\u21CF\",\n\t\"nrarr;\": \"\u219B\",\n\t\"nrtri;\": \"\u22EB\",\n\t\"nsime;\": \"\u2244\",\n\t\"nsmid;\": \"\u2224\",\n\t\"nspar;\": \"\u2226\",\n\t\"nsubE;\": \"\u2AC5\u0338\",\n\t\"nsube;\": \"\u2288\",\n\t\"nsucc;\": \"\u2281\",\n\t\"nsupE;\": \"\u2AC6\u0338\",\n\t\"nsupe;\": \"\u2289\",\n\tNtilde: \"\u00D1\",\n\tntilde: \"\u00F1\",\n\t\"numsp;\": \"\u2007\",\n\t\"nvsim;\": \"\u223C\u20D2\",\n\t\"nwArr;\": \"\u21D6\",\n\t\"nwarr;\": \"\u2196\",\n\tOacute: \"\u00D3\",\n\toacute: \"\u00F3\",\n\t\"Ocirc;\": \"\u00D4\",\n\t\"ocirc;\": \"\u00F4\",\n\t\"odash;\": \"\u229D\",\n\t\"OElig;\": \"\u0152\",\n\t\"oelig;\": \"\u0153\",\n\t\"ofcir;\": \"\u29BF\",\n\tOgrave: \"\u00D2\",\n\tograve: \"\u00F2\",\n\t\"ohbar;\": \"\u29B5\",\n\t\"olarr;\": \"\u21BA\",\n\t\"olcir;\": \"\u29BE\",\n\t\"oline;\": \"\u203E\",\n\t\"Omacr;\": \"\u014C\",\n\t\"omacr;\": \"\u014D\",\n\t\"Omega;\": \"\u03A9\",\n\t\"omega;\": \"\u03C9\",\n\t\"operp;\": \"\u29B9\",\n\t\"oplus;\": \"\u2295\",\n\t\"orarr;\": \"\u21BB\",\n\t\"order;\": \"\u2134\",\n\tOslash: \"\u00D8\",\n\toslash: \"\u00F8\",\n\tOtilde: \"\u00D5\",\n\totilde: \"\u00F5\",\n\t\"ovbar;\": \"\u233D\",\n\t\"parsl;\": \"\u2AFD\",\n\t\"phone;\": \"\u260E\",\n\t\"plusb;\": \"\u229E\",\n\t\"pluse;\": \"\u2A72\",\n\tplusmn: \"\u00B1\",\n\t\"pound;\": \"\u00A3\",\n\t\"prcue;\": \"\u227C\",\n\t\"Prime;\": \"\u2033\",\n\t\"prime;\": \"\u2032\",\n\t\"prnap;\": \"\u2AB9\",\n\t\"prsim;\": \"\u227E\",\n\t\"quest;\": \"?\",\n\t\"rAarr;\": \"\u21DB\",\n\t\"radic;\": \"\u221A\",\n\t\"rangd;\": \"\u2992\",\n\t\"range;\": \"\u29A5\",\n\t\"raquo;\": \"\u00BB\",\n\t\"rarrb;\": \"\u21E5\",\n\t\"rarrc;\": \"\u2933\",\n\t\"rarrw;\": \"\u219D\",\n\t\"ratio;\": \"\u2236\",\n\t\"RBarr;\": \"\u2910\",\n\t\"rBarr;\": \"\u290F\",\n\t\"rbarr;\": \"\u290D\",\n\t\"rbbrk;\": \"\u2773\",\n\t\"rbrke;\": \"\u298C\",\n\t\"rceil;\": \"\u2309\",\n\t\"rdquo;\": \"\u201D\",\n\t\"reals;\": \"\u211D\",\n\t\"rhard;\": \"\u21C1\",\n\t\"rharu;\": \"\u21C0\",\n\t\"rlarr;\": \"\u21C4\",\n\t\"rlhar;\": \"\u21CC\",\n\t\"rnmid;\": \"\u2AEE\",\n\t\"roang;\": \"\u27ED\",\n\t\"roarr;\": \"\u21FE\",\n\t\"robrk;\": \"\u27E7\",\n\t\"ropar;\": \"\u2986\",\n\t\"rrarr;\": \"\u21C9\",\n\t\"rsquo;\": \"\u2019\",\n\t\"rtrie;\": \"\u22B5\",\n\t\"rtrif;\": \"\u25B8\",\n\t\"sbquo;\": \"\u201A\",\n\t\"sccue;\": \"\u227D\",\n\t\"Scirc;\": \"\u015C\",\n\t\"scirc;\": \"\u015D\",\n\t\"scnap;\": \"\u2ABA\",\n\t\"scsim;\": \"\u227F\",\n\t\"sdotb;\": \"\u22A1\",\n\t\"sdote;\": \"\u2A66\",\n\t\"seArr;\": \"\u21D8\",\n\t\"searr;\": \"\u2198\",\n\t\"setmn;\": \"\u2216\",\n\t\"sharp;\": \"\u266F\",\n\t\"Sigma;\": \"\u03A3\",\n\t\"sigma;\": \"\u03C3\",\n\t\"simeq;\": \"\u2243\",\n\t\"simgE;\": \"\u2AA0\",\n\t\"simlE;\": \"\u2A9F\",\n\t\"simne;\": \"\u2246\",\n\t\"slarr;\": \"\u2190\",\n\t\"smile;\": \"\u2323\",\n\t\"smtes;\": \"\u2AAC\uFE00\",\n\t\"sqcap;\": \"\u2293\",\n\t\"sqcup;\": \"\u2294\",\n\t\"sqsub;\": \"\u228F\",\n\t\"sqsup;\": \"\u2290\",\n\t\"srarr;\": \"\u2192\",\n\t\"starf;\": \"\u2605\",\n\t\"strns;\": \"\u00AF\",\n\t\"subnE;\": \"\u2ACB\",\n\t\"subne;\": \"\u228A\",\n\t\"supnE;\": \"\u2ACC\",\n\t\"supne;\": \"\u228B\",\n\t\"swArr;\": \"\u21D9\",\n\t\"swarr;\": \"\u2199\",\n\t\"szlig;\": \"\u00DF\",\n\t\"Theta;\": \"\u0398\",\n\t\"theta;\": \"\u03B8\",\n\t\"thkap;\": \"\u2248\",\n\t\"THORN;\": \"\u00DE\",\n\t\"thorn;\": \"\u00FE\",\n\t\"Tilde;\": \"\u223C\",\n\t\"tilde;\": \"\u02DC\",\n\t\"times;\": \"\u00D7\",\n\t\"TRADE;\": \"\u2122\",\n\t\"trade;\": \"\u2122\",\n\t\"trisb;\": \"\u29CD\",\n\t\"TSHcy;\": \"\u040B\",\n\t\"tshcy;\": \"\u045B\",\n\t\"twixt;\": \"\u226C\",\n\tUacute: \"\u00DA\",\n\tuacute: \"\u00FA\",\n\t\"Ubrcy;\": \"\u040E\",\n\t\"ubrcy;\": \"\u045E\",\n\t\"Ucirc;\": \"\u00DB\",\n\t\"ucirc;\": \"\u00FB\",\n\t\"udarr;\": \"\u21C5\",\n\t\"udhar;\": \"\u296E\",\n\tUgrave: \"\u00D9\",\n\tugrave: \"\u00F9\",\n\t\"uharl;\": \"\u21BF\",\n\t\"uharr;\": \"\u21BE\",\n\t\"uhblk;\": \"\u2580\",\n\t\"ultri;\": \"\u25F8\",\n\t\"Umacr;\": \"\u016A\",\n\t\"umacr;\": \"\u016B\",\n\t\"Union;\": \"\u22C3\",\n\t\"Uogon;\": \"\u0172\",\n\t\"uogon;\": \"\u0173\",\n\t\"uplus;\": \"\u228E\",\n\t\"upsih;\": \"\u03D2\",\n\t\"UpTee;\": \"\u22A5\",\n\t\"Uring;\": \"\u016E\",\n\t\"uring;\": \"\u016F\",\n\t\"urtri;\": \"\u25F9\",\n\t\"utdot;\": \"\u22F0\",\n\t\"utrif;\": \"\u25B4\",\n\t\"uuarr;\": \"\u21C8\",\n\t\"varpi;\": \"\u03D6\",\n\t\"vBarv;\": \"\u2AE9\",\n\t\"VDash;\": \"\u22AB\",\n\t\"Vdash;\": \"\u22A9\",\n\t\"vDash;\": \"\u22A8\",\n\t\"vdash;\": \"\u22A2\",\n\t\"veeeq;\": \"\u225A\",\n\t\"vltri;\": \"\u22B2\",\n\t\"vnsub;\": \"\u2282\u20D2\",\n\t\"vnsup;\": \"\u2283\u20D2\",\n\t\"vprop;\": \"\u221D\",\n\t\"vrtri;\": \"\u22B3\",\n\t\"Wcirc;\": \"\u0174\",\n\t\"wcirc;\": \"\u0175\",\n\t\"Wedge;\": \"\u22C0\",\n\t\"wedge;\": \"\u2227\",\n\t\"xcirc;\": \"\u25EF\",\n\t\"xdtri;\": \"\u25BD\",\n\t\"xhArr;\": \"\u27FA\",\n\t\"xharr;\": \"\u27F7\",\n\t\"xlArr;\": \"\u27F8\",\n\t\"xlarr;\": \"\u27F5\",\n\t\"xodot;\": \"\u2A00\",\n\t\"xrArr;\": \"\u27F9\",\n\t\"xrarr;\": \"\u27F6\",\n\t\"xutri;\": \"\u25B3\",\n\tYacute: \"\u00DD\",\n\tyacute: \"\u00FD\",\n\t\"Ycirc;\": \"\u0176\",\n\t\"ycirc;\": \"\u0177\",\n\t\"Aacute;\": \"\u00C1\",\n\t\"aacute;\": \"\u00E1\",\n\t\"Abreve;\": \"\u0102\",\n\t\"abreve;\": \"\u0103\",\n\t\"Agrave;\": \"\u00C0\",\n\t\"agrave;\": \"\u00E0\",\n\t\"andand;\": \"\u2A55\",\n\t\"angmsd;\": \"\u2221\",\n\t\"angsph;\": \"\u2222\",\n\t\"apacir;\": \"\u2A6F\",\n\t\"approx;\": \"\u2248\",\n\t\"Assign;\": \"\u2254\",\n\t\"Atilde;\": \"\u00C3\",\n\t\"atilde;\": \"\u00E3\",\n\t\"barvee;\": \"\u22BD\",\n\t\"Barwed;\": \"\u2306\",\n\t\"barwed;\": \"\u2305\",\n\t\"becaus;\": \"\u2235\",\n\t\"bernou;\": \"\u212C\",\n\t\"bigcap;\": \"\u22C2\",\n\t\"bigcup;\": \"\u22C3\",\n\t\"bigvee;\": \"\u22C1\",\n\t\"bkarow;\": \"\u290D\",\n\t\"bottom;\": \"\u22A5\",\n\t\"bowtie;\": \"\u22C8\",\n\t\"boxbox;\": \"\u29C9\",\n\t\"bprime;\": \"\u2035\",\n\t\"brvbar;\": \"\u00A6\",\n\t\"bullet;\": \"\u2022\",\n\t\"Bumpeq;\": \"\u224E\",\n\t\"bumpeq;\": \"\u224F\",\n\t\"Cacute;\": \"\u0106\",\n\t\"cacute;\": \"\u0107\",\n\t\"capand;\": \"\u2A44\",\n\t\"capcap;\": \"\u2A4B\",\n\t\"capcup;\": \"\u2A47\",\n\t\"capdot;\": \"\u2A40\",\n\t\"Ccaron;\": \"\u010C\",\n\t\"ccaron;\": \"\u010D\",\n\t\"Ccedil;\": \"\u00C7\",\n\t\"ccedil;\": \"\u00E7\",\n\t\"circeq;\": \"\u2257\",\n\t\"cirmid;\": \"\u2AEF\",\n\t\"Colone;\": \"\u2A74\",\n\t\"colone;\": \"\u2254\",\n\t\"commat;\": \"@\",\n\t\"compfn;\": \"\u2218\",\n\t\"Conint;\": \"\u222F\",\n\t\"conint;\": \"\u222E\",\n\t\"coprod;\": \"\u2210\",\n\t\"copysr;\": \"\u2117\",\n\t\"cularr;\": \"\u21B6\",\n\t\"CupCap;\": \"\u224D\",\n\t\"cupcap;\": \"\u2A46\",\n\t\"cupcup;\": \"\u2A4A\",\n\t\"cupdot;\": \"\u228D\",\n\t\"curarr;\": \"\u21B7\",\n\t\"curren;\": \"\u00A4\",\n\t\"cylcty;\": \"\u232D\",\n\t\"Dagger;\": \"\u2021\",\n\t\"dagger;\": \"\u2020\",\n\t\"daleth;\": \"\u2138\",\n\t\"Dcaron;\": \"\u010E\",\n\t\"dcaron;\": \"\u010F\",\n\t\"dfisht;\": \"\u297F\",\n\t\"divide;\": \"\u00F7\",\n\t\"divonx;\": \"\u22C7\",\n\t\"dlcorn;\": \"\u231E\",\n\t\"dlcrop;\": \"\u230D\",\n\t\"dollar;\": \"$\",\n\t\"DotDot;\": \"\u20DC\",\n\t\"drcorn;\": \"\u231F\",\n\t\"drcrop;\": \"\u230C\",\n\t\"Dstrok;\": \"\u0110\",\n\t\"dstrok;\": \"\u0111\",\n\t\"Eacute;\": \"\u00C9\",\n\t\"eacute;\": \"\u00E9\",\n\t\"easter;\": \"\u2A6E\",\n\t\"Ecaron;\": \"\u011A\",\n\t\"ecaron;\": \"\u011B\",\n\t\"ecolon;\": \"\u2255\",\n\t\"Egrave;\": \"\u00C8\",\n\t\"egrave;\": \"\u00E8\",\n\t\"egsdot;\": \"\u2A98\",\n\t\"elsdot;\": \"\u2A97\",\n\t\"emptyv;\": \"\u2205\",\n\t\"emsp13;\": \"\u2004\",\n\t\"emsp14;\": \"\u2005\",\n\t\"eparsl;\": \"\u29E3\",\n\t\"eqcirc;\": \"\u2256\",\n\t\"equals;\": \"=\",\n\t\"equest;\": \"\u225F\",\n\t\"Exists;\": \"\u2203\",\n\t\"female;\": \"\u2640\",\n\t\"ffilig;\": \"\uFB03\",\n\t\"ffllig;\": \"\uFB04\",\n\t\"ForAll;\": \"\u2200\",\n\t\"forall;\": \"\u2200\",\n\t\"frac12;\": \"\u00BD\",\n\t\"frac13;\": \"\u2153\",\n\t\"frac14;\": \"\u00BC\",\n\t\"frac15;\": \"\u2155\",\n\t\"frac16;\": \"\u2159\",\n\t\"frac18;\": \"\u215B\",\n\t\"frac23;\": \"\u2154\",\n\t\"frac25;\": \"\u2156\",\n\t\"frac34;\": \"\u00BE\",\n\t\"frac35;\": \"\u2157\",\n\t\"frac38;\": \"\u215C\",\n\t\"frac45;\": \"\u2158\",\n\t\"frac56;\": \"\u215A\",\n\t\"frac58;\": \"\u215D\",\n\t\"frac78;\": \"\u215E\",\n\t\"gacute;\": \"\u01F5\",\n\t\"Gammad;\": \"\u03DC\",\n\t\"gammad;\": \"\u03DD\",\n\t\"Gbreve;\": \"\u011E\",\n\t\"gbreve;\": \"\u011F\",\n\t\"Gcedil;\": \"\u0122\",\n\t\"gesdot;\": \"\u2A80\",\n\t\"gesles;\": \"\u2A94\",\n\t\"gtlPar;\": \"\u2995\",\n\t\"gtrarr;\": \"\u2978\",\n\t\"gtrdot;\": \"\u22D7\",\n\t\"gtrsim;\": \"\u2273\",\n\t\"hairsp;\": \"\u200A\",\n\t\"hamilt;\": \"\u210B\",\n\t\"HARDcy;\": \"\u042A\",\n\t\"hardcy;\": \"\u044A\",\n\t\"hearts;\": \"\u2665\",\n\t\"hellip;\": \"\u2026\",\n\t\"hercon;\": \"\u22B9\",\n\t\"homtht;\": \"\u223B\",\n\t\"horbar;\": \"\u2015\",\n\t\"hslash;\": \"\u210F\",\n\t\"Hstrok;\": \"\u0126\",\n\t\"hstrok;\": \"\u0127\",\n\t\"hybull;\": \"\u2043\",\n\t\"hyphen;\": \"\u2010\",\n\t\"Iacute;\": \"\u00CD\",\n\t\"iacute;\": \"\u00ED\",\n\t\"Igrave;\": \"\u00CC\",\n\t\"igrave;\": \"\u00EC\",\n\t\"iiiint;\": \"\u2A0C\",\n\t\"iinfin;\": \"\u29DC\",\n\t\"incare;\": \"\u2105\",\n\t\"inodot;\": \"\u0131\",\n\t\"intcal;\": \"\u22BA\",\n\t\"iquest;\": \"\u00BF\",\n\t\"isinsv;\": \"\u22F3\",\n\t\"Itilde;\": \"\u0128\",\n\t\"itilde;\": \"\u0129\",\n\t\"Jsercy;\": \"\u0408\",\n\t\"jsercy;\": \"\u0458\",\n\t\"kappav;\": \"\u03F0\",\n\t\"Kcedil;\": \"\u0136\",\n\t\"kcedil;\": \"\u0137\",\n\t\"kgreen;\": \"\u0138\",\n\t\"Lacute;\": \"\u0139\",\n\t\"lacute;\": \"\u013A\",\n\t\"lagran;\": \"\u2112\",\n\t\"Lambda;\": \"\u039B\",\n\t\"lambda;\": \"\u03BB\",\n\t\"langle;\": \"\u27E8\",\n\t\"larrfs;\": \"\u291D\",\n\t\"larrhk;\": \"\u21A9\",\n\t\"larrlp;\": \"\u21AB\",\n\t\"larrpl;\": \"\u2939\",\n\t\"larrtl;\": \"\u21A2\",\n\t\"lAtail;\": \"\u291B\",\n\t\"latail;\": \"\u2919\",\n\t\"lbrace;\": \"{\",\n\t\"lbrack;\": \"[\",\n\t\"Lcaron;\": \"\u013D\",\n\t\"lcaron;\": \"\u013E\",\n\t\"Lcedil;\": \"\u013B\",\n\t\"lcedil;\": \"\u013C\",\n\t\"ldquor;\": \"\u201E\",\n\t\"lesdot;\": \"\u2A7F\",\n\t\"lesges;\": \"\u2A93\",\n\t\"lfisht;\": \"\u297C\",\n\t\"lfloor;\": \"\u230A\",\n\t\"lharul;\": \"\u296A\",\n\t\"llhard;\": \"\u296B\",\n\t\"Lmidot;\": \"\u013F\",\n\t\"lmidot;\": \"\u0140\",\n\t\"lmoust;\": \"\u23B0\",\n\t\"loplus;\": \"\u2A2D\",\n\t\"lowast;\": \"\u2217\",\n\t\"lowbar;\": \"_\",\n\t\"lparlt;\": \"\u2993\",\n\t\"lrhard;\": \"\u296D\",\n\t\"lsaquo;\": \"\u2039\",\n\t\"lsquor;\": \"\u201A\",\n\t\"Lstrok;\": \"\u0141\",\n\t\"lstrok;\": \"\u0142\",\n\t\"lthree;\": \"\u22CB\",\n\t\"ltimes;\": \"\u22C9\",\n\t\"ltlarr;\": \"\u2976\",\n\t\"ltrPar;\": \"\u2996\",\n\t\"mapsto;\": \"\u21A6\",\n\t\"marker;\": \"\u25AE\",\n\t\"mcomma;\": \"\u2A29\",\n\t\"midast;\": \"*\",\n\t\"midcir;\": \"\u2AF0\",\n\t\"middot;\": \"\u00B7\",\n\t\"minusb;\": \"\u229F\",\n\t\"minusd;\": \"\u2238\",\n\t\"mnplus;\": \"\u2213\",\n\t\"models;\": \"\u22A7\",\n\t\"mstpos;\": \"\u223E\",\n\t\"Nacute;\": \"\u0143\",\n\t\"nacute;\": \"\u0144\",\n\t\"nbumpe;\": \"\u224F\u0338\",\n\t\"Ncaron;\": \"\u0147\",\n\t\"ncaron;\": \"\u0148\",\n\t\"Ncedil;\": \"\u0145\",\n\t\"ncedil;\": \"\u0146\",\n\t\"nearhk;\": \"\u2924\",\n\t\"nequiv;\": \"\u2262\",\n\t\"nesear;\": \"\u2928\",\n\t\"nexist;\": \"\u2204\",\n\t\"nltrie;\": \"\u22EC\",\n\t\"notinE;\": \"\u22F9\u0338\",\n\t\"nparsl;\": \"\u2AFD\u20E5\",\n\t\"nprcue;\": \"\u22E0\",\n\t\"nrarrc;\": \"\u2933\u0338\",\n\t\"nrarrw;\": \"\u219D\u0338\",\n\t\"nrtrie;\": \"\u22ED\",\n\t\"nsccue;\": \"\u22E1\",\n\t\"nsimeq;\": \"\u2244\",\n\t\"Ntilde;\": \"\u00D1\",\n\t\"ntilde;\": \"\u00F1\",\n\t\"numero;\": \"\u2116\",\n\t\"nVDash;\": \"\u22AF\",\n\t\"nVdash;\": \"\u22AE\",\n\t\"nvDash;\": \"\u22AD\",\n\t\"nvdash;\": \"\u22AC\",\n\t\"nvHarr;\": \"\u2904\",\n\t\"nvlArr;\": \"\u2902\",\n\t\"nvrArr;\": \"\u2903\",\n\t\"nwarhk;\": \"\u2923\",\n\t\"nwnear;\": \"\u2927\",\n\t\"Oacute;\": \"\u00D3\",\n\t\"oacute;\": \"\u00F3\",\n\t\"Odblac;\": \"\u0150\",\n\t\"odblac;\": \"\u0151\",\n\t\"odsold;\": \"\u29BC\",\n\t\"Ograve;\": \"\u00D2\",\n\t\"ograve;\": \"\u00F2\",\n\t\"ominus;\": \"\u2296\",\n\t\"origof;\": \"\u22B6\",\n\t\"Oslash;\": \"\u00D8\",\n\t\"oslash;\": \"\u00F8\",\n\t\"Otilde;\": \"\u00D5\",\n\t\"otilde;\": \"\u00F5\",\n\t\"Otimes;\": \"\u2A37\",\n\t\"otimes;\": \"\u2297\",\n\t\"parsim;\": \"\u2AF3\",\n\t\"percnt;\": \"%\",\n\t\"period;\": \".\",\n\t\"permil;\": \"\u2030\",\n\t\"phmmat;\": \"\u2133\",\n\t\"planck;\": \"\u210F\",\n\t\"plankv;\": \"\u210F\",\n\t\"plusdo;\": \"\u2214\",\n\t\"plusdu;\": \"\u2A25\",\n\t\"plusmn;\": \"\u00B1\",\n\t\"preceq;\": \"\u2AAF\",\n\t\"primes;\": \"\u2119\",\n\t\"prnsim;\": \"\u22E8\",\n\t\"propto;\": \"\u221D\",\n\t\"prurel;\": \"\u22B0\",\n\t\"puncsp;\": \"\u2008\",\n\t\"qprime;\": \"\u2057\",\n\t\"Racute;\": \"\u0154\",\n\t\"racute;\": \"\u0155\",\n\t\"rangle;\": \"\u27E9\",\n\t\"rarrap;\": \"\u2975\",\n\t\"rarrfs;\": \"\u291E\",\n\t\"rarrhk;\": \"\u21AA\",\n\t\"rarrlp;\": \"\u21AC\",\n\t\"rarrpl;\": \"\u2945\",\n\t\"Rarrtl;\": \"\u2916\",\n\t\"rarrtl;\": \"\u21A3\",\n\t\"rAtail;\": \"\u291C\",\n\t\"ratail;\": \"\u291A\",\n\t\"rbrace;\": \"}\",\n\t\"rbrack;\": \"]\",\n\t\"Rcaron;\": \"\u0158\",\n\t\"rcaron;\": \"\u0159\",\n\t\"Rcedil;\": \"\u0156\",\n\t\"rcedil;\": \"\u0157\",\n\t\"rdquor;\": \"\u201D\",\n\t\"rfisht;\": \"\u297D\",\n\t\"rfloor;\": \"\u230B\",\n\t\"rharul;\": \"\u296C\",\n\t\"rmoust;\": \"\u23B1\",\n\t\"roplus;\": \"\u2A2E\",\n\t\"rpargt;\": \"\u2994\",\n\t\"rsaquo;\": \"\u203A\",\n\t\"rsquor;\": \"\u2019\",\n\t\"rthree;\": \"\u22CC\",\n\t\"rtimes;\": \"\u22CA\",\n\t\"Sacute;\": \"\u015A\",\n\t\"sacute;\": \"\u015B\",\n\t\"Scaron;\": \"\u0160\",\n\t\"scaron;\": \"\u0161\",\n\t\"Scedil;\": \"\u015E\",\n\t\"scedil;\": \"\u015F\",\n\t\"scnsim;\": \"\u22E9\",\n\t\"searhk;\": \"\u2925\",\n\t\"seswar;\": \"\u2929\",\n\t\"sfrown;\": \"\u2322\",\n\t\"SHCHcy;\": \"\u0429\",\n\t\"shchcy;\": \"\u0449\",\n\t\"sigmaf;\": \"\u03C2\",\n\t\"sigmav;\": \"\u03C2\",\n\t\"simdot;\": \"\u2A6A\",\n\t\"smashp;\": \"\u2A33\",\n\t\"SOFTcy;\": \"\u042C\",\n\t\"softcy;\": \"\u044C\",\n\t\"solbar;\": \"\u233F\",\n\t\"spades;\": \"\u2660\",\n\t\"sqcaps;\": \"\u2293\uFE00\",\n\t\"sqcups;\": \"\u2294\uFE00\",\n\t\"sqsube;\": \"\u2291\",\n\t\"sqsupe;\": \"\u2292\",\n\t\"Square;\": \"\u25A1\",\n\t\"square;\": \"\u25A1\",\n\t\"squarf;\": \"\u25AA\",\n\t\"ssetmn;\": \"\u2216\",\n\t\"ssmile;\": \"\u2323\",\n\t\"sstarf;\": \"\u22C6\",\n\t\"subdot;\": \"\u2ABD\",\n\t\"Subset;\": \"\u22D0\",\n\t\"subset;\": \"\u2282\",\n\t\"subsim;\": \"\u2AC7\",\n\t\"subsub;\": \"\u2AD5\",\n\t\"subsup;\": \"\u2AD3\",\n\t\"succeq;\": \"\u2AB0\",\n\t\"supdot;\": \"\u2ABE\",\n\t\"Supset;\": \"\u22D1\",\n\t\"supset;\": \"\u2283\",\n\t\"supsim;\": \"\u2AC8\",\n\t\"supsub;\": \"\u2AD4\",\n\t\"supsup;\": \"\u2AD6\",\n\t\"swarhk;\": \"\u2926\",\n\t\"swnwar;\": \"\u292A\",\n\t\"target;\": \"\u2316\",\n\t\"Tcaron;\": \"\u0164\",\n\t\"tcaron;\": \"\u0165\",\n\t\"Tcedil;\": \"\u0162\",\n\t\"tcedil;\": \"\u0163\",\n\t\"telrec;\": \"\u2315\",\n\t\"there4;\": \"\u2234\",\n\t\"thetav;\": \"\u03D1\",\n\t\"thinsp;\": \"\u2009\",\n\t\"thksim;\": \"\u223C\",\n\t\"timesb;\": \"\u22A0\",\n\t\"timesd;\": \"\u2A30\",\n\t\"topbot;\": \"\u2336\",\n\t\"topcir;\": \"\u2AF1\",\n\t\"tprime;\": \"\u2034\",\n\t\"tridot;\": \"\u25EC\",\n\t\"Tstrok;\": \"\u0166\",\n\t\"tstrok;\": \"\u0167\",\n\t\"Uacute;\": \"\u00DA\",\n\t\"uacute;\": \"\u00FA\",\n\t\"Ubreve;\": \"\u016C\",\n\t\"ubreve;\": \"\u016D\",\n\t\"Udblac;\": \"\u0170\",\n\t\"udblac;\": \"\u0171\",\n\t\"ufisht;\": \"\u297E\",\n\t\"Ugrave;\": \"\u00D9\",\n\t\"ugrave;\": \"\u00F9\",\n\t\"ulcorn;\": \"\u231C\",\n\t\"ulcrop;\": \"\u230F\",\n\t\"urcorn;\": \"\u231D\",\n\t\"urcrop;\": \"\u230E\",\n\t\"Utilde;\": \"\u0168\",\n\t\"utilde;\": \"\u0169\",\n\t\"vangrt;\": \"\u299C\",\n\t\"varphi;\": \"\u03D5\",\n\t\"varrho;\": \"\u03F1\",\n\t\"Vdashl;\": \"\u2AE6\",\n\t\"veebar;\": \"\u22BB\",\n\t\"vellip;\": \"\u22EE\",\n\t\"Verbar;\": \"\u2016\",\n\t\"verbar;\": \"|\",\n\t\"vsubnE;\": \"\u2ACB\uFE00\",\n\t\"vsubne;\": \"\u228A\uFE00\",\n\t\"vsupnE;\": \"\u2ACC\uFE00\",\n\t\"vsupne;\": \"\u228B\uFE00\",\n\t\"Vvdash;\": \"\u22AA\",\n\t\"wedbar;\": \"\u2A5F\",\n\t\"wedgeq;\": \"\u2259\",\n\t\"weierp;\": \"\u2118\",\n\t\"wreath;\": \"\u2240\",\n\t\"xoplus;\": \"\u2A01\",\n\t\"xotime;\": \"\u2A02\",\n\t\"xsqcup;\": \"\u2A06\",\n\t\"xuplus;\": \"\u2A04\",\n\t\"xwedge;\": \"\u22C0\",\n\t\"Yacute;\": \"\u00DD\",\n\t\"yacute;\": \"\u00FD\",\n\t\"Zacute;\": \"\u0179\",\n\t\"zacute;\": \"\u017A\",\n\t\"Zcaron;\": \"\u017D\",\n\t\"zcaron;\": \"\u017E\",\n\t\"zeetrf;\": \"\u2128\",\n\t\"alefsym;\": \"\u2135\",\n\t\"angrtvb;\": \"\u22BE\",\n\t\"angzarr;\": \"\u237C\",\n\t\"asympeq;\": \"\u224D\",\n\t\"backsim;\": \"\u223D\",\n\t\"Because;\": \"\u2235\",\n\t\"because;\": \"\u2235\",\n\t\"bemptyv;\": \"\u29B0\",\n\t\"between;\": \"\u226C\",\n\t\"bigcirc;\": \"\u25EF\",\n\t\"bigodot;\": \"\u2A00\",\n\t\"bigstar;\": \"\u2605\",\n\t\"bnequiv;\": \"\u2261\u20E5\",\n\t\"boxplus;\": \"\u229E\",\n\t\"Cayleys;\": \"\u212D\",\n\t\"Cconint;\": \"\u2230\",\n\t\"ccupssm;\": \"\u2A50\",\n\t\"Cedilla;\": \"\u00B8\",\n\t\"cemptyv;\": \"\u29B2\",\n\t\"cirscir;\": \"\u29C2\",\n\t\"coloneq;\": \"\u2254\",\n\t\"congdot;\": \"\u2A6D\",\n\t\"cudarrl;\": \"\u2938\",\n\t\"cudarrr;\": \"\u2935\",\n\t\"cularrp;\": \"\u293D\",\n\t\"curarrm;\": \"\u293C\",\n\t\"dbkarow;\": \"\u290F\",\n\t\"ddagger;\": \"\u2021\",\n\t\"ddotseq;\": \"\u2A77\",\n\t\"demptyv;\": \"\u29B1\",\n\t\"Diamond;\": \"\u22C4\",\n\t\"diamond;\": \"\u22C4\",\n\t\"digamma;\": \"\u03DD\",\n\t\"dotplus;\": \"\u2214\",\n\t\"DownTee;\": \"\u22A4\",\n\t\"dwangle;\": \"\u29A6\",\n\t\"Element;\": \"\u2208\",\n\t\"Epsilon;\": \"\u0395\",\n\t\"epsilon;\": \"\u03B5\",\n\t\"eqcolon;\": \"\u2255\",\n\t\"equivDD;\": \"\u2A78\",\n\t\"gesdoto;\": \"\u2A82\",\n\t\"gtquest;\": \"\u2A7C\",\n\t\"gtrless;\": \"\u2277\",\n\t\"harrcir;\": \"\u2948\",\n\t\"Implies;\": \"\u21D2\",\n\t\"intprod;\": \"\u2A3C\",\n\t\"isindot;\": \"\u22F5\",\n\t\"larrbfs;\": \"\u291F\",\n\t\"larrsim;\": \"\u2973\",\n\t\"lbrksld;\": \"\u298F\",\n\t\"lbrkslu;\": \"\u298D\",\n\t\"ldrdhar;\": \"\u2967\",\n\t\"LeftTee;\": \"\u22A3\",\n\t\"lesdoto;\": \"\u2A81\",\n\t\"lessdot;\": \"\u22D6\",\n\t\"lessgtr;\": \"\u2276\",\n\t\"lesssim;\": \"\u2272\",\n\t\"lotimes;\": \"\u2A34\",\n\t\"lozenge;\": \"\u25CA\",\n\t\"ltquest;\": \"\u2A7B\",\n\t\"luruhar;\": \"\u2966\",\n\t\"maltese;\": \"\u2720\",\n\t\"minusdu;\": \"\u2A2A\",\n\t\"napprox;\": \"\u2249\",\n\t\"natural;\": \"\u266E\",\n\t\"nearrow;\": \"\u2197\",\n\t\"NewLine;\": \"\\n\",\n\t\"nexists;\": \"\u2204\",\n\t\"NoBreak;\": \"\u2060\",\n\t\"notinva;\": \"\u2209\",\n\t\"notinvb;\": \"\u22F7\",\n\t\"notinvc;\": \"\u22F6\",\n\t\"NotLess;\": \"\u226E\",\n\t\"notniva;\": \"\u220C\",\n\t\"notnivb;\": \"\u22FE\",\n\t\"notnivc;\": \"\u22FD\",\n\t\"npolint;\": \"\u2A14\",\n\t\"npreceq;\": \"\u2AAF\u0338\",\n\t\"nsqsube;\": \"\u22E2\",\n\t\"nsqsupe;\": \"\u22E3\",\n\t\"nsubset;\": \"\u2282\u20D2\",\n\t\"nsucceq;\": \"\u2AB0\u0338\",\n\t\"nsupset;\": \"\u2283\u20D2\",\n\t\"nvinfin;\": \"\u29DE\",\n\t\"nvltrie;\": \"\u22B4\u20D2\",\n\t\"nvrtrie;\": \"\u22B5\u20D2\",\n\t\"nwarrow;\": \"\u2196\",\n\t\"olcross;\": \"\u29BB\",\n\t\"Omicron;\": \"\u039F\",\n\t\"omicron;\": \"\u03BF\",\n\t\"orderof;\": \"\u2134\",\n\t\"orslope;\": \"\u2A57\",\n\t\"OverBar;\": \"\u203E\",\n\t\"pertenk;\": \"\u2031\",\n\t\"planckh;\": \"\u210E\",\n\t\"pluscir;\": \"\u2A22\",\n\t\"plussim;\": \"\u2A26\",\n\t\"plustwo;\": \"\u2A27\",\n\t\"precsim;\": \"\u227E\",\n\t\"Product;\": \"\u220F\",\n\t\"quatint;\": \"\u2A16\",\n\t\"questeq;\": \"\u225F\",\n\t\"rarrbfs;\": \"\u2920\",\n\t\"rarrsim;\": \"\u2974\",\n\t\"rbrksld;\": \"\u298E\",\n\t\"rbrkslu;\": \"\u2990\",\n\t\"rdldhar;\": \"\u2969\",\n\t\"realine;\": \"\u211B\",\n\t\"rotimes;\": \"\u2A35\",\n\t\"ruluhar;\": \"\u2968\",\n\t\"searrow;\": \"\u2198\",\n\t\"simplus;\": \"\u2A24\",\n\t\"simrarr;\": \"\u2972\",\n\t\"subedot;\": \"\u2AC3\",\n\t\"submult;\": \"\u2AC1\",\n\t\"subplus;\": \"\u2ABF\",\n\t\"subrarr;\": \"\u2979\",\n\t\"succsim;\": \"\u227F\",\n\t\"supdsub;\": \"\u2AD8\",\n\t\"supedot;\": \"\u2AC4\",\n\t\"suphsol;\": \"\u27C9\",\n\t\"suphsub;\": \"\u2AD7\",\n\t\"suplarr;\": \"\u297B\",\n\t\"supmult;\": \"\u2AC2\",\n\t\"supplus;\": \"\u2AC0\",\n\t\"swarrow;\": \"\u2199\",\n\t\"topfork;\": \"\u2ADA\",\n\t\"triplus;\": \"\u2A39\",\n\t\"tritime;\": \"\u2A3B\",\n\t\"UpArrow;\": \"\u2191\",\n\t\"Uparrow;\": \"\u21D1\",\n\t\"uparrow;\": \"\u2191\",\n\t\"Upsilon;\": \"\u03A5\",\n\t\"upsilon;\": \"\u03C5\",\n\t\"uwangle;\": \"\u29A7\",\n\t\"vzigzag;\": \"\u299A\",\n\t\"zigrarr;\": \"\u21DD\",\n\t\"andslope;\": \"\u2A58\",\n\t\"angmsdaa;\": \"\u29A8\",\n\t\"angmsdab;\": \"\u29A9\",\n\t\"angmsdac;\": \"\u29AA\",\n\t\"angmsdad;\": \"\u29AB\",\n\t\"angmsdae;\": \"\u29AC\",\n\t\"angmsdaf;\": \"\u29AD\",\n\t\"angmsdag;\": \"\u29AE\",\n\t\"angmsdah;\": \"\u29AF\",\n\t\"angrtvbd;\": \"\u299D\",\n\t\"approxeq;\": \"\u224A\",\n\t\"awconint;\": \"\u2233\",\n\t\"backcong;\": \"\u224C\",\n\t\"barwedge;\": \"\u2305\",\n\t\"bbrktbrk;\": \"\u23B6\",\n\t\"bigoplus;\": \"\u2A01\",\n\t\"bigsqcup;\": \"\u2A06\",\n\t\"biguplus;\": \"\u2A04\",\n\t\"bigwedge;\": \"\u22C0\",\n\t\"boxminus;\": \"\u229F\",\n\t\"boxtimes;\": \"\u22A0\",\n\t\"bsolhsub;\": \"\u27C8\",\n\t\"capbrcup;\": \"\u2A49\",\n\t\"circledR;\": \"\u00AE\",\n\t\"circledS;\": \"\u24C8\",\n\t\"cirfnint;\": \"\u2A10\",\n\t\"clubsuit;\": \"\u2663\",\n\t\"cupbrcap;\": \"\u2A48\",\n\t\"curlyvee;\": \"\u22CE\",\n\t\"cwconint;\": \"\u2232\",\n\t\"DDotrahd;\": \"\u2911\",\n\t\"doteqdot;\": \"\u2251\",\n\t\"DotEqual;\": \"\u2250\",\n\t\"dotminus;\": \"\u2238\",\n\t\"drbkarow;\": \"\u2910\",\n\t\"dzigrarr;\": \"\u27FF\",\n\t\"elinters;\": \"\u23E7\",\n\t\"emptyset;\": \"\u2205\",\n\t\"eqvparsl;\": \"\u29E5\",\n\t\"fpartint;\": \"\u2A0D\",\n\t\"geqslant;\": \"\u2A7E\",\n\t\"gesdotol;\": \"\u2A84\",\n\t\"gnapprox;\": \"\u2A8A\",\n\t\"hksearow;\": \"\u2925\",\n\t\"hkswarow;\": \"\u2926\",\n\t\"imagline;\": \"\u2110\",\n\t\"imagpart;\": \"\u2111\",\n\t\"infintie;\": \"\u29DD\",\n\t\"integers;\": \"\u2124\",\n\t\"Integral;\": \"\u222B\",\n\t\"intercal;\": \"\u22BA\",\n\t\"intlarhk;\": \"\u2A17\",\n\t\"laemptyv;\": \"\u29B4\",\n\t\"ldrushar;\": \"\u294B\",\n\t\"leqslant;\": \"\u2A7D\",\n\t\"lesdotor;\": \"\u2A83\",\n\t\"LessLess;\": \"\u2AA1\",\n\t\"llcorner;\": \"\u231E\",\n\t\"lnapprox;\": \"\u2A89\",\n\t\"lrcorner;\": \"\u231F\",\n\t\"lurdshar;\": \"\u294A\",\n\t\"mapstoup;\": \"\u21A5\",\n\t\"multimap;\": \"\u22B8\",\n\t\"naturals;\": \"\u2115\",\n\t\"ncongdot;\": \"\u2A6D\u0338\",\n\t\"NotEqual;\": \"\u2260\",\n\t\"notindot;\": \"\u22F5\u0338\",\n\t\"NotTilde;\": \"\u2241\",\n\t\"otimesas;\": \"\u2A36\",\n\t\"parallel;\": \"\u2225\",\n\t\"PartialD;\": \"\u2202\",\n\t\"plusacir;\": \"\u2A23\",\n\t\"pointint;\": \"\u2A15\",\n\t\"Precedes;\": \"\u227A\",\n\t\"precneqq;\": \"\u2AB5\",\n\t\"precnsim;\": \"\u22E8\",\n\t\"profalar;\": \"\u232E\",\n\t\"profline;\": \"\u2312\",\n\t\"profsurf;\": \"\u2313\",\n\t\"raemptyv;\": \"\u29B3\",\n\t\"realpart;\": \"\u211C\",\n\t\"RightTee;\": \"\u22A2\",\n\t\"rppolint;\": \"\u2A12\",\n\t\"rtriltri;\": \"\u29CE\",\n\t\"scpolint;\": \"\u2A13\",\n\t\"setminus;\": \"\u2216\",\n\t\"shortmid;\": \"\u2223\",\n\t\"smeparsl;\": \"\u29E4\",\n\t\"sqsubset;\": \"\u228F\",\n\t\"sqsupset;\": \"\u2290\",\n\t\"subseteq;\": \"\u2286\",\n\t\"Succeeds;\": \"\u227B\",\n\t\"succneqq;\": \"\u2AB6\",\n\t\"succnsim;\": \"\u22E9\",\n\t\"SuchThat;\": \"\u220B\",\n\t\"Superset;\": \"\u2283\",\n\t\"supseteq;\": \"\u2287\",\n\t\"thetasym;\": \"\u03D1\",\n\t\"thicksim;\": \"\u223C\",\n\t\"timesbar;\": \"\u2A31\",\n\t\"triangle;\": \"\u25B5\",\n\t\"triminus;\": \"\u2A3A\",\n\t\"trpezium;\": \"\u23E2\",\n\t\"Uarrocir;\": \"\u2949\",\n\t\"ulcorner;\": \"\u231C\",\n\t\"UnderBar;\": \"_\",\n\t\"urcorner;\": \"\u231D\",\n\t\"varkappa;\": \"\u03F0\",\n\t\"varsigma;\": \"\u03C2\",\n\t\"vartheta;\": \"\u03D1\",\n\t\"backprime;\": \"\u2035\",\n\t\"backsimeq;\": \"\u22CD\",\n\t\"Backslash;\": \"\u2216\",\n\t\"bigotimes;\": \"\u2A02\",\n\t\"CenterDot;\": \"\u00B7\",\n\t\"centerdot;\": \"\u00B7\",\n\t\"checkmark;\": \"\u2713\",\n\t\"CircleDot;\": \"\u2299\",\n\t\"complexes;\": \"\u2102\",\n\t\"Congruent;\": \"\u2261\",\n\t\"Coproduct;\": \"\u2210\",\n\t\"dotsquare;\": \"\u22A1\",\n\t\"DoubleDot;\": \"\u00A8\",\n\t\"DownArrow;\": \"\u2193\",\n\t\"Downarrow;\": \"\u21D3\",\n\t\"downarrow;\": \"\u2193\",\n\t\"DownBreve;\": \"\u0311\",\n\t\"gtrapprox;\": \"\u2A86\",\n\t\"gtreqless;\": \"\u22DB\",\n\t\"gvertneqq;\": \"\u2269\uFE00\",\n\t\"heartsuit;\": \"\u2665\",\n\t\"HumpEqual;\": \"\u224F\",\n\t\"LeftArrow;\": \"\u2190\",\n\t\"Leftarrow;\": \"\u21D0\",\n\t\"leftarrow;\": \"\u2190\",\n\t\"LeftFloor;\": \"\u230A\",\n\t\"lesseqgtr;\": \"\u22DA\",\n\t\"LessTilde;\": \"\u2272\",\n\t\"lvertneqq;\": \"\u2268\uFE00\",\n\t\"Mellintrf;\": \"\u2133\",\n\t\"MinusPlus;\": \"\u2213\",\n\t\"ngeqslant;\": \"\u2A7E\u0338\",\n\t\"nleqslant;\": \"\u2A7D\u0338\",\n\t\"NotCupCap;\": \"\u226D\",\n\t\"NotExists;\": \"\u2204\",\n\t\"NotSubset;\": \"\u2282\u20D2\",\n\t\"nparallel;\": \"\u2226\",\n\t\"nshortmid;\": \"\u2224\",\n\t\"nsubseteq;\": \"\u2288\",\n\t\"nsupseteq;\": \"\u2289\",\n\t\"OverBrace;\": \"\u23DE\",\n\t\"pitchfork;\": \"\u22D4\",\n\t\"PlusMinus;\": \"\u00B1\",\n\t\"rationals;\": \"\u211A\",\n\t\"spadesuit;\": \"\u2660\",\n\t\"subseteqq;\": \"\u2AC5\",\n\t\"subsetneq;\": \"\u228A\",\n\t\"supseteqq;\": \"\u2AC6\",\n\t\"supsetneq;\": \"\u228B\",\n\t\"Therefore;\": \"\u2234\",\n\t\"therefore;\": \"\u2234\",\n\t\"ThinSpace;\": \"\u2009\",\n\t\"triangleq;\": \"\u225C\",\n\t\"TripleDot;\": \"\u20DB\",\n\t\"UnionPlus;\": \"\u228E\",\n\t\"varpropto;\": \"\u221D\",\n\t\"Bernoullis;\": \"\u212C\",\n\t\"circledast;\": \"\u229B\",\n\t\"CirclePlus;\": \"\u2295\",\n\t\"complement;\": \"\u2201\",\n\t\"curlywedge;\": \"\u22CF\",\n\t\"eqslantgtr;\": \"\u2A96\",\n\t\"EqualTilde;\": \"\u2242\",\n\t\"Fouriertrf;\": \"\u2131\",\n\t\"gtreqqless;\": \"\u2A8C\",\n\t\"ImaginaryI;\": \"\u2148\",\n\t\"Laplacetrf;\": \"\u2112\",\n\t\"LeftVector;\": \"\u21BC\",\n\t\"lessapprox;\": \"\u2A85\",\n\t\"lesseqqgtr;\": \"\u2A8B\",\n\t\"Lleftarrow;\": \"\u21DA\",\n\t\"lmoustache;\": \"\u23B0\",\n\t\"longmapsto;\": \"\u27FC\",\n\t\"mapstodown;\": \"\u21A7\",\n\t\"mapstoleft;\": \"\u21A4\",\n\t\"nLeftarrow;\": \"\u21CD\",\n\t\"nleftarrow;\": \"\u219A\",\n\t\"NotElement;\": \"\u2209\",\n\t\"NotGreater;\": \"\u226F\",\n\t\"nsubseteqq;\": \"\u2AC5\u0338\",\n\t\"nsupseteqq;\": \"\u2AC6\u0338\",\n\t\"precapprox;\": \"\u2AB7\",\n\t\"Proportion;\": \"\u2237\",\n\t\"RightArrow;\": \"\u2192\",\n\t\"Rightarrow;\": \"\u21D2\",\n\t\"rightarrow;\": \"\u2192\",\n\t\"RightFloor;\": \"\u230B\",\n\t\"rmoustache;\": \"\u23B1\",\n\t\"sqsubseteq;\": \"\u2291\",\n\t\"sqsupseteq;\": \"\u2292\",\n\t\"subsetneqq;\": \"\u2ACB\",\n\t\"succapprox;\": \"\u2AB8\",\n\t\"supsetneqq;\": \"\u2ACC\",\n\t\"ThickSpace;\": \"\u205F\u200A\",\n\t\"TildeEqual;\": \"\u2243\",\n\t\"TildeTilde;\": \"\u2248\",\n\t\"UnderBrace;\": \"\u23DF\",\n\t\"UpArrowBar;\": \"\u2912\",\n\t\"UpTeeArrow;\": \"\u21A5\",\n\t\"upuparrows;\": \"\u21C8\",\n\t\"varepsilon;\": \"\u03F5\",\n\t\"varnothing;\": \"\u2205\",\n\t\"backepsilon;\": \"\u03F6\",\n\t\"blacksquare;\": \"\u25AA\",\n\t\"circledcirc;\": \"\u229A\",\n\t\"circleddash;\": \"\u229D\",\n\t\"CircleMinus;\": \"\u2296\",\n\t\"CircleTimes;\": \"\u2297\",\n\t\"curlyeqprec;\": \"\u22DE\",\n\t\"curlyeqsucc;\": \"\u22DF\",\n\t\"diamondsuit;\": \"\u2666\",\n\t\"eqslantless;\": \"\u2A95\",\n\t\"Equilibrium;\": \"\u21CC\",\n\t\"expectation;\": \"\u2130\",\n\t\"GreaterLess;\": \"\u2277\",\n\t\"LeftCeiling;\": \"\u2308\",\n\t\"LessGreater;\": \"\u2276\",\n\t\"MediumSpace;\": \"\u205F\",\n\t\"NotLessLess;\": \"\u226A\u0338\",\n\t\"NotPrecedes;\": \"\u2280\",\n\t\"NotSucceeds;\": \"\u2281\",\n\t\"NotSuperset;\": \"\u2283\u20D2\",\n\t\"nRightarrow;\": \"\u21CF\",\n\t\"nrightarrow;\": \"\u219B\",\n\t\"OverBracket;\": \"\u23B4\",\n\t\"preccurlyeq;\": \"\u227C\",\n\t\"precnapprox;\": \"\u2AB9\",\n\t\"quaternions;\": \"\u210D\",\n\t\"RightVector;\": \"\u21C0\",\n\t\"Rrightarrow;\": \"\u21DB\",\n\t\"RuleDelayed;\": \"\u29F4\",\n\t\"SmallCircle;\": \"\u2218\",\n\t\"SquareUnion;\": \"\u2294\",\n\t\"straightphi;\": \"\u03D5\",\n\t\"SubsetEqual;\": \"\u2286\",\n\t\"succcurlyeq;\": \"\u227D\",\n\t\"succnapprox;\": \"\u2ABA\",\n\t\"thickapprox;\": \"\u2248\",\n\t\"UpDownArrow;\": \"\u2195\",\n\t\"Updownarrow;\": \"\u21D5\",\n\t\"updownarrow;\": \"\u2195\",\n\t\"VerticalBar;\": \"\u2223\",\n\t\"blacklozenge;\": \"\u29EB\",\n\t\"DownArrowBar;\": \"\u2913\",\n\t\"DownTeeArrow;\": \"\u21A7\",\n\t\"ExponentialE;\": \"\u2147\",\n\t\"exponentiale;\": \"\u2147\",\n\t\"GreaterEqual;\": \"\u2265\",\n\t\"GreaterTilde;\": \"\u2273\",\n\t\"HilbertSpace;\": \"\u210B\",\n\t\"HumpDownHump;\": \"\u224E\",\n\t\"Intersection;\": \"\u22C2\",\n\t\"LeftArrowBar;\": \"\u21E4\",\n\t\"LeftTeeArrow;\": \"\u21A4\",\n\t\"LeftTriangle;\": \"\u22B2\",\n\t\"LeftUpVector;\": \"\u21BF\",\n\t\"NotCongruent;\": \"\u2262\",\n\t\"NotHumpEqual;\": \"\u224F\u0338\",\n\t\"NotLessEqual;\": \"\u2270\",\n\t\"NotLessTilde;\": \"\u2274\",\n\t\"Proportional;\": \"\u221D\",\n\t\"RightCeiling;\": \"\u2309\",\n\t\"risingdotseq;\": \"\u2253\",\n\t\"RoundImplies;\": \"\u2970\",\n\t\"ShortUpArrow;\": \"\u2191\",\n\t\"SquareSubset;\": \"\u228F\",\n\t\"triangledown;\": \"\u25BF\",\n\t\"triangleleft;\": \"\u25C3\",\n\t\"UnderBracket;\": \"\u23B5\",\n\t\"varsubsetneq;\": \"\u228A\uFE00\",\n\t\"varsupsetneq;\": \"\u228B\uFE00\",\n\t\"VerticalLine;\": \"|\",\n\t\"ApplyFunction;\": \"\u2061\",\n\t\"bigtriangleup;\": \"\u25B3\",\n\t\"blacktriangle;\": \"\u25B4\",\n\t\"DifferentialD;\": \"\u2146\",\n\t\"divideontimes;\": \"\u22C7\",\n\t\"DoubleLeftTee;\": \"\u2AE4\",\n\t\"DoubleUpArrow;\": \"\u21D1\",\n\t\"fallingdotseq;\": \"\u2252\",\n\t\"hookleftarrow;\": \"\u21A9\",\n\t\"leftarrowtail;\": \"\u21A2\",\n\t\"leftharpoonup;\": \"\u21BC\",\n\t\"LeftTeeVector;\": \"\u295A\",\n\t\"LeftVectorBar;\": \"\u2952\",\n\t\"LessFullEqual;\": \"\u2266\",\n\t\"LongLeftArrow;\": \"\u27F5\",\n\t\"Longleftarrow;\": \"\u27F8\",\n\t\"longleftarrow;\": \"\u27F5\",\n\t\"looparrowleft;\": \"\u21AB\",\n\t\"measuredangle;\": \"\u2221\",\n\t\"NotEqualTilde;\": \"\u2242\u0338\",\n\t\"NotTildeEqual;\": \"\u2244\",\n\t\"NotTildeTilde;\": \"\u2249\",\n\t\"ntriangleleft;\": \"\u22EA\",\n\t\"Poincareplane;\": \"\u210C\",\n\t\"PrecedesEqual;\": \"\u2AAF\",\n\t\"PrecedesTilde;\": \"\u227E\",\n\t\"RightArrowBar;\": \"\u21E5\",\n\t\"RightTeeArrow;\": \"\u21A6\",\n\t\"RightTriangle;\": \"\u22B3\",\n\t\"RightUpVector;\": \"\u21BE\",\n\t\"shortparallel;\": \"\u2225\",\n\t\"smallsetminus;\": \"\u2216\",\n\t\"SucceedsEqual;\": \"\u2AB0\",\n\t\"SucceedsTilde;\": \"\u227F\",\n\t\"SupersetEqual;\": \"\u2287\",\n\t\"triangleright;\": \"\u25B9\",\n\t\"UpEquilibrium;\": \"\u296E\",\n\t\"upharpoonleft;\": \"\u21BF\",\n\t\"varsubsetneqq;\": \"\u2ACB\uFE00\",\n\t\"varsupsetneqq;\": \"\u2ACC\uFE00\",\n\t\"VerticalTilde;\": \"\u2240\",\n\t\"VeryThinSpace;\": \"\u200A\",\n\t\"curvearrowleft;\": \"\u21B6\",\n\t\"DiacriticalDot;\": \"\u02D9\",\n\t\"doublebarwedge;\": \"\u2306\",\n\t\"DoubleRightTee;\": \"\u22A8\",\n\t\"downdownarrows;\": \"\u21CA\",\n\t\"DownLeftVector;\": \"\u21BD\",\n\t\"GreaterGreater;\": \"\u2AA2\",\n\t\"hookrightarrow;\": \"\u21AA\",\n\t\"HorizontalLine;\": \"\u2500\",\n\t\"InvisibleComma;\": \"\u2063\",\n\t\"InvisibleTimes;\": \"\u2062\",\n\t\"LeftDownVector;\": \"\u21C3\",\n\t\"leftleftarrows;\": \"\u21C7\",\n\t\"LeftRightArrow;\": \"\u2194\",\n\t\"Leftrightarrow;\": \"\u21D4\",\n\t\"leftrightarrow;\": \"\u2194\",\n\t\"leftthreetimes;\": \"\u22CB\",\n\t\"LessSlantEqual;\": \"\u2A7D\",\n\t\"LongRightArrow;\": \"\u27F6\",\n\t\"Longrightarrow;\": \"\u27F9\",\n\t\"longrightarrow;\": \"\u27F6\",\n\t\"looparrowright;\": \"\u21AC\",\n\t\"LowerLeftArrow;\": \"\u2199\",\n\t\"NestedLessLess;\": \"\u226A\",\n\t\"NotGreaterLess;\": \"\u2279\",\n\t\"NotLessGreater;\": \"\u2278\",\n\t\"NotSubsetEqual;\": \"\u2288\",\n\t\"NotVerticalBar;\": \"\u2224\",\n\t\"nshortparallel;\": \"\u2226\",\n\t\"ntriangleright;\": \"\u22EB\",\n\t\"OpenCurlyQuote;\": \"\u2018\",\n\t\"ReverseElement;\": \"\u220B\",\n\t\"rightarrowtail;\": \"\u21A3\",\n\t\"rightharpoonup;\": \"\u21C0\",\n\t\"RightTeeVector;\": \"\u295B\",\n\t\"RightVectorBar;\": \"\u2953\",\n\t\"ShortDownArrow;\": \"\u2193\",\n\t\"ShortLeftArrow;\": \"\u2190\",\n\t\"SquareSuperset;\": \"\u2290\",\n\t\"TildeFullEqual;\": \"\u2245\",\n\t\"trianglelefteq;\": \"\u22B4\",\n\t\"upharpoonright;\": \"\u21BE\",\n\t\"UpperLeftArrow;\": \"\u2196\",\n\t\"ZeroWidthSpace;\": \"\u200B\",\n\t\"bigtriangledown;\": \"\u25BD\",\n\t\"circlearrowleft;\": \"\u21BA\",\n\t\"CloseCurlyQuote;\": \"\u2019\",\n\t\"ContourIntegral;\": \"\u222E\",\n\t\"curvearrowright;\": \"\u21B7\",\n\t\"DoubleDownArrow;\": \"\u21D3\",\n\t\"DoubleLeftArrow;\": \"\u21D0\",\n\t\"downharpoonleft;\": \"\u21C3\",\n\t\"DownRightVector;\": \"\u21C1\",\n\t\"leftharpoondown;\": \"\u21BD\",\n\t\"leftrightarrows;\": \"\u21C6\",\n\t\"LeftRightVector;\": \"\u294E\",\n\t\"LeftTriangleBar;\": \"\u29CF\",\n\t\"LeftUpTeeVector;\": \"\u2960\",\n\t\"LeftUpVectorBar;\": \"\u2958\",\n\t\"LowerRightArrow;\": \"\u2198\",\n\t\"nLeftrightarrow;\": \"\u21CE\",\n\t\"nleftrightarrow;\": \"\u21AE\",\n\t\"NotGreaterEqual;\": \"\u2271\",\n\t\"NotGreaterTilde;\": \"\u2275\",\n\t\"NotHumpDownHump;\": \"\u224E\u0338\",\n\t\"NotLeftTriangle;\": \"\u22EA\",\n\t\"NotSquareSubset;\": \"\u228F\u0338\",\n\t\"ntrianglelefteq;\": \"\u22EC\",\n\t\"OverParenthesis;\": \"\u23DC\",\n\t\"RightDownVector;\": \"\u21C2\",\n\t\"rightleftarrows;\": \"\u21C4\",\n\t\"rightsquigarrow;\": \"\u219D\",\n\t\"rightthreetimes;\": \"\u22CC\",\n\t\"ShortRightArrow;\": \"\u2192\",\n\t\"straightepsilon;\": \"\u03F5\",\n\t\"trianglerighteq;\": \"\u22B5\",\n\t\"UpperRightArrow;\": \"\u2197\",\n\t\"vartriangleleft;\": \"\u22B2\",\n\t\"circlearrowright;\": \"\u21BB\",\n\t\"DiacriticalAcute;\": \"\u00B4\",\n\t\"DiacriticalGrave;\": \"`\",\n\t\"DiacriticalTilde;\": \"\u02DC\",\n\t\"DoubleRightArrow;\": \"\u21D2\",\n\t\"DownArrowUpArrow;\": \"\u21F5\",\n\t\"downharpoonright;\": \"\u21C2\",\n\t\"EmptySmallSquare;\": \"\u25FB\",\n\t\"GreaterEqualLess;\": \"\u22DB\",\n\t\"GreaterFullEqual;\": \"\u2267\",\n\t\"LeftAngleBracket;\": \"\u27E8\",\n\t\"LeftUpDownVector;\": \"\u2951\",\n\t\"LessEqualGreater;\": \"\u22DA\",\n\t\"NonBreakingSpace;\": \"\u00A0\",\n\t\"NotPrecedesEqual;\": \"\u2AAF\u0338\",\n\t\"NotRightTriangle;\": \"\u22EB\",\n\t\"NotSucceedsEqual;\": \"\u2AB0\u0338\",\n\t\"NotSucceedsTilde;\": \"\u227F\u0338\",\n\t\"NotSupersetEqual;\": \"\u2289\",\n\t\"ntrianglerighteq;\": \"\u22ED\",\n\t\"rightharpoondown;\": \"\u21C1\",\n\t\"rightrightarrows;\": \"\u21C9\",\n\t\"RightTriangleBar;\": \"\u29D0\",\n\t\"RightUpTeeVector;\": \"\u295C\",\n\t\"RightUpVectorBar;\": \"\u2954\",\n\t\"twoheadleftarrow;\": \"\u219E\",\n\t\"UnderParenthesis;\": \"\u23DD\",\n\t\"UpArrowDownArrow;\": \"\u21C5\",\n\t\"vartriangleright;\": \"\u22B3\",\n\t\"blacktriangledown;\": \"\u25BE\",\n\t\"blacktriangleleft;\": \"\u25C2\",\n\t\"DoubleUpDownArrow;\": \"\u21D5\",\n\t\"DoubleVerticalBar;\": \"\u2225\",\n\t\"DownLeftTeeVector;\": \"\u295E\",\n\t\"DownLeftVectorBar;\": \"\u2956\",\n\t\"FilledSmallSquare;\": \"\u25FC\",\n\t\"GreaterSlantEqual;\": \"\u2A7E\",\n\t\"LeftDoubleBracket;\": \"\u27E6\",\n\t\"LeftDownTeeVector;\": \"\u2961\",\n\t\"LeftDownVectorBar;\": \"\u2959\",\n\t\"leftrightharpoons;\": \"\u21CB\",\n\t\"LeftTriangleEqual;\": \"\u22B4\",\n\t\"NegativeThinSpace;\": \"\u200B\",\n\t\"NotGreaterGreater;\": \"\u226B\u0338\",\n\t\"NotLessSlantEqual;\": \"\u2A7D\u0338\",\n\t\"NotNestedLessLess;\": \"\u2AA1\u0338\",\n\t\"NotReverseElement;\": \"\u220C\",\n\t\"NotSquareSuperset;\": \"\u2290\u0338\",\n\t\"NotTildeFullEqual;\": \"\u2247\",\n\t\"RightAngleBracket;\": \"\u27E9\",\n\t\"rightleftharpoons;\": \"\u21CC\",\n\t\"RightUpDownVector;\": \"\u294F\",\n\t\"SquareSubsetEqual;\": \"\u2291\",\n\t\"twoheadrightarrow;\": \"\u21A0\",\n\t\"VerticalSeparator;\": \"\u2758\",\n\t\"blacktriangleright;\": \"\u25B8\",\n\t\"DownRightTeeVector;\": \"\u295F\",\n\t\"DownRightVectorBar;\": \"\u2957\",\n\t\"LongLeftRightArrow;\": \"\u27F7\",\n\t\"Longleftrightarrow;\": \"\u27FA\",\n\t\"longleftrightarrow;\": \"\u27F7\",\n\t\"NegativeThickSpace;\": \"\u200B\",\n\t\"NotLeftTriangleBar;\": \"\u29CF\u0338\",\n\t\"PrecedesSlantEqual;\": \"\u227C\",\n\t\"ReverseEquilibrium;\": \"\u21CB\",\n\t\"RightDoubleBracket;\": \"\u27E7\",\n\t\"RightDownTeeVector;\": \"\u295D\",\n\t\"RightDownVectorBar;\": \"\u2955\",\n\t\"RightTriangleEqual;\": \"\u22B5\",\n\t\"SquareIntersection;\": \"\u2293\",\n\t\"SucceedsSlantEqual;\": \"\u227D\",\n\t\"DoubleLongLeftArrow;\": \"\u27F8\",\n\t\"DownLeftRightVector;\": \"\u2950\",\n\t\"LeftArrowRightArrow;\": \"\u21C6\",\n\t\"leftrightsquigarrow;\": \"\u21AD\",\n\t\"NegativeMediumSpace;\": \"\u200B\",\n\t\"NotGreaterFullEqual;\": \"\u2267\u0338\",\n\t\"NotRightTriangleBar;\": \"\u29D0\u0338\",\n\t\"RightArrowLeftArrow;\": \"\u21C4\",\n\t\"SquareSupersetEqual;\": \"\u2292\",\n\t\"CapitalDifferentialD;\": \"\u2145\",\n\t\"DoubleLeftRightArrow;\": \"\u21D4\",\n\t\"DoubleLongRightArrow;\": \"\u27F9\",\n\t\"EmptyVerySmallSquare;\": \"\u25AB\",\n\t\"NestedGreaterGreater;\": \"\u226B\",\n\t\"NotDoubleVerticalBar;\": \"\u2226\",\n\t\"NotGreaterSlantEqual;\": \"\u2A7E\u0338\",\n\t\"NotLeftTriangleEqual;\": \"\u22EC\",\n\t\"NotSquareSubsetEqual;\": \"\u22E2\",\n\t\"OpenCurlyDoubleQuote;\": \"\u201C\",\n\t\"ReverseUpEquilibrium;\": \"\u296F\",\n\t\"CloseCurlyDoubleQuote;\": \"\u201D\",\n\t\"DoubleContourIntegral;\": \"\u222F\",\n\t\"FilledVerySmallSquare;\": \"\u25AA\",\n\t\"NegativeVeryThinSpace;\": \"\u200B\",\n\t\"NotPrecedesSlantEqual;\": \"\u22E0\",\n\t\"NotRightTriangleEqual;\": \"\u22ED\",\n\t\"NotSucceedsSlantEqual;\": \"\u22E1\",\n\t\"DiacriticalDoubleAcute;\": \"\u02DD\",\n\t\"NotSquareSupersetEqual;\": \"\u22E3\",\n\t\"NotNestedGreaterGreater;\": \"\u2AA2\u0338\",\n\t\"ClockwiseContourIntegral;\": \"\u2232\",\n\t\"DoubleLongLeftRightArrow;\": \"\u27FA\",\n\t\"CounterClockwiseContourIntegral;\": \"\u2233\"\n};\n\nlet maxCRNameLength;\nconst decodeHtml = (rawText, asAttr) => {\n  let offset = 0;\n  const end = rawText.length;\n  let decodedText = \"\";\n  function advance(length) {\n    offset += length;\n    rawText = rawText.slice(length);\n  }\n  while (offset < end) {\n    const head = /&(?:#x?)?/i.exec(rawText);\n    if (!head || offset + head.index >= end) {\n      const remaining = end - offset;\n      decodedText += rawText.slice(0, remaining);\n      advance(remaining);\n      break;\n    }\n    decodedText += rawText.slice(0, head.index);\n    advance(head.index);\n    if (head[0] === \"&\") {\n      let name = \"\";\n      let value = void 0;\n      if (/[0-9a-z]/i.test(rawText[1])) {\n        if (!maxCRNameLength) {\n          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(\n            (max, name2) => Math.max(max, name2.length),\n            0\n          );\n        }\n        for (let length = maxCRNameLength; !value && length > 0; --length) {\n          name = rawText.slice(1, 1 + length);\n          value = namedCharacterReferences[name];\n        }\n        if (value) {\n          const semi = name.endsWith(\";\");\n          if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name.length + 1] || \"\")) {\n            decodedText += \"&\" + name;\n            advance(1 + name.length);\n          } else {\n            decodedText += value;\n            advance(1 + name.length);\n          }\n        } else {\n          decodedText += \"&\" + name;\n          advance(1 + name.length);\n        }\n      } else {\n        decodedText += \"&\";\n        advance(1);\n      }\n    } else {\n      const hex = head[0] === \"&#x\";\n      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;\n      const body = pattern.exec(rawText);\n      if (!body) {\n        decodedText += head[0];\n        advance(head[0].length);\n      } else {\n        let cp = Number.parseInt(body[1], hex ? 16 : 10);\n        if (cp === 0) {\n          cp = 65533;\n        } else if (cp > 1114111) {\n          cp = 65533;\n        } else if (cp >= 55296 && cp <= 57343) {\n          cp = 65533;\n        } else if (cp >= 64976 && cp <= 65007 || (cp & 65534) === 65534) ; else if (cp >= 1 && cp <= 8 || cp === 11 || cp >= 13 && cp <= 31 || cp >= 127 && cp <= 159) {\n          cp = CCR_REPLACEMENTS[cp] || cp;\n        }\n        decodedText += String.fromCodePoint(cp);\n        advance(body[0].length);\n      }\n    }\n  }\n  return decodedText;\n};\nconst CCR_REPLACEMENTS = {\n  128: 8364,\n  130: 8218,\n  131: 402,\n  132: 8222,\n  133: 8230,\n  134: 8224,\n  135: 8225,\n  136: 710,\n  137: 8240,\n  138: 352,\n  139: 8249,\n  140: 338,\n  142: 381,\n  145: 8216,\n  146: 8217,\n  147: 8220,\n  148: 8221,\n  149: 8226,\n  150: 8211,\n  151: 8212,\n  152: 732,\n  153: 8482,\n  154: 353,\n  155: 8250,\n  156: 339,\n  158: 382,\n  159: 376\n};\n\nconst isRawTextContainer = /* @__PURE__ */ shared.makeMap(\n  \"style,iframe,script,noscript\",\n  true\n);\nconst parserOptions = {\n  isVoidTag: shared.isVoidTag,\n  isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),\n  isPreTag: (tag) => tag === \"pre\",\n  decodeEntities: decodeHtml,\n  isBuiltInComponent: (tag) => {\n    if (compilerCore.isBuiltInType(tag, `Transition`)) {\n      return TRANSITION;\n    } else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {\n      return TRANSITION_GROUP;\n    }\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag, parent) {\n    let ns = parent ? parent.ns : 0;\n    if (parent && ns === 2) {\n      if (parent.tag === \"annotation-xml\") {\n        if (tag === \"svg\") {\n          return 1;\n        }\n        if (parent.props.some(\n          (a) => a.type === 6 && a.name === \"encoding\" && a.value != null && (a.value.content === \"text/html\" || a.value.content === \"application/xhtml+xml\")\n        )) {\n          ns = 0;\n        }\n      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== \"mglyph\" && tag !== \"malignmark\") {\n        ns = 0;\n      }\n    } else if (parent && ns === 1) {\n      if (parent.tag === \"foreignObject\" || parent.tag === \"desc\" || parent.tag === \"title\") {\n        ns = 0;\n      }\n    }\n    if (ns === 0) {\n      if (tag === \"svg\") {\n        return 1;\n      }\n      if (tag === \"math\") {\n        return 2;\n      }\n    }\n    return ns;\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode({ tag, ns }) {\n    if (ns === 0) {\n      if (tag === \"textarea\" || tag === \"title\") {\n        return 1;\n      }\n      if (isRawTextContainer(tag)) {\n        return 2;\n      }\n    }\n    return 0;\n  }\n};\n\nconst transformStyle = (node) => {\n  if (node.type === 1) {\n    node.props.forEach((p, i) => {\n      if (p.type === 6 && p.name === \"style\" && p.value) {\n        node.props[i] = {\n          type: 7,\n          name: `bind`,\n          arg: compilerCore.createSimpleExpression(`style`, true, p.loc),\n          exp: parseInlineCSS(p.value.content, p.loc),\n          modifiers: [],\n          loc: p.loc\n        };\n      }\n    });\n  }\n};\nconst parseInlineCSS = (cssText, loc) => {\n  const normalized = shared.parseStringStyle(cssText);\n  return compilerCore.createSimpleExpression(\n    JSON.stringify(normalized),\n    false,\n    loc,\n    3\n  );\n};\n\nfunction createDOMCompilerError(code, loc) {\n  return compilerCore.createCompilerError(\n    code,\n    loc,\n    DOMErrorMessages \n  );\n}\nconst DOMErrorMessages = {\n  [53]: `v-html is missing expression.`,\n  [54]: `v-html will override element children.`,\n  [55]: `v-text is missing expression.`,\n  [56]: `v-text will override element children.`,\n  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [58]: `v-model argument is not supported on plain elements.`,\n  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\n  [61]: `v-show is missing expression.`,\n  [62]: `<Transition> expects exactly one child element or component.`,\n  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\n};\n\nconst transformVHtml = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(53, loc)\n    );\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(54, loc)\n    );\n    node.children.length = 0;\n  }\n  return {\n    props: [\n      compilerCore.createObjectProperty(\n        compilerCore.createSimpleExpression(`innerHTML`, true, loc),\n        exp || compilerCore.createSimpleExpression(\"\", true)\n      )\n    ]\n  };\n};\n\nconst transformVText = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(55, loc)\n    );\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(56, loc)\n    );\n    node.children.length = 0;\n  }\n  return {\n    props: [\n      compilerCore.createObjectProperty(\n        compilerCore.createSimpleExpression(`textContent`, true),\n        exp ? compilerCore.getConstantType(exp, context) > 0 ? exp : compilerCore.createCallExpression(\n          context.helperString(compilerCore.TO_DISPLAY_STRING),\n          [exp],\n          loc\n        ) : compilerCore.createSimpleExpression(\"\", true)\n      )\n    ]\n  };\n};\n\nconst transformModel = (dir, node, context) => {\n  const baseResult = compilerCore.transformModel(dir, node, context);\n  if (!baseResult.props.length || node.tagType === 1) {\n    return baseResult;\n  }\n  if (dir.arg) {\n    context.onError(\n      createDOMCompilerError(\n        58,\n        dir.arg.loc\n      )\n    );\n  }\n  const { tag } = node;\n  const isCustomElement = context.isCustomElement(tag);\n  if (tag === \"input\" || tag === \"textarea\" || tag === \"select\" || isCustomElement) {\n    let directiveToUse = V_MODEL_TEXT;\n    let isInvalidType = false;\n    if (tag === \"input\" || isCustomElement) {\n      const type = compilerCore.findProp(node, `type`);\n      if (type) {\n        if (type.type === 7) {\n          directiveToUse = V_MODEL_DYNAMIC;\n        } else if (type.value) {\n          switch (type.value.content) {\n            case \"radio\":\n              directiveToUse = V_MODEL_RADIO;\n              break;\n            case \"checkbox\":\n              directiveToUse = V_MODEL_CHECKBOX;\n              break;\n            case \"file\":\n              isInvalidType = true;\n              context.onError(\n                createDOMCompilerError(\n                  59,\n                  dir.loc\n                )\n              );\n              break;\n          }\n        }\n      } else if (compilerCore.hasDynamicKeyVBind(node)) {\n        directiveToUse = V_MODEL_DYNAMIC;\n      } else ;\n    } else if (tag === \"select\") {\n      directiveToUse = V_MODEL_SELECT;\n    } else ;\n    if (!isInvalidType) {\n      baseResult.needRuntime = context.helper(directiveToUse);\n    }\n  } else {\n    context.onError(\n      createDOMCompilerError(\n        57,\n        dir.loc\n      )\n    );\n  }\n  baseResult.props = baseResult.props.filter(\n    (p) => !(p.key.type === 4 && p.key.content === \"modelValue\")\n  );\n  return baseResult;\n};\n\nconst isEventOptionModifier = /* @__PURE__ */ shared.makeMap(`passive,once,capture`);\nconst isNonKeyModifier = /* @__PURE__ */ shared.makeMap(\n  // event propagation management\n  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`\n);\nconst maybeKeyModifier = /* @__PURE__ */ shared.makeMap(\"left,right\");\nconst isKeyboardEvent = /* @__PURE__ */ shared.makeMap(\n  `onkeyup,onkeydown,onkeypress`,\n  true\n);\nconst resolveModifiers = (key, modifiers, context, loc) => {\n  const keyModifiers = [];\n  const nonKeyModifiers = [];\n  const eventOptionModifiers = [];\n  for (let i = 0; i < modifiers.length; i++) {\n    const modifier = modifiers[i];\n    if (modifier === \"native\" && compilerCore.checkCompatEnabled(\n      \"COMPILER_V_ON_NATIVE\",\n      context,\n      loc\n    )) {\n      eventOptionModifiers.push(modifier);\n    } else if (isEventOptionModifier(modifier)) {\n      eventOptionModifiers.push(modifier);\n    } else {\n      if (maybeKeyModifier(modifier)) {\n        if (compilerCore.isStaticExp(key)) {\n          if (isKeyboardEvent(key.content)) {\n            keyModifiers.push(modifier);\n          } else {\n            nonKeyModifiers.push(modifier);\n          }\n        } else {\n          keyModifiers.push(modifier);\n          nonKeyModifiers.push(modifier);\n        }\n      } else {\n        if (isNonKeyModifier(modifier)) {\n          nonKeyModifiers.push(modifier);\n        } else {\n          keyModifiers.push(modifier);\n        }\n      }\n    }\n  }\n  return {\n    keyModifiers,\n    nonKeyModifiers,\n    eventOptionModifiers\n  };\n};\nconst transformClick = (key, event) => {\n  const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === \"onclick\";\n  return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([\n    `(`,\n    key,\n    `) === \"onClick\" ? \"${event}\" : (`,\n    key,\n    `)`\n  ]) : key;\n};\nconst transformOn = (dir, node, context) => {\n  return compilerCore.transformOn(dir, node, context, (baseResult) => {\n    const { modifiers } = dir;\n    if (!modifiers.length)\n      return baseResult;\n    let { key, value: handlerExp } = baseResult.props[0];\n    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);\n    if (nonKeyModifiers.includes(\"right\")) {\n      key = transformClick(key, `onContextmenu`);\n    }\n    if (nonKeyModifiers.includes(\"middle\")) {\n      key = transformClick(key, `onMouseup`);\n    }\n    if (nonKeyModifiers.length) {\n      handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\n        handlerExp,\n        JSON.stringify(nonKeyModifiers)\n      ]);\n    }\n    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard\n    (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {\n      handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [\n        handlerExp,\n        JSON.stringify(keyModifiers)\n      ]);\n    }\n    if (eventOptionModifiers.length) {\n      const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join(\"\");\n      key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`]);\n    }\n    return {\n      props: [compilerCore.createObjectProperty(key, handlerExp)]\n    };\n  });\n};\n\nconst transformShow = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(61, loc)\n    );\n  }\n  return {\n    props: [],\n    needRuntime: context.helper(V_SHOW)\n  };\n};\n\nconst expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;\nconst stringifyStatic = (children, context, parent) => {\n  if (context.scopes.vSlot > 0) {\n    return;\n  }\n  let nc = 0;\n  let ec = 0;\n  const currentChunk = [];\n  const stringifyCurrentChunk = (currentIndex) => {\n    if (nc >= 20 || ec >= 5) {\n      const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [\n        JSON.stringify(\n          currentChunk.map((node) => stringifyNode(node, context)).join(\"\")\n        ).replace(expReplaceRE, `\" + $1 + \"`),\n        // the 2nd argument indicates the number of DOM nodes this static vnode\n        // will insert / hydrate\n        String(currentChunk.length)\n      ]);\n      replaceHoist(currentChunk[0], staticCall, context);\n      if (currentChunk.length > 1) {\n        for (let i2 = 1; i2 < currentChunk.length; i2++) {\n          replaceHoist(currentChunk[i2], null, context);\n        }\n        const deleteCount = currentChunk.length - 1;\n        children.splice(currentIndex - currentChunk.length + 1, deleteCount);\n        return deleteCount;\n      }\n    }\n    return 0;\n  };\n  let i = 0;\n  for (; i < children.length; i++) {\n    const child = children[i];\n    const hoisted = getHoistedNode(child);\n    if (hoisted) {\n      const node = child;\n      const result = analyzeNode(node);\n      if (result) {\n        nc += result[0];\n        ec += result[1];\n        currentChunk.push(node);\n        continue;\n      }\n    }\n    i -= stringifyCurrentChunk(i);\n    nc = 0;\n    ec = 0;\n    currentChunk.length = 0;\n  }\n  stringifyCurrentChunk(i);\n};\nconst getHoistedNode = (node) => (node.type === 1 && node.tagType === 0 || node.type == 12) && node.codegenNode && node.codegenNode.type === 4 && node.codegenNode.hoisted;\nconst dataAriaRE = /^(data|aria)-/;\nconst isStringifiableAttr = (name, ns) => {\n  return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);\n};\nconst replaceHoist = (node, replacement, context) => {\n  const hoistToReplace = node.codegenNode.hoisted;\n  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;\n};\nconst isNonStringifiable = /* @__PURE__ */ shared.makeMap(\n  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`\n);\nfunction analyzeNode(node) {\n  if (node.type === 1 && isNonStringifiable(node.tag)) {\n    return false;\n  }\n  if (node.type === 12) {\n    return [1, 0];\n  }\n  let nc = 1;\n  let ec = node.props.length > 0 ? 1 : 0;\n  let bailed = false;\n  const bail = () => {\n    bailed = true;\n    return false;\n  };\n  function walk(node2) {\n    for (let i = 0; i < node2.props.length; i++) {\n      const p = node2.props[i];\n      if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {\n        return bail();\n      }\n      if (p.type === 7 && p.name === \"bind\") {\n        if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {\n          return bail();\n        }\n        if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) {\n          return bail();\n        }\n      }\n    }\n    for (let i = 0; i < node2.children.length; i++) {\n      nc++;\n      const child = node2.children[i];\n      if (child.type === 1) {\n        if (child.props.length > 0) {\n          ec++;\n        }\n        walk(child);\n        if (bailed) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  return walk(node) ? [nc, ec] : false;\n}\nfunction stringifyNode(node, context) {\n  if (shared.isString(node)) {\n    return node;\n  }\n  if (shared.isSymbol(node)) {\n    return ``;\n  }\n  switch (node.type) {\n    case 1:\n      return stringifyElement(node, context);\n    case 2:\n      return shared.escapeHtml(node.content);\n    case 3:\n      return `<!--${shared.escapeHtml(node.content)}-->`;\n    case 5:\n      return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));\n    case 8:\n      return shared.escapeHtml(evaluateConstant(node));\n    case 12:\n      return stringifyNode(node.content, context);\n    default:\n      return \"\";\n  }\n}\nfunction stringifyElement(node, context) {\n  let res = `<${node.tag}`;\n  let innerHTML = \"\";\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 6) {\n      res += ` ${p.name}`;\n      if (p.value) {\n        res += `=\"${shared.escapeHtml(p.value.content)}\"`;\n      }\n    } else if (p.type === 7) {\n      if (p.name === \"bind\") {\n        const exp = p.exp;\n        if (exp.content[0] === \"_\") {\n          res += ` ${p.arg.content}=\"__VUE_EXP_START__${exp.content}__VUE_EXP_END__\"`;\n          continue;\n        }\n        if (shared.isBooleanAttr(p.arg.content) && exp.content === \"false\") {\n          continue;\n        }\n        let evaluated = evaluateConstant(exp);\n        if (evaluated != null) {\n          const arg = p.arg && p.arg.content;\n          if (arg === \"class\") {\n            evaluated = shared.normalizeClass(evaluated);\n          } else if (arg === \"style\") {\n            evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));\n          }\n          res += ` ${p.arg.content}=\"${shared.escapeHtml(\n            evaluated\n          )}\"`;\n        }\n      } else if (p.name === \"html\") {\n        innerHTML = evaluateConstant(p.exp);\n      } else if (p.name === \"text\") {\n        innerHTML = shared.escapeHtml(\n          shared.toDisplayString(evaluateConstant(p.exp))\n        );\n      }\n    }\n  }\n  if (context.scopeId) {\n    res += ` ${context.scopeId}`;\n  }\n  res += `>`;\n  if (innerHTML) {\n    res += innerHTML;\n  } else {\n    for (let i = 0; i < node.children.length; i++) {\n      res += stringifyNode(node.children[i], context);\n    }\n  }\n  if (!shared.isVoidTag(node.tag)) {\n    res += `</${node.tag}>`;\n  }\n  return res;\n}\nfunction evaluateConstant(exp) {\n  if (exp.type === 4) {\n    return new Function(`return (${exp.content})`)();\n  } else {\n    let res = ``;\n    exp.children.forEach((c) => {\n      if (shared.isString(c) || shared.isSymbol(c)) {\n        return;\n      }\n      if (c.type === 2) {\n        res += c.content;\n      } else if (c.type === 5) {\n        res += shared.toDisplayString(evaluateConstant(c.content));\n      } else {\n        res += evaluateConstant(c);\n      }\n    });\n    return res;\n  }\n}\n\nconst ignoreSideEffectTags = (node, context) => {\n  if (node.type === 1 && node.tagType === 0 && (node.tag === \"script\" || node.tag === \"style\")) {\n    context.removeNode();\n  }\n};\n\nconst DOMNodeTransforms = [\n  transformStyle,\n  ...[]\n];\nconst DOMDirectiveTransforms = {\n  cloak: compilerCore.noopDirectiveTransform,\n  html: transformVHtml,\n  text: transformVText,\n  model: transformModel,\n  // override compiler-core\n  on: transformOn,\n  // override compiler-core\n  show: transformShow\n};\nfunction compile(template, options = {}) {\n  return compilerCore.baseCompile(\n    template,\n    shared.extend({}, parserOptions, options, {\n      nodeTransforms: [\n        // ignore <script> and <tag>\n        // this is not put inside DOMNodeTransforms because that list is used\n        // by compiler-ssr to generate vnode fallback branches\n        ignoreSideEffectTags,\n        ...DOMNodeTransforms,\n        ...options.nodeTransforms || []\n      ],\n      directiveTransforms: shared.extend(\n        {},\n        DOMDirectiveTransforms,\n        options.directiveTransforms || {}\n      ),\n      transformHoist: stringifyStatic\n    })\n  );\n}\nfunction parse(template, options = {}) {\n  return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));\n}\n\nexports.DOMDirectiveTransforms = DOMDirectiveTransforms;\nexports.DOMNodeTransforms = DOMNodeTransforms;\nexports.TRANSITION = TRANSITION;\nexports.TRANSITION_GROUP = TRANSITION_GROUP;\nexports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;\nexports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;\nexports.V_MODEL_RADIO = V_MODEL_RADIO;\nexports.V_MODEL_SELECT = V_MODEL_SELECT;\nexports.V_MODEL_TEXT = V_MODEL_TEXT;\nexports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;\nexports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;\nexports.V_SHOW = V_SHOW;\nexports.compile = compile;\nexports.createDOMCompilerError = createDOMCompilerError;\nexports.parse = parse;\nexports.parserOptions = parserOptions;\nexports.transformStyle = transformStyle;\nObject.keys(compilerCore).forEach(function (k) {\n  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = compilerCore[k];\n});\n", "'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/compiler-dom.cjs.prod.js')\n} else {\n  module.exports = require('./dist/compiler-dom.cjs.js')\n}\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar shared = require('@vue/shared');\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  }\n}\n\nconst createDep = (effects) => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit;\n    }\n  }\n};\nconst finalizeDepMarkers = (effect) => {\n  const { deps } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\n\nconst targetMap = /* @__PURE__ */ new WeakMap();\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol(\"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(\"\");\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = void 0;\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n      parent = parent.parent;\n    }\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = void 0;\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n  stop() {\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nfunction cleanupEffect(effect2) {\n  const { deps } = effect2;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect2);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    shared.extend(_effect, options);\n    if (options.scope)\n      recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    trackEffects(dep);\n  }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack2 = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit;\n      shouldTrack2 = !wasTracked(dep);\n    }\n  } else {\n    shouldTrack2 = !dep.has(activeEffect);\n  }\n  if (shouldTrack2) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && shared.isArray(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || !shared.isSymbol(key2) && key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!shared.isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (shared.isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (shared.isIntegerKey(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!shared.isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (shared.isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (shared.isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  if (deps.length === 1) {\n    if (deps[0]) {\n      {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = shared.isArray(dep) ? dep : [...dep];\n  for (const effect2 of effects) {\n    if (effect2.computed) {\n      triggerEffect(effect2);\n    }\n  }\n  for (const effect2 of effects) {\n    if (!effect2.computed) {\n      triggerEffect(effect2);\n    }\n  }\n}\nfunction triggerEffect(effect2, debuggerEventExtraInfo) {\n  if (effect2 !== activeEffect || effect2.allowRecurse) {\n    if (effect2.scheduler) {\n      effect2.scheduler();\n    } else {\n      effect2.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(shared.isSymbol)\n);\nconst arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _shallow = false) {\n    this._isReadonly = _isReadonly;\n    this._shallow = _shallow;\n  }\n  get(target, key, receiver) {\n    const isReadonly2 = this._isReadonly, shallow = this._shallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return shallow;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = shared.isArray(target);\n    if (!isReadonly2) {\n      if (targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && shared.isIntegerKey(key) ? res : res.value;\n    }\n    if (shared.isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(shallow = false) {\n    super(false, shallow);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n    if (!this._shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (shared.hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = shared.hasOwn(target, key);\n    target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      shared.isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(shallow = false) {\n    super(true, shallow);\n  }\n  set(target, key) {\n    return true;\n  }\n  deleteProperty(target, key) {\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(\n  true\n);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (shared.hasChanged(key, rawKey)) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (shared.hasChanged(key, rawKey)) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (shared.hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  }\n  get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = shared.isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      false\n    );\n    readonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      false\n    );\n    shallowInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      true\n    );\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      true\n    );\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(shared.toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!shared.isObject(target)) {\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  shared.def(value, \"__v_skip\", true);\n  return value;\n}\nconst toReactive = (value) => shared.isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref2) {\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n    {\n      trackEffects(ref2.dep || (ref2.dep = createDep()));\n    }\n  }\n}\nfunction triggerRefValue(ref2, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    {\n      triggerEffects(dep);\n    }\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if (shared.hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2);\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return shared.isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    );\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  const ret = shared.isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (shared.isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (shared.isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n  get value() {\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = shared.isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = shared.NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  return cRef;\n}\n\nconst tick = /* @__PURE__ */ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = void 0;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(\n              true\n              /* computedTrigger */\n            );\n          }\n        }\n      }\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    return toRaw(this)._get();\n  }\n}\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\nexports.EffectScope = EffectScope;\nexports.ITERATE_KEY = ITERATE_KEY;\nexports.ReactiveEffect = ReactiveEffect;\nexports.computed = computed;\nexports.customRef = customRef;\nexports.deferredComputed = deferredComputed;\nexports.effect = effect;\nexports.effectScope = effectScope;\nexports.enableTracking = enableTracking;\nexports.getCurrentScope = getCurrentScope;\nexports.isProxy = isProxy;\nexports.isReactive = isReactive;\nexports.isReadonly = isReadonly;\nexports.isRef = isRef;\nexports.isShallow = isShallow;\nexports.markRaw = markRaw;\nexports.onScopeDispose = onScopeDispose;\nexports.pauseTracking = pauseTracking;\nexports.proxyRefs = proxyRefs;\nexports.reactive = reactive;\nexports.readonly = readonly;\nexports.ref = ref;\nexports.resetTracking = resetTracking;\nexports.shallowReactive = shallowReactive;\nexports.shallowReadonly = shallowReadonly;\nexports.shallowRef = shallowRef;\nexports.stop = stop;\nexports.toRaw = toRaw;\nexports.toRef = toRef;\nexports.toRefs = toRefs;\nexports.toValue = toValue;\nexports.track = track;\nexports.trigger = trigger;\nexports.triggerRef = triggerRef;\nexports.unref = unref;\n", "'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/reactivity.cjs.prod.js')\n} else {\n  module.exports = require('./dist/reactivity.cjs.js')\n}\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar reactivity = require('@vue/reactivity');\nvar shared = require('@vue/shared');\n\nfunction warn$1(msg, ...args) {\n  return;\n}\nfunction assertNumber(val, type) {\n  return;\n}\n\nfunction callWithErrorHandling(fn, instance, type, args) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n  return res;\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if (shared.isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && shared.isPromise(res)) {\n      res.catch((err) => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  const values = [];\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n  }\n  return values;\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n  if (instance) {\n    let cur = instance.parent;\n    const exposedInstance = instance.proxy;\n    const errorInfo = type;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    const appErrorHandler = instance.appContext.config.errorHandler;\n    if (appErrorHandler) {\n      callWithErrorHandling(\n        appErrorHandler,\n        null,\n        10,\n        [err, exposedInstance, errorInfo]\n      );\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  {\n    console.error(err);\n  }\n}\n\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /* @__PURE__ */ Promise.resolve();\nlet currentFlushPromise = null;\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\nfunction findInsertionIndex(id) {\n  let start = flushIndex + 1;\n  let end = queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJob = queue[middle];\n    const middleJobId = getId(middleJob);\n    if (middleJobId < id || middleJobId === id && middleJob.pre) {\n      start = middle + 1;\n    } else {\n      end = middle;\n    }\n  }\n  return start;\n}\nfunction queueJob(job) {\n  if (!queue.length || !queue.includes(\n    job,\n    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex\n  )) {\n    if (job.id == null) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(job.id), 0, job);\n    }\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction invalidateJob(job) {\n  const i = queue.indexOf(job);\n  if (i > flushIndex) {\n    queue.splice(i, 1);\n  }\n}\nfunction queuePostFlushCb(cb) {\n  if (!shared.isArray(cb)) {\n    if (!activePostFlushCbs || !activePostFlushCbs.includes(\n      cb,\n      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex\n    )) {\n      pendingPostFlushCbs.push(cb);\n    }\n  } else {\n    pendingPostFlushCbs.push(...cb);\n  }\n  queueFlush();\n}\nfunction flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {\n  for (; i < queue.length; i++) {\n    const cb = queue[i];\n    if (cb && cb.pre) {\n      queue.splice(i, 1);\n      i--;\n      cb();\n    }\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)];\n    pendingPostFlushCbs.length = 0;\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      activePostFlushCbs[postFlushIndex]();\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = (job) => job.id == null ? Infinity : job.id;\nconst comparator = (a, b) => {\n  const diff = getId(a) - getId(b);\n  if (diff === 0) {\n    if (a.pre && !b.pre)\n      return -1;\n    if (b.pre && !a.pre)\n      return 1;\n  }\n  return diff;\n};\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n  queue.sort(comparator);\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job && job.active !== false) {\n        if (false) ;\n        callWithErrorHandling(job, null, 14);\n      }\n    }\n  } finally {\n    flushIndex = 0;\n    queue.length = 0;\n    flushPostFlushCbs();\n    isFlushing = false;\n    currentFlushPromise = null;\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs();\n    }\n  }\n}\n\nexports.devtools = void 0;\nlet buffer = [];\nfunction setDevtoolsHook(hook, target) {\n  var _a, _b;\n  exports.devtools = hook;\n  if (exports.devtools) {\n    exports.devtools.enabled = true;\n    buffer.forEach(({ event, args }) => exports.devtools.emit(event, ...args));\n    buffer = [];\n  } else if (\n    // handle late devtools injection - only do this if we are in an actual\n    // browser environment to avoid the timer handle stalling test runner exit\n    // (#4815)\n    typeof window !== \"undefined\" && // some envs mock window but not fully\n    window.HTMLElement && // also exclude jsdom\n    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes(\"jsdom\"))\n  ) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push((newHook) => {\n      setDevtoolsHook(newHook, target);\n    });\n    setTimeout(() => {\n      if (!exports.devtools) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        buffer = [];\n      }\n    }, 3e3);\n  } else {\n    buffer = [];\n  }\n}\n\nfunction emit(instance, event, ...rawArgs) {\n  if (instance.isUnmounted)\n    return;\n  const props = instance.vnode.props || shared.EMPTY_OBJ;\n  let args = rawArgs;\n  const isModelListener = event.startsWith(\"update:\");\n  const modelArg = isModelListener && event.slice(7);\n  if (modelArg && modelArg in props) {\n    const modifiersKey = `${modelArg === \"modelValue\" ? \"model\" : modelArg}Modifiers`;\n    const { number, trim } = props[modifiersKey] || shared.EMPTY_OBJ;\n    if (trim) {\n      args = rawArgs.map((a) => shared.isString(a) ? a.trim() : a);\n    }\n    if (number) {\n      args = rawArgs.map(shared.looseToNumber);\n    }\n  }\n  let handlerName;\n  let handler = props[handlerName = shared.toHandlerKey(event)] || // also try camelCase event handler (#2249)\n  props[handlerName = shared.toHandlerKey(shared.camelize(event))];\n  if (!handler && isModelListener) {\n    handler = props[handlerName = shared.toHandlerKey(shared.hyphenate(event))];\n  }\n  if (handler) {\n    callWithAsyncErrorHandling(\n      handler,\n      instance,\n      6,\n      args\n    );\n  }\n  const onceHandler = props[handlerName + `Once`];\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {};\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n    instance.emitted[handlerName] = true;\n    callWithAsyncErrorHandling(\n      onceHandler,\n      instance,\n      6,\n      args\n    );\n  }\n}\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.emitsCache;\n  const cached = cache.get(comp);\n  if (cached !== void 0) {\n    return cached;\n  }\n  const raw = comp.emits;\n  let normalized = {};\n  let hasExtends = false;\n  if (!shared.isFunction(comp)) {\n    const extendEmits = (raw2) => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);\n      if (normalizedFromExtend) {\n        hasExtends = true;\n        shared.extend(normalized, normalizedFromExtend);\n      }\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if (shared.isObject(comp)) {\n      cache.set(comp, null);\n    }\n    return null;\n  }\n  if (shared.isArray(raw)) {\n    raw.forEach((key) => normalized[key] = null);\n  } else {\n    shared.extend(normalized, raw);\n  }\n  if (shared.isObject(comp)) {\n    cache.set(comp, normalized);\n  }\n  return normalized;\n}\nfunction isEmitListener(options, key) {\n  if (!options || !shared.isOn(key)) {\n    return false;\n  }\n  key = key.slice(2).replace(/Once$/, \"\");\n  return shared.hasOwn(options, key[0].toLowerCase() + key.slice(1)) || shared.hasOwn(options, shared.hyphenate(key)) || shared.hasOwn(options, key);\n}\n\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\nfunction setCurrentRenderingInstance(instance) {\n  const prev = currentRenderingInstance;\n  currentRenderingInstance = instance;\n  currentScopeId = instance && instance.type.__scopeId || null;\n  return prev;\n}\nfunction pushScopeId(id) {\n  currentScopeId = id;\n}\nfunction popScopeId() {\n  currentScopeId = null;\n}\nconst withScopeId = (_id) => withCtx;\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {\n  if (!ctx)\n    return fn;\n  if (fn._n) {\n    return fn;\n  }\n  const renderFnWithContext = (...args) => {\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1);\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx);\n    let res;\n    try {\n      res = fn(...args);\n    } finally {\n      setCurrentRenderingInstance(prevInstance);\n      if (renderFnWithContext._d) {\n        setBlockTracking(1);\n      }\n    }\n    return res;\n  };\n  renderFnWithContext._n = true;\n  renderFnWithContext._c = true;\n  renderFnWithContext._d = true;\n  return renderFnWithContext;\n}\n\nfunction markAttrsAccessed() {\n}\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    props,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance;\n  let result;\n  let fallthroughAttrs;\n  const prev = setCurrentRenderingInstance(instance);\n  try {\n    if (vnode.shapeFlag & 4) {\n      const proxyToUse = withProxy || proxy;\n      const thisProxy = false ? new Proxy(proxyToUse, {\n        get(target, key, receiver) {\n          warn(\n            `Property '${String(\n              key\n            )}' was accessed via 'this'. Avoid using 'this' in templates.`\n          );\n          return Reflect.get(target, key, receiver);\n        }\n      }) : proxyToUse;\n      result = normalizeVNode(\n        render.call(\n          thisProxy,\n          proxyToUse,\n          renderCache,\n          props,\n          setupState,\n          data,\n          ctx\n        )\n      );\n      fallthroughAttrs = attrs;\n    } else {\n      const render2 = Component;\n      if (false) ;\n      result = normalizeVNode(\n        render2.length > 1 ? render2(\n          props,\n          false ? {\n            get attrs() {\n              markAttrsAccessed();\n              return attrs;\n            },\n            slots,\n            emit\n          } : { attrs, slots, emit }\n        ) : render2(\n          props,\n          null\n          /* we know it doesn't need it */\n        )\n      );\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    }\n  } catch (err) {\n    blockStack.length = 0;\n    handleError(err, instance, 1);\n    result = createVNode(Comment);\n  }\n  let root = result;\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs);\n    const { shapeFlag } = root;\n    if (keys.length) {\n      if (shapeFlag & (1 | 6)) {\n        if (propsOptions && keys.some(shared.isModelListener)) {\n          fallthroughAttrs = filterModelListeners(\n            fallthroughAttrs,\n            propsOptions\n          );\n        }\n        root = cloneVNode(root, fallthroughAttrs);\n      }\n    }\n  }\n  if (vnode.dirs) {\n    root = cloneVNode(root);\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n  }\n  if (vnode.transition) {\n    root.transition = vnode.transition;\n  }\n  {\n    result = root;\n  }\n  setCurrentRenderingInstance(prev);\n  return result;\n}\nfunction filterSingleRoot(children) {\n  let singleRoot;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (isVNode(child)) {\n      if (child.type !== Comment || child.children === \"v-if\") {\n        if (singleRoot) {\n          return;\n        } else {\n          singleRoot = child;\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  return singleRoot;\n}\nconst getFunctionalFallthrough = (attrs) => {\n  let res;\n  for (const key in attrs) {\n    if (key === \"class\" || key === \"style\" || shared.isOn(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n  for (const key in attrs) {\n    if (!shared.isModelListener(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n  return res;\n};\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const { props: prevProps, children: prevChildren, component } = prevVNode;\n  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\n  const emits = component.emitsOptions;\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & 1024) {\n      return true;\n    }\n    if (patchFlag & 16) {\n      if (!prevProps) {\n        return !!nextProps;\n      }\n      return hasPropsChanged(prevProps, nextProps, emits);\n    } else if (patchFlag & 8) {\n      const dynamicProps = nextVNode.dynamicProps;\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i];\n        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n    if (prevProps === nextProps) {\n      return false;\n    }\n    if (!prevProps) {\n      return !!nextProps;\n    }\n    if (!nextProps) {\n      return true;\n    }\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n  return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction updateHOCHostEl({ vnode, parent }, el) {\n  while (parent && parent.subTree === vnode) {\n    (vnode = parent.vnode).el = el;\n    parent = parent.parent;\n  }\n}\n\nconst COMPONENTS = \"components\";\nconst DIRECTIVES = \"directives\";\nfunction resolveComponent(name, maybeSelfReference) {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nconst NULL_DYNAMIC_COMPONENT = Symbol.for(\"v-ndc\");\nfunction resolveDynamicComponent(component) {\n  if (shared.isString(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n}\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\n  const instance = currentRenderingInstance || currentInstance;\n  if (instance) {\n    const Component = instance.type;\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(\n        Component,\n        false\n        /* do not include inferred name to avoid breaking existing code */\n      );\n      if (selfName && (selfName === name || selfName === shared.camelize(name) || selfName === shared.capitalize(shared.camelize(name)))) {\n        return Component;\n      }\n    }\n    const res = (\n      // local registration\n      // check instance[type] first which is resolved for options API\n      resolve(instance[type] || Component[type], name) || // global registration\n      resolve(instance.appContext[type], name)\n    );\n    if (!res && maybeSelfReference) {\n      return Component;\n    }\n    return res;\n  }\n}\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[shared.camelize(name)] || registry[shared.capitalize(shared.camelize(name))]);\n}\n\nconst isSuspense = (type) => type.__isSuspense;\nconst SuspenseImpl = {\n  name: \"Suspense\",\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      );\n    } else {\n      patchSuspense(\n        n1,\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        isSVG,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      );\n    }\n  },\n  hydrate: hydrateSuspense,\n  create: createSuspenseBoundary,\n  normalize: normalizeSuspenseChildren\n};\nconst Suspense = SuspenseImpl ;\nfunction triggerEvent(vnode, name) {\n  const eventListener = vnode.props && vnode.props[name];\n  if (shared.isFunction(eventListener)) {\n    eventListener();\n  }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: { createElement }\n  } = rendererInternals;\n  const hiddenContainer = createElement(\"div\");\n  const suspense = vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    container,\n    hiddenContainer,\n    anchor,\n    isSVG,\n    slotScopeIds,\n    optimized,\n    rendererInternals\n  );\n  patch(\n    null,\n    suspense.pendingBranch = vnode.ssContent,\n    hiddenContainer,\n    null,\n    parentComponent,\n    suspense,\n    isSVG,\n    slotScopeIds\n  );\n  if (suspense.deps > 0) {\n    triggerEvent(vnode, \"onPending\");\n    triggerEvent(vnode, \"onFallback\");\n    patch(\n      null,\n      vnode.ssFallback,\n      container,\n      anchor,\n      parentComponent,\n      null,\n      // fallback tree will not have suspense context\n      isSVG,\n      slotScopeIds\n    );\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    suspense.resolve(false, true);\n  }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      patch(\n        pendingBranch,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      );\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        patch(\n          activeBranch,\n          newFallback,\n          container,\n          anchor,\n          parentComponent,\n          null,\n          // fallback tree will not have suspense context\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n        setActiveBranch(suspense, newFallback);\n      }\n    } else {\n      suspense.pendingId++;\n      if (isHydrating) {\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      }\n      suspense.deps = 0;\n      suspense.effects.length = 0;\n      suspense.hiddenContainer = createElement(\"div\");\n      if (isInFallback) {\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(\n            activeBranch,\n            newFallback,\n            container,\n            anchor,\n            parentComponent,\n            null,\n            // fallback tree will not have suspense context\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        patch(\n          activeBranch,\n          newBranch,\n          container,\n          anchor,\n          parentComponent,\n          suspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n        suspense.resolve(true);\n      } else {\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      patch(\n        activeBranch,\n        newBranch,\n        container,\n        anchor,\n        parentComponent,\n        suspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      );\n      setActiveBranch(suspense, newBranch);\n    } else {\n      triggerEvent(n2, \"onPending\");\n      suspense.pendingBranch = newBranch;\n      suspense.pendingId++;\n      patch(\n        null,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      );\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else {\n        const { timeout, pendingId } = suspense;\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\nfunction createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: { parentNode, remove }\n  } = rendererInternals;\n  let parentSuspenseId;\n  const isSuspensible = isVNodeSuspensible(vnode);\n  if (isSuspensible) {\n    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {\n      parentSuspenseId = parentSuspense.pendingId;\n      parentSuspense.deps++;\n    }\n  }\n  const timeout = vnode.props ? shared.toNumber(vnode.props.timeout) : void 0;\n  const suspense = {\n    vnode,\n    parent: parentSuspense,\n    parentComponent,\n    isSVG,\n    container,\n    hiddenContainer,\n    anchor,\n    deps: 0,\n    pendingId: 0,\n    timeout: typeof timeout === \"number\" ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: true,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n    resolve(resume = false, sync = false) {\n      const {\n        vnode: vnode2,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent: parentComponent2,\n        container: container2\n      } = suspense;\n      let delayEnter = false;\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === \"out-in\";\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(pendingBranch, container2, anchor2, 0);\n              queuePostFlushCb(effects);\n            }\n          };\n        }\n        let { anchor: anchor2 } = suspense;\n        if (activeBranch) {\n          anchor2 = next(activeBranch);\n          unmount(activeBranch, parentComponent2, suspense, true);\n        }\n        if (!delayEnter) {\n          move(pendingBranch, container2, anchor2, 0);\n        }\n      }\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false;\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n      while (parent) {\n        if (parent.pendingBranch) {\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!hasUnresolvedAncestor && !delayEnter) {\n        queuePostFlushCb(effects);\n      }\n      suspense.effects = [];\n      if (isSuspensible) {\n        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {\n          parentSuspense.deps--;\n          if (parentSuspense.deps === 0 && !sync) {\n            parentSuspense.resolve();\n          }\n        }\n      }\n      triggerEvent(vnode2, \"onResolve\");\n    },\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;\n      triggerEvent(vnode2, \"onFallback\");\n      const anchor2 = next(activeBranch);\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        }\n        patch(\n          null,\n          fallbackVNode,\n          container2,\n          anchor2,\n          parentComponent2,\n          null,\n          // fallback tree will not have suspense context\n          isSVG2,\n          slotScopeIds,\n          optimized\n        );\n        setActiveBranch(suspense, fallbackVNode);\n      };\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === \"out-in\";\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      }\n      suspense.isInFallback = true;\n      unmount(\n        activeBranch,\n        parentComponent2,\n        null,\n        // no suspense so unmount hooks fire now\n        true\n        // shouldRemove\n      );\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n    move(container2, anchor2, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);\n      suspense.container = container2;\n    },\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n    registerDep(instance, setupRenderEffect) {\n      const isInPendingSuspense = !!suspense.pendingBranch;\n      if (isInPendingSuspense) {\n        suspense.deps++;\n      }\n      const hydratedEl = instance.vnode.el;\n      instance.asyncDep.catch((err) => {\n        handleError(err, instance, 0);\n      }).then((asyncSetupResult) => {\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n        instance.asyncResolved = true;\n        const { vnode: vnode2 } = instance;\n        handleSetupResult(instance, asyncSetupResult, false);\n        if (hydratedEl) {\n          vnode2.el = hydratedEl;\n        }\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(\n          instance,\n          vnode2,\n          // component may have been moved before resolve.\n          // if this is not a hydration, instance.subTree will be the comment\n          // placeholder.\n          parentNode(hydratedEl || instance.subTree.el),\n          // anchor will not be used if this is hydration, so only need to\n          // consider the comment placeholder case.\n          hydratedEl ? null : next(instance.subTree),\n          suspense,\n          isSVG,\n          optimized\n        );\n        if (placeholder) {\n          remove(placeholder);\n        }\n        updateHOCHostEl(instance, vnode2.el);\n        if (isInPendingSuspense && --suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n    unmount(parentSuspense2, doRemove) {\n      suspense.isUnmounted = true;\n      if (suspense.activeBranch) {\n        unmount(\n          suspense.activeBranch,\n          parentComponent,\n          parentSuspense2,\n          doRemove\n        );\n      }\n      if (suspense.pendingBranch) {\n        unmount(\n          suspense.pendingBranch,\n          parentComponent,\n          parentSuspense2,\n          doRemove\n        );\n      }\n    }\n  };\n  return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n  const suspense = vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    node.parentNode,\n    document.createElement(\"div\"),\n    null,\n    isSVG,\n    slotScopeIds,\n    optimized,\n    rendererInternals,\n    true\n    /* hydrating */\n  );\n  const result = hydrateNode(\n    node,\n    suspense.pendingBranch = vnode.ssContent,\n    parentComponent,\n    suspense,\n    slotScopeIds,\n    optimized\n  );\n  if (suspense.deps === 0) {\n    suspense.resolve(false, true);\n  }\n  return result;\n}\nfunction normalizeSuspenseChildren(vnode) {\n  const { shapeFlag, children } = vnode;\n  const isSlotChildren = shapeFlag & 32;\n  vnode.ssContent = normalizeSuspenseSlot(\n    isSlotChildren ? children.default : children\n  );\n  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n  let block;\n  if (shared.isFunction(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c;\n    if (trackBlock) {\n      s._d = false;\n      openBlock();\n    }\n    s = s();\n    if (trackBlock) {\n      s._d = true;\n      block = currentBlock;\n      closeBlock();\n    }\n  }\n  if (shared.isArray(s)) {\n    const singleChild = filterSingleRoot(s);\n    s = singleChild;\n  }\n  s = normalizeVNode(s);\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter((c) => c !== s);\n  }\n  return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if (shared.isArray(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const { vnode, parentComponent } = suspense;\n  const el = vnode.el = branch.el;\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\nfunction isVNodeSuspensible(vnode) {\n  var _a;\n  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;\n}\n\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n  return doWatch(\n    effect,\n    null,\n    { flush: \"post\" }\n  );\n}\nfunction watchSyncEffect(effect, options) {\n  return doWatch(\n    effect,\n    null,\n    { flush: \"sync\" }\n  );\n}\nconst INITIAL_WATCHER_VALUE = {};\nfunction watch(source, cb, options) {\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared.EMPTY_OBJ) {\n  var _a;\n  const instance = reactivity.getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (reactivity.isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = reactivity.isShallow(source);\n  } else if (reactivity.isReactive(source)) {\n    getter = () => source;\n    deep = true;\n  } else if (shared.isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => reactivity.isReactive(s) || reactivity.isShallow(s));\n    getter = () => source.map((s) => {\n      if (reactivity.isRef(s)) {\n        return s.value;\n      } else if (reactivity.isReactive(s)) {\n        return traverse(s);\n      } else if (shared.isFunction(s)) {\n        return callWithErrorHandling(s, instance, 2);\n      } else ;\n    });\n  } else if (shared.isFunction(source)) {\n    if (cb) {\n      getter = () => callWithErrorHandling(source, instance, 2);\n    } else {\n      getter = () => {\n        if (instance && instance.isUnmounted) {\n          return;\n        }\n        if (cleanup) {\n          cleanup();\n        }\n        return callWithAsyncErrorHandling(\n          source,\n          instance,\n          3,\n          [onCleanup]\n        );\n      };\n    }\n  } else {\n    getter = shared.NOOP;\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    getter = () => traverse(baseGetter());\n  }\n  let cleanup;\n  let onCleanup = (fn) => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, 4);\n      cleanup = effect.onStop = void 0;\n    };\n  };\n  let ssrCleanup;\n  if (isInSSRComponentSetup) {\n    onCleanup = shared.NOOP;\n    if (!cb) {\n      getter();\n    } else if (immediate) {\n      callWithAsyncErrorHandling(cb, instance, 3, [\n        getter(),\n        isMultiSource ? [] : void 0,\n        onCleanup\n      ]);\n    }\n    if (flush === \"sync\") {\n      const ctx = useSSRContext();\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n    } else {\n      return shared.NOOP;\n    }\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = () => {\n    if (!effect.active) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => shared.hasChanged(v, oldValue[i])) : shared.hasChanged(newValue, oldValue)) || false) {\n        if (cleanup) {\n          cleanup();\n        }\n        callWithAsyncErrorHandling(cb, instance, 3, [\n          newValue,\n          // pass undefined as the old value when it's changed for the first time\n          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n          onCleanup\n        ]);\n        oldValue = newValue;\n      }\n    } else {\n      effect.run();\n    }\n  };\n  job.allowRecurse = !!cb;\n  let scheduler;\n  if (flush === \"sync\") {\n    scheduler = job;\n  } else if (flush === \"post\") {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n  } else {\n    job.pre = true;\n    if (instance)\n      job.id = instance.uid;\n    scheduler = () => queueJob(job);\n  }\n  const effect = new reactivity.ReactiveEffect(getter, scheduler);\n  if (cb) {\n    if (immediate) {\n      job();\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (flush === \"post\") {\n    queuePostRenderEffect(\n      effect.run.bind(effect),\n      instance && instance.suspense\n    );\n  } else {\n    effect.run();\n  }\n  const unwatch = () => {\n    effect.stop();\n    if (instance && instance.scope) {\n      shared.remove(instance.scope.effects, effect);\n    }\n  };\n  if (ssrCleanup)\n    ssrCleanup.push(unwatch);\n  return unwatch;\n}\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = shared.isString(source) ? source.includes(\".\") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n  if (shared.isFunction(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n  const cur = currentInstance;\n  setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n  if (cur) {\n    setCurrentInstance(cur);\n  } else {\n    unsetCurrentInstance();\n  }\n  return res;\n}\nfunction createPathGetter(ctx, path) {\n  const segments = path.split(\".\");\n  return () => {\n    let cur = ctx;\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n    return cur;\n  };\n}\nfunction traverse(value, seen) {\n  if (!shared.isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  if (reactivity.isRef(value)) {\n    traverse(value.value, seen);\n  } else if (shared.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen);\n    }\n  } else if (shared.isSet(value) || shared.isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, seen);\n    });\n  } else if (shared.isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], seen);\n    }\n  }\n  return value;\n}\n\nfunction withDirectives(vnode, directives) {\n  const internalInstance = currentRenderingInstance;\n  if (internalInstance === null) {\n    return vnode;\n  }\n  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;\n  const bindings = vnode.dirs || (vnode.dirs = []);\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = shared.EMPTY_OBJ] = directives[i];\n    if (dir) {\n      if (shared.isFunction(dir)) {\n        dir = {\n          mounted: dir,\n          updated: dir\n        };\n      }\n      if (dir.deep) {\n        traverse(value);\n      }\n      bindings.push({\n        dir,\n        instance,\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      });\n    }\n  }\n  return vnode;\n}\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    let hook = binding.dir[name];\n    if (hook) {\n      reactivity.pauseTracking();\n      callWithAsyncErrorHandling(hook, instance, 8, [\n        vnode.el,\n        binding,\n        vnode,\n        prevVNode\n      ]);\n      reactivity.resetTracking();\n    }\n  }\n}\n\nconst leaveCbKey = Symbol(\"_leaveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: /* @__PURE__ */ new Map()\n  };\n  onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionPropsValidators = {\n  mode: String,\n  appear: Boolean,\n  persisted: Boolean,\n  // enter\n  onBeforeEnter: TransitionHookValidator,\n  onEnter: TransitionHookValidator,\n  onAfterEnter: TransitionHookValidator,\n  onEnterCancelled: TransitionHookValidator,\n  // leave\n  onBeforeLeave: TransitionHookValidator,\n  onLeave: TransitionHookValidator,\n  onAfterLeave: TransitionHookValidator,\n  onLeaveCancelled: TransitionHookValidator,\n  // appear\n  onBeforeAppear: TransitionHookValidator,\n  onAppear: TransitionHookValidator,\n  onAfterAppear: TransitionHookValidator,\n  onAppearCancelled: TransitionHookValidator\n};\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: BaseTransitionPropsValidators,\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    let prevTransitionKey;\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n      if (!children || !children.length) {\n        return;\n      }\n      let child = children[0];\n      if (children.length > 1) {\n        for (const c of children) {\n          if (c.type !== Comment) {\n            child = c;\n            break;\n          }\n        }\n      }\n      const rawProps = reactivity.toRaw(props);\n      const { mode } = rawProps;\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      }\n      const innerChild = getKeepAliveChild(child);\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n      const enterHooks = resolveTransitionHooks(\n        innerChild,\n        rawProps,\n        state,\n        instance\n      );\n      setTransitionHooks(innerChild, enterHooks);\n      const oldChild = instance.subTree;\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n      let transitionKeyChanged = false;\n      const { getTransitionKey } = innerChild.type;\n      if (getTransitionKey) {\n        const key = getTransitionKey();\n        if (prevTransitionKey === void 0) {\n          prevTransitionKey = key;\n        } else if (key !== prevTransitionKey) {\n          prevTransitionKey = key;\n          transitionKeyChanged = true;\n        }\n      }\n      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\n        const leavingHooks = resolveTransitionHooks(\n          oldInnerChild,\n          rawProps,\n          state,\n          instance\n        );\n        setTransitionHooks(oldInnerChild, leavingHooks);\n        if (mode === \"out-in\") {\n          state.isLeaving = true;\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            if (instance.update.active !== false) {\n              instance.update();\n            }\n          };\n          return emptyPlaceholder(child);\n        } else if (mode === \"in-out\" && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(\n              state,\n              oldInnerChild\n            );\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n            el[leaveCbKey] = () => {\n              earlyRemove();\n              el[leaveCbKey] = void 0;\n              delete enterHooks.delayedLeave;\n            };\n            enterHooks.delayedLeave = delayedLeave;\n          };\n        }\n      }\n      return child;\n    };\n  }\n};\nconst BaseTransition = BaseTransitionImpl;\nfunction getLeavingNodesForType(state, vnode) {\n  const { leavingVNodes } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = /* @__PURE__ */ Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n  return leavingVNodesCache;\n}\nfunction resolveTransitionHooks(vnode, props, state, instance) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(\n      hook,\n      instance,\n      9,\n      args\n    );\n  };\n  const callAsyncHook = (hook, args) => {\n    const done = args[1];\n    callHook(hook, args);\n    if (shared.isArray(hook)) {\n      if (hook.every((hook2) => hook2.length <= 1))\n        done();\n    } else if (hook.length <= 1) {\n      done();\n    }\n  };\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      }\n      if (el[leaveCbKey]) {\n        el[leaveCbKey](\n          true\n          /* cancelled */\n        );\n      }\n      const leavingVNode = leavingVNodesCache[key];\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {\n        leavingVNode.el[leaveCbKey]();\n      }\n      callHook(hook, [el]);\n    },\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n      let called = false;\n      const done = el[enterCbKey] = (cancelled) => {\n        if (called)\n          return;\n        called = true;\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n        el[enterCbKey] = void 0;\n      };\n      if (hook) {\n        callAsyncHook(hook, [el, done]);\n      } else {\n        done();\n      }\n    },\n    leave(el, remove) {\n      const key2 = String(vnode.key);\n      if (el[enterCbKey]) {\n        el[enterCbKey](\n          true\n          /* cancelled */\n        );\n      }\n      if (state.isUnmounting) {\n        return remove();\n      }\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n      const done = el[leaveCbKey] = (cancelled) => {\n        if (called)\n          return;\n        called = true;\n        remove();\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n        el[leaveCbKey] = void 0;\n        if (leavingVNodesCache[key2] === vnode) {\n          delete leavingVNodesCache[key2];\n        }\n      };\n      leavingVNodesCache[key2] = vnode;\n      if (onLeave) {\n        callAsyncHook(onLeave, [el, done]);\n      } else {\n        done();\n      }\n    },\n    clone(vnode2) {\n      return resolveTransitionHooks(vnode2, props, state, instance);\n    }\n  };\n  return hooks;\n}\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\nfunction getKeepAliveChild(vnode) {\n  return isKeepAlive(vnode) ? (\n    // #7121 ensure get the child component subtree in case\n    // it's been replaced during HMR\n    vnode.children ? vnode.children[0] : void 0\n  ) : vnode;\n}\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6 && vnode.component) {\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128) {\n    vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n  } else {\n    vnode.transition = hooks;\n  }\n}\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\n  let ret = [];\n  let keyedFragmentCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);\n    if (child.type === Fragment) {\n      if (child.patchFlag & 128)\n        keyedFragmentCount++;\n      ret = ret.concat(\n        getTransitionRawChildren(child.children, keepComment, key)\n      );\n    } else if (keepComment || child.type !== Comment) {\n      ret.push(key != null ? cloneVNode(child, { key }) : child);\n    }\n  }\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2;\n    }\n  }\n  return ret;\n}\n\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineComponent(options, extraOptions) {\n  return shared.isFunction(options) ? (\n    // #8326: extend call and options.name access are considered side-effects\n    // by Rollup, so we have to wrap it in a pure-annotated IIFE.\n    /* @__PURE__ */ (() => shared.extend({ name: options.name }, extraOptions, { setup: options }))()\n  ) : options;\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineAsyncComponent(source) {\n  if (shared.isFunction(source)) {\n    source = { loader: source };\n  }\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {\n      err = err instanceof Error ? err : new Error(String(err));\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n          const userFail = () => reject(err);\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then((comp) => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === \"Module\")) {\n        comp = comp.default;\n      }\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n  return defineComponent({\n    name: \"AsyncComponentWrapper\",\n    __asyncLoader: load,\n    get __asyncResolved() {\n      return resolvedComp;\n    },\n    setup() {\n      const instance = currentInstance;\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n      const onError = (err) => {\n        pendingRequest = null;\n        handleError(\n          err,\n          instance,\n          13,\n          !errorComponent\n          /* do not throw in dev if user provided error component */\n        );\n      };\n      if (suspensible && instance.suspense || isInSSRComponentSetup) {\n        return load().then((comp) => {\n          return () => createInnerComp(comp, instance);\n        }).catch((err) => {\n          onError(err);\n          return () => errorComponent ? createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n      const loaded = reactivity.ref(false);\n      const error = reactivity.ref();\n      const delayed = reactivity.ref(!!delay);\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(\n              `Async component timed out after ${timeout}ms.`\n            );\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n      load().then(() => {\n        loaded.value = true;\n        if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n          queueJob(instance.parent.update);\n        }\n      }).catch((err) => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent);\n        }\n      };\n    }\n  });\n}\nfunction createInnerComp(comp, parent) {\n  const { ref: ref2, props, children, ce } = parent.vnode;\n  const vnode = createVNode(comp, props, children);\n  vnode.ref = ref2;\n  vnode.ce = ce;\n  delete parent.vnode.ce;\n  return vnode;\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const sharedContext = instance.ctx;\n    if (!sharedContext.renderer) {\n      return () => {\n        const children = slots.default && slots.default();\n        return children && children.length === 1 ? children[0] : children;\n      };\n    }\n    const cache = /* @__PURE__ */ new Map();\n    const keys = /* @__PURE__ */ new Set();\n    let current = null;\n    const parentSuspense = instance.suspense;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: { createElement }\n      }\n    } = sharedContext;\n    const storageContainer = createElement(\"div\");\n    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n      const instance2 = vnode.component;\n      move(vnode, container, anchor, 0, parentSuspense);\n      patch(\n        instance2.vnode,\n        vnode,\n        container,\n        anchor,\n        instance2,\n        parentSuspense,\n        isSVG,\n        vnode.slotScopeIds,\n        optimized\n      );\n      queuePostRenderEffect(() => {\n        instance2.isDeactivated = false;\n        if (instance2.a) {\n          shared.invokeArrayFns(instance2.a);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n      }, parentSuspense);\n    };\n    sharedContext.deactivate = (vnode) => {\n      const instance2 = vnode.component;\n      move(vnode, storageContainer, null, 1, parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance2.da) {\n          shared.invokeArrayFns(instance2.da);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n        instance2.isDeactivated = true;\n      }, parentSuspense);\n    };\n    function unmount(vnode) {\n      resetShapeFlag(vnode);\n      _unmount(vnode, instance, parentSuspense, true);\n    }\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type);\n        if (name && (!filter || !filter(name))) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n      if (!current || !isSameVNodeType(cached, current)) {\n        unmount(cached);\n      } else if (current) {\n        resetShapeFlag(current);\n      }\n      cache.delete(key);\n      keys.delete(key);\n    }\n    watch(\n      () => [props.include, props.exclude],\n      ([include, exclude]) => {\n        include && pruneCache((name) => matches(include, name));\n        exclude && pruneCache((name) => !matches(exclude, name));\n      },\n      // prune post-render after `current` has been updated\n      { flush: \"post\", deep: true }\n    );\n    let pendingCacheKey = null;\n    const cacheSubtree = () => {\n      if (pendingCacheKey != null) {\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n      }\n    };\n    onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach((cached) => {\n        const { subTree, suspense } = instance;\n        const vnode = getInnerChild(subTree);\n        if (cached.type === vnode.type && cached.key === vnode.key) {\n          resetShapeFlag(vnode);\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n      if (!slots.default) {\n        return null;\n      }\n      const children = slots.default();\n      const rawVNode = children[0];\n      if (children.length > 1) {\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {\n        current = null;\n        return rawVNode;\n      }\n      let vnode = getInnerChild(rawVNode);\n      const comp = vnode.type;\n      const name = getComponentName(\n        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp\n      );\n      const { include, exclude, max } = props;\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        current = vnode;\n        return rawVNode;\n      }\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key);\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n        if (rawVNode.shapeFlag & 128) {\n          rawVNode.ssContent = vnode;\n        }\n      }\n      pendingCacheKey = key;\n      if (cachedVNode) {\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n        if (vnode.transition) {\n          setTransitionHooks(vnode, vnode.transition);\n        }\n        vnode.shapeFlag |= 512;\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key);\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      }\n      vnode.shapeFlag |= 256;\n      current = vnode;\n      return isSuspense(rawVNode.type) ? rawVNode : vnode;\n    };\n  }\n};\nconst KeepAlive = KeepAliveImpl;\nfunction matches(pattern, name) {\n  if (shared.isArray(pattern)) {\n    return pattern.some((p) => matches(p, name));\n  } else if (shared.isString(pattern)) {\n    return pattern.split(\",\").includes(name);\n  } else if (shared.isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  return false;\n}\nfunction onActivated(hook, target) {\n  registerKeepAliveHook(hook, \"a\", target);\n}\nfunction onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, \"da\", target);\n}\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    let current = target;\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n      current = current.parent;\n    }\n    return hook();\n  });\n  injectHook(type, wrappedHook, target);\n  if (target) {\n    let current = target.parent;\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n      current = current.parent;\n    }\n  }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  const injected = injectHook(\n    type,\n    hook,\n    keepAliveRoot,\n    true\n    /* prepend */\n  );\n  onUnmounted(() => {\n    shared.remove(keepAliveRoot[type], injected);\n  }, target);\n}\nfunction resetShapeFlag(vnode) {\n  vnode.shapeFlag &= ~256;\n  vnode.shapeFlag &= ~512;\n}\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n  if (target) {\n    const hooks = target[type] || (target[type] = []);\n    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {\n      if (target.isUnmounted) {\n        return;\n      }\n      reactivity.pauseTracking();\n      setCurrentInstance(target);\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      unsetCurrentInstance();\n      reactivity.resetTracking();\n      return res;\n    });\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n    return wrappedHook;\n  }\n}\nconst createHook = (lifecycle) => (hook, target = currentInstance) => (\n  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n  (!isInSSRComponentSetup || lifecycle === \"sp\") && injectHook(lifecycle, (...args) => hook(...args), target)\n);\nconst onBeforeMount = createHook(\"bm\");\nconst onMounted = createHook(\"m\");\nconst onBeforeUpdate = createHook(\"bu\");\nconst onUpdated = createHook(\"u\");\nconst onBeforeUnmount = createHook(\"bum\");\nconst onUnmounted = createHook(\"um\");\nconst onServerPrefetch = createHook(\"sp\");\nconst onRenderTriggered = createHook(\n  \"rtg\"\n);\nconst onRenderTracked = createHook(\n  \"rtc\"\n);\nfunction onErrorCaptured(hook, target = currentInstance) {\n  injectHook(\"ec\", hook, target);\n}\n\nfunction renderList(source, renderItem, cache, index) {\n  let ret;\n  const cached = cache && cache[index];\n  if (shared.isArray(source) || shared.isString(source)) {\n    ret = new Array(source.length);\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);\n    }\n  } else if (typeof source === \"number\") {\n    ret = new Array(source);\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);\n    }\n  } else if (shared.isObject(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(\n        source,\n        (item, i) => renderItem(item, i, void 0, cached && cached[i])\n      );\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n      }\n    }\n  } else {\n    ret = [];\n  }\n  if (cache) {\n    cache[index] = ret;\n  }\n  return ret;\n}\n\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i];\n    if (shared.isArray(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      slots[slot.name] = slot.key ? (...args) => {\n        const res = slot.fn(...args);\n        if (res)\n          res.key = slot.key;\n        return res;\n      } : slot.fn;\n    }\n  }\n  return slots;\n}\n\nfunction renderSlot(slots, name, props = {}, fallback, noSlotted) {\n  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {\n    if (name !== \"default\")\n      props.name = name;\n    return createVNode(\"slot\", props, fallback && fallback());\n  }\n  let slot = slots[name];\n  if (slot && slot._c) {\n    slot._d = false;\n  }\n  openBlock();\n  const validSlotContent = slot && ensureValidVNode(slot(props));\n  const rendered = createBlock(\n    Fragment,\n    {\n      key: props.key || // slot content array of a dynamic conditional slot may have a branch\n      // key attached in the `createSlots` helper, respect that\n      validSlotContent && validSlotContent.key || `_${name}`\n    },\n    validSlotContent || (fallback ? fallback() : []),\n    validSlotContent && slots._ === 1 ? 64 : -2\n  );\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + \"-s\"];\n  }\n  if (slot && slot._c) {\n    slot._d = true;\n  }\n  return rendered;\n}\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some((child) => {\n    if (!isVNode(child))\n      return true;\n    if (child.type === Comment)\n      return false;\n    if (child.type === Fragment && !ensureValidVNode(child.children))\n      return false;\n    return true;\n  }) ? vnodes : null;\n}\n\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n  const ret = {};\n  for (const key in obj) {\n    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : shared.toHandlerKey(key)] = obj[key];\n  }\n  return ret;\n}\n\nconst getPublicInstance = (i) => {\n  if (!i)\n    return null;\n  if (isStatefulComponent(i))\n    return getExposeProxy(i) || i.proxy;\n  return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap = (\n  // Move PURE marker to new line to workaround compiler discarding it\n  // due to type annotation\n  /* @__PURE__ */ shared.extend(/* @__PURE__ */ Object.create(null), {\n    $: (i) => i,\n    $el: (i) => i.vnode.el,\n    $data: (i) => i.data,\n    $props: (i) => i.props,\n    $attrs: (i) => i.attrs,\n    $slots: (i) => i.slots,\n    $refs: (i) => i.refs,\n    $parent: (i) => getPublicInstance(i.parent),\n    $root: (i) => getPublicInstance(i.root),\n    $emit: (i) => i.emit,\n    $options: (i) => resolveMergedOptions(i) ,\n    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),\n    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),\n    $watch: (i) => instanceWatch.bind(i) \n  })\n);\nconst hasSetupBinding = (state, key) => state !== shared.EMPTY_OBJ && !state.__isScriptSetup && shared.hasOwn(state, key);\nconst PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\n    let normalizedProps;\n    if (key[0] !== \"$\") {\n      const n = accessCache[key];\n      if (n !== void 0) {\n        switch (n) {\n          case 1 /* SETUP */:\n            return setupState[key];\n          case 2 /* DATA */:\n            return data[key];\n          case 4 /* CONTEXT */:\n            return ctx[key];\n          case 3 /* PROPS */:\n            return props[key];\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache[key] = 1 /* SETUP */;\n        return setupState[key];\n      } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {\n        accessCache[key] = 2 /* DATA */;\n        return data[key];\n      } else if (\n        // only cache other properties when instance has declared (thus stable)\n        // props\n        (normalizedProps = instance.propsOptions[0]) && shared.hasOwn(normalizedProps, key)\n      ) {\n        accessCache[key] = 3 /* PROPS */;\n        return props[key];\n      } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {\n        accessCache[key] = 4 /* CONTEXT */;\n        return ctx[key];\n      } else if (shouldCacheAccess) {\n        accessCache[key] = 0 /* OTHER */;\n      }\n    }\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    if (publicGetter) {\n      if (key === \"$attrs\") {\n        reactivity.track(instance, \"get\", key);\n      }\n      return publicGetter(instance);\n    } else if (\n      // css module (injected by vue-loader)\n      (cssModule = type.__cssModules) && (cssModule = cssModule[key])\n    ) {\n      return cssModule;\n    } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {\n      accessCache[key] = 4 /* CONTEXT */;\n      return ctx[key];\n    } else if (\n      // global properties\n      globalProperties = appContext.config.globalProperties, shared.hasOwn(globalProperties, key)\n    ) {\n      {\n        return globalProperties[key];\n      }\n    } else ;\n  },\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance;\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value;\n      return true;\n    } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {\n      data[key] = value;\n      return true;\n    } else if (shared.hasOwn(instance.props, key)) {\n      return false;\n    }\n    if (key[0] === \"$\" && key.slice(1) in instance) {\n      return false;\n    } else {\n      {\n        ctx[key] = value;\n      }\n    }\n    return true;\n  },\n  has({\n    _: { data, setupState, accessCache, ctx, appContext, propsOptions }\n  }, key) {\n    let normalizedProps;\n    return !!accessCache[key] || data !== shared.EMPTY_OBJ && shared.hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && shared.hasOwn(normalizedProps, key) || shared.hasOwn(ctx, key) || shared.hasOwn(publicPropertiesMap, key) || shared.hasOwn(appContext.config.globalProperties, key);\n  },\n  defineProperty(target, key, descriptor) {\n    if (descriptor.get != null) {\n      target._.accessCache[key] = 0;\n    } else if (shared.hasOwn(descriptor, \"value\")) {\n      this.set(target, key, descriptor.value, null);\n    }\n    return Reflect.defineProperty(target, key, descriptor);\n  }\n};\nconst RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ shared.extend(\n  {},\n  PublicInstanceProxyHandlers,\n  {\n    get(target, key) {\n      if (key === Symbol.unscopables) {\n        return;\n      }\n      return PublicInstanceProxyHandlers.get(target, key, target);\n    },\n    has(_, key) {\n      const has = key[0] !== \"_\" && !shared.isGloballyAllowed(key);\n      return has;\n    }\n  }\n);\n\nfunction defineProps() {\n  return null;\n}\nfunction defineEmits() {\n  return null;\n}\nfunction defineExpose(exposed) {\n}\nfunction defineOptions(options) {\n}\nfunction defineSlots() {\n  return null;\n}\nfunction defineModel() {\n}\nfunction withDefaults(props, defaults) {\n  return null;\n}\nfunction useSlots() {\n  return getContext().slots;\n}\nfunction useAttrs() {\n  return getContext().attrs;\n}\nfunction useModel(props, name, options) {\n  const i = getCurrentInstance();\n  if (options && options.local) {\n    const proxy = reactivity.ref(props[name]);\n    watch(\n      () => props[name],\n      (v) => proxy.value = v\n    );\n    watch(proxy, (value) => {\n      if (value !== props[name]) {\n        i.emit(`update:${name}`, value);\n      }\n    });\n    return proxy;\n  } else {\n    return {\n      __v_isRef: true,\n      get value() {\n        return props[name];\n      },\n      set value(value) {\n        i.emit(`update:${name}`, value);\n      }\n    };\n  }\n}\nfunction getContext() {\n  const i = getCurrentInstance();\n  return i.setupContext || (i.setupContext = createSetupContext(i));\n}\nfunction normalizePropsOrEmits(props) {\n  return shared.isArray(props) ? props.reduce(\n    (normalized, p) => (normalized[p] = null, normalized),\n    {}\n  ) : props;\n}\nfunction mergeDefaults(raw, defaults) {\n  const props = normalizePropsOrEmits(raw);\n  for (const key in defaults) {\n    if (key.startsWith(\"__skip\"))\n      continue;\n    let opt = props[key];\n    if (opt) {\n      if (shared.isArray(opt) || shared.isFunction(opt)) {\n        opt = props[key] = { type: opt, default: defaults[key] };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      opt = props[key] = { default: defaults[key] };\n    } else ;\n    if (opt && defaults[`__skip_${key}`]) {\n      opt.skipFactory = true;\n    }\n  }\n  return props;\n}\nfunction mergeModels(a, b) {\n  if (!a || !b)\n    return a || b;\n  if (shared.isArray(a) && shared.isArray(b))\n    return a.concat(b);\n  return shared.extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));\n}\nfunction createPropsRestProxy(props, excludedKeys) {\n  const ret = {};\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      });\n    }\n  }\n  return ret;\n}\nfunction withAsyncContext(getAwaitable) {\n  const ctx = getCurrentInstance();\n  let awaitable = getAwaitable();\n  unsetCurrentInstance();\n  if (shared.isPromise(awaitable)) {\n    awaitable = awaitable.catch((e) => {\n      setCurrentInstance(ctx);\n      throw e;\n    });\n  }\n  return [awaitable, () => setCurrentInstance(ctx)];\n}\n\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n  const options = resolveMergedOptions(instance);\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  shouldCacheAccess = false;\n  if (options.beforeCreate) {\n    callHook(options.beforeCreate, instance, \"bc\");\n  }\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options;\n  const checkDuplicateProperties = null;\n  if (injectOptions) {\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties);\n  }\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n      if (shared.isFunction(methodHandler)) {\n        {\n          ctx[key] = methodHandler.bind(publicThis);\n        }\n      }\n    }\n  }\n  if (dataOptions) {\n    const data = dataOptions.call(publicThis, publicThis);\n    if (!shared.isObject(data)) ; else {\n      instance.data = reactivity.reactive(data);\n    }\n  }\n  shouldCacheAccess = true;\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = shared.isFunction(opt) ? opt.bind(publicThis, publicThis) : shared.isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : shared.NOOP;\n      const set = !shared.isFunction(opt) && shared.isFunction(opt.set) ? opt.set.bind(publicThis) : shared.NOOP;\n      const c = computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: (v) => c.value = v\n      });\n    }\n  }\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key);\n    }\n  }\n  if (provideOptions) {\n    const provides = shared.isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n    Reflect.ownKeys(provides).forEach((key) => {\n      provide(key, provides[key]);\n    });\n  }\n  if (created) {\n    callHook(created, instance, \"c\");\n  }\n  function registerLifecycleHook(register, hook) {\n    if (shared.isArray(hook)) {\n      hook.forEach((_hook) => register(_hook.bind(publicThis)));\n    } else if (hook) {\n      register(hook.bind(publicThis));\n    }\n  }\n  registerLifecycleHook(onBeforeMount, beforeMount);\n  registerLifecycleHook(onMounted, mounted);\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n  registerLifecycleHook(onUpdated, updated);\n  registerLifecycleHook(onActivated, activated);\n  registerLifecycleHook(onDeactivated, deactivated);\n  registerLifecycleHook(onErrorCaptured, errorCaptured);\n  registerLifecycleHook(onRenderTracked, renderTracked);\n  registerLifecycleHook(onRenderTriggered, renderTriggered);\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n  registerLifecycleHook(onUnmounted, unmounted);\n  registerLifecycleHook(onServerPrefetch, serverPrefetch);\n  if (shared.isArray(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {});\n      expose.forEach((key) => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: (val) => publicThis[key] = val\n        });\n      });\n    } else if (!instance.exposed) {\n      instance.exposed = {};\n    }\n  }\n  if (render && instance.render === shared.NOOP) {\n    instance.render = render;\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs;\n  }\n  if (components)\n    instance.components = components;\n  if (directives)\n    instance.directives = directives;\n}\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = shared.NOOP) {\n  if (shared.isArray(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions);\n  }\n  for (const key in injectOptions) {\n    const opt = injectOptions[key];\n    let injected;\n    if (shared.isObject(opt)) {\n      if (\"default\" in opt) {\n        injected = inject(\n          opt.from || key,\n          opt.default,\n          true\n          /* treat default function as factory */\n        );\n      } else {\n        injected = inject(opt.from || key);\n      }\n    } else {\n      injected = inject(opt);\n    }\n    if (reactivity.isRef(injected)) {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => injected.value,\n        set: (v) => injected.value = v\n      });\n    } else {\n      ctx[key] = injected;\n    }\n  }\n}\nfunction callHook(hook, instance, type) {\n  callWithAsyncErrorHandling(\n    shared.isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),\n    instance,\n    type\n  );\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n  const getter = key.includes(\".\") ? createPathGetter(publicThis, key) : () => publicThis[key];\n  if (shared.isString(raw)) {\n    const handler = ctx[raw];\n    if (shared.isFunction(handler)) {\n      watch(getter, handler);\n    }\n  } else if (shared.isFunction(raw)) {\n    watch(getter, raw.bind(publicThis));\n  } else if (shared.isObject(raw)) {\n    if (shared.isArray(raw)) {\n      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = shared.isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n      if (shared.isFunction(handler)) {\n        watch(getter, handler, raw);\n      }\n    }\n  } else ;\n}\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const { mixins, extends: extendsOptions } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: { optionMergeStrategies }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n    if (globalMixins.length) {\n      globalMixins.forEach(\n        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)\n      );\n    }\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n  if (shared.isObject(base)) {\n    cache.set(base, resolved);\n  }\n  return resolved;\n}\nfunction mergeOptions(to, from, strats, asMixin = false) {\n  const { mixins, extends: extendsOptions } = from;\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n  if (mixins) {\n    mixins.forEach(\n      (m) => mergeOptions(to, m, strats, true)\n    );\n  }\n  for (const key in from) {\n    if (asMixin && key === \"expose\") ; else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n  return to;\n}\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeEmitsOrPropsOptions,\n  emits: mergeEmitsOrPropsOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n  if (!to) {\n    return from;\n  }\n  return function mergedDataFn() {\n    return (shared.extend)(\n      shared.isFunction(to) ? to.call(this, this) : to,\n      shared.isFunction(from) ? from.call(this, this) : from\n    );\n  };\n}\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n  if (shared.isArray(raw)) {\n    const res = {};\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n    return res;\n  }\n  return raw;\n}\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n  return to ? shared.extend(/* @__PURE__ */ Object.create(null), to, from) : from;\n}\nfunction mergeEmitsOrPropsOptions(to, from) {\n  if (to) {\n    if (shared.isArray(to) && shared.isArray(from)) {\n      return [.../* @__PURE__ */ new Set([...to, ...from])];\n    }\n    return shared.extend(\n      /* @__PURE__ */ Object.create(null),\n      normalizePropsOrEmits(to),\n      normalizePropsOrEmits(from != null ? from : {})\n    );\n  } else {\n    return from;\n  }\n}\nfunction mergeWatchOptions(to, from) {\n  if (!to)\n    return from;\n  if (!from)\n    return to;\n  const merged = shared.extend(/* @__PURE__ */ Object.create(null), to);\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n  return merged;\n}\n\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: shared.NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: void 0,\n      warnHandler: void 0,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: /* @__PURE__ */ Object.create(null),\n    optionsCache: /* @__PURE__ */ new WeakMap(),\n    propsCache: /* @__PURE__ */ new WeakMap(),\n    emitsCache: /* @__PURE__ */ new WeakMap()\n  };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent, rootProps = null) {\n    if (!shared.isFunction(rootComponent)) {\n      rootComponent = shared.extend({}, rootComponent);\n    }\n    if (rootProps != null && !shared.isObject(rootProps)) {\n      rootProps = null;\n    }\n    const context = createAppContext();\n    const installedPlugins = /* @__PURE__ */ new WeakSet();\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid$1++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n      version,\n      get config() {\n        return context.config;\n      },\n      set config(v) {\n      },\n      use(plugin, ...options) {\n        if (installedPlugins.has(plugin)) ; else if (plugin && shared.isFunction(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if (shared.isFunction(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else ;\n        return app;\n      },\n      mixin(mixin) {\n        {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin);\n          }\n        }\n        return app;\n      },\n      component(name, component) {\n        if (!component) {\n          return context.components[name];\n        }\n        context.components[name] = component;\n        return app;\n      },\n      directive(name, directive) {\n        if (!directive) {\n          return context.directives[name];\n        }\n        context.directives[name] = directive;\n        return app;\n      },\n      mount(rootContainer, isHydrate, isSVG) {\n        if (!isMounted) {\n          const vnode = createVNode(rootComponent, rootProps);\n          vnode.appContext = context;\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer, isSVG);\n          }\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n          return getExposeProxy(vnode.component) || vnode.component.proxy;\n        }\n      },\n      unmount() {\n        if (isMounted) {\n          render(null, app._container);\n          delete app._container.__vue_app__;\n        }\n      },\n      provide(key, value) {\n        context.provides[key] = value;\n        return app;\n      },\n      runWithContext(fn) {\n        currentApp = app;\n        try {\n          return fn();\n        } finally {\n          currentApp = null;\n        }\n      }\n    };\n    return app;\n  };\n}\nlet currentApp = null;\n\nfunction provide(key, value) {\n  if (!currentInstance) ; else {\n    let provides = currentInstance.provides;\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n    provides[key] = value;\n  }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n  const instance = currentInstance || currentRenderingInstance;\n  if (instance || currentApp) {\n    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;\n    if (provides && key in provides) {\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && shared.isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;\n    } else ;\n  }\n}\nfunction hasInjectionContext() {\n  return !!(currentInstance || currentRenderingInstance || currentApp);\n}\n\nfunction initProps(instance, rawProps, isStateful, isSSR = false) {\n  const props = {};\n  const attrs = {};\n  shared.def(attrs, InternalObjectKey, 1);\n  instance.propsDefaults = /* @__PURE__ */ Object.create(null);\n  setFullProps(instance, rawProps, props, attrs);\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = void 0;\n    }\n  }\n  if (isStateful) {\n    instance.props = isSSR ? props : reactivity.shallowReactive(props);\n  } else {\n    if (!instance.type.props) {\n      instance.props = attrs;\n    } else {\n      instance.props = props;\n    }\n  }\n  instance.attrs = attrs;\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: { patchFlag }\n  } = instance;\n  const rawCurrentProps = reactivity.toRaw(props);\n  const [options] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  if (\n    // always force full diff in dev\n    // - #1942 if hmr is enabled with sfc component\n    // - vite#872 non-sfc component used by sfc component\n    (optimized || patchFlag > 0) && !(patchFlag & 16)\n  ) {\n    if (patchFlag & 8) {\n      const propsToUpdate = instance.vnode.dynamicProps;\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i];\n        if (isEmitListener(instance.emitsOptions, key)) {\n          continue;\n        }\n        const value = rawProps[key];\n        if (options) {\n          if (shared.hasOwn(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value;\n              hasAttrsChanged = true;\n            }\n          } else {\n            const camelizedKey = shared.camelize(key);\n            props[camelizedKey] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              camelizedKey,\n              value,\n              instance,\n              false\n              /* isAbsent */\n            );\n          }\n        } else {\n          if (value !== attrs[key]) {\n            attrs[key] = value;\n            hasAttrsChanged = true;\n          }\n        }\n      }\n    }\n  } else {\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true;\n    }\n    let kebabKey;\n    for (const key in rawCurrentProps) {\n      if (!rawProps || // for camelCase\n      !shared.hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      ((kebabKey = shared.hyphenate(key)) === key || !shared.hasOwn(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && // for camelCase\n          (rawPrevProps[key] !== void 0 || // for kebab-case\n          rawPrevProps[kebabKey] !== void 0)) {\n            props[key] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              key,\n              void 0,\n              instance,\n              true\n              /* isAbsent */\n            );\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    }\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !shared.hasOwn(rawProps, key) && true) {\n          delete attrs[key];\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (hasAttrsChanged) {\n    reactivity.trigger(instance, \"set\", \"$attrs\");\n  }\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  let rawCastValues;\n  if (rawProps) {\n    for (let key in rawProps) {\n      if (shared.isReservedProp(key)) {\n        continue;\n      }\n      const value = rawProps[key];\n      let camelKey;\n      if (options && shared.hasOwn(options, camelKey = shared.camelize(key))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value;\n        } else {\n          (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value;\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (needCastKeys) {\n    const rawCurrentProps = reactivity.toRaw(props);\n    const castValues = rawCastValues || shared.EMPTY_OBJ;\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(\n        options,\n        rawCurrentProps,\n        key,\n        castValues[key],\n        instance,\n        !shared.hasOwn(castValues, key)\n      );\n    }\n  }\n  return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n  const opt = options[key];\n  if (opt != null) {\n    const hasDefault = shared.hasOwn(opt, \"default\");\n    if (hasDefault && value === void 0) {\n      const defaultValue = opt.default;\n      if (opt.type !== Function && !opt.skipFactory && shared.isFunction(defaultValue)) {\n        const { propsDefaults } = instance;\n        if (key in propsDefaults) {\n          value = propsDefaults[key];\n        } else {\n          setCurrentInstance(instance);\n          value = propsDefaults[key] = defaultValue.call(\n            null,\n            props\n          );\n          unsetCurrentInstance();\n        }\n      } else {\n        value = defaultValue;\n      }\n    }\n    if (opt[0 /* shouldCast */]) {\n      if (isAbsent && !hasDefault) {\n        value = false;\n      } else if (opt[1 /* shouldCastTrue */] && (value === \"\" || value === shared.hyphenate(key))) {\n        value = true;\n      }\n    }\n  }\n  return value;\n}\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.propsCache;\n  const cached = cache.get(comp);\n  if (cached) {\n    return cached;\n  }\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = [];\n  let hasExtends = false;\n  if (!shared.isFunction(comp)) {\n    const extendProps = (raw2) => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw2, appContext, true);\n      shared.extend(normalized, props);\n      if (keys)\n        needCastKeys.push(...keys);\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if (shared.isObject(comp)) {\n      cache.set(comp, shared.EMPTY_ARR);\n    }\n    return shared.EMPTY_ARR;\n  }\n  if (shared.isArray(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      const normalizedKey = shared.camelize(raw[i]);\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = shared.EMPTY_OBJ;\n      }\n    }\n  } else if (raw) {\n    for (const key in raw) {\n      const normalizedKey = shared.camelize(key);\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = shared.isArray(opt) || shared.isFunction(opt) ? { type: opt } : shared.extend({}, opt);\n        if (prop) {\n          const booleanIndex = getTypeIndex(Boolean, prop.type);\n          const stringIndex = getTypeIndex(String, prop.type);\n          prop[0 /* shouldCast */] = booleanIndex > -1;\n          prop[1 /* shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;\n          if (booleanIndex > -1 || shared.hasOwn(prop, \"default\")) {\n            needCastKeys.push(normalizedKey);\n          }\n        }\n      }\n    }\n  }\n  const res = [normalized, needCastKeys];\n  if (shared.isObject(comp)) {\n    cache.set(comp, res);\n  }\n  return res;\n}\nfunction validatePropName(key) {\n  if (key[0] !== \"$\") {\n    return true;\n  }\n  return false;\n}\nfunction getType(ctor) {\n  const match = ctor && ctor.toString().match(/^\\s*(function|class) (\\w+)/);\n  return match ? match[2] : ctor === null ? \"null\" : \"\";\n}\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n  if (shared.isArray(expectedTypes)) {\n    return expectedTypes.findIndex((t) => isSameType(t, type));\n  } else if (shared.isFunction(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n  return -1;\n}\n\nconst isInternalKey = (key) => key[0] === \"_\" || key === \"$stable\";\nconst normalizeSlotValue = (value) => shared.isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n  if (rawSlot._n) {\n    return rawSlot;\n  }\n  const normalized = withCtx((...args) => {\n    if (false) ;\n    return normalizeSlotValue(rawSlot(...args));\n  }, ctx);\n  normalized._c = false;\n  return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n  const ctx = rawSlots._ctx;\n  for (const key in rawSlots) {\n    if (isInternalKey(key))\n      continue;\n    const value = rawSlots[key];\n    if (shared.isFunction(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      const normalized = normalizeSlotValue(value);\n      slots[key] = () => normalized;\n    }\n  }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n  const normalized = normalizeSlotValue(children);\n  instance.slots.default = () => normalized;\n};\nconst initSlots = (instance, children) => {\n  if (instance.vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      instance.slots = reactivity.toRaw(children);\n      shared.def(children, \"_\", type);\n    } else {\n      normalizeObjectSlots(\n        children,\n        instance.slots = {});\n    }\n  } else {\n    instance.slots = {};\n    if (children) {\n      normalizeVNodeSlots(instance, children);\n    }\n  }\n  shared.def(instance.slots, InternalObjectKey, 1);\n};\nconst updateSlots = (instance, children, optimized) => {\n  const { vnode, slots } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = shared.EMPTY_OBJ;\n  if (vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      if (optimized && type === 1) {\n        needDeletionCheck = false;\n      } else {\n        shared.extend(slots, children);\n        if (!optimized && type === 1) {\n          delete slots._;\n        }\n      }\n    } else {\n      needDeletionCheck = !children.$stable;\n      normalizeObjectSlots(children, slots);\n    }\n    deletionComparisonTarget = children;\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = { default: 1 };\n  }\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {\n        delete slots[key];\n      }\n    }\n  }\n};\n\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\n  if (shared.isArray(rawRef)) {\n    rawRef.forEach(\n      (r, i) => setRef(\n        r,\n        oldRawRef && (shared.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),\n        parentSuspense,\n        vnode,\n        isUnmount\n      )\n    );\n    return;\n  }\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    return;\n  }\n  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;\n  const value = isUnmount ? null : refValue;\n  const { i: owner, r: ref } = rawRef;\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === shared.EMPTY_OBJ ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState;\n  if (oldRef != null && oldRef !== ref) {\n    if (shared.isString(oldRef)) {\n      refs[oldRef] = null;\n      if (shared.hasOwn(setupState, oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if (reactivity.isRef(oldRef)) {\n      oldRef.value = null;\n    }\n  }\n  if (shared.isFunction(ref)) {\n    callWithErrorHandling(ref, owner, 12, [value, refs]);\n  } else {\n    const _isString = shared.isString(ref);\n    const _isRef = reactivity.isRef(ref);\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? shared.hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;\n          if (isUnmount) {\n            shared.isArray(existing) && shared.remove(existing, refValue);\n          } else {\n            if (!shared.isArray(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue];\n                if (shared.hasOwn(setupState, ref)) {\n                  setupState[ref] = refs[ref];\n                }\n              } else {\n                ref.value = [refValue];\n                if (rawRef.k)\n                  refs[rawRef.k] = ref.value;\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue);\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value;\n          if (shared.hasOwn(setupState, ref)) {\n            setupState[ref] = value;\n          }\n        } else if (_isRef) {\n          ref.value = value;\n          if (rawRef.k)\n            refs[rawRef.k] = value;\n        } else ;\n      };\n      if (value) {\n        doSet.id = -1;\n        queuePostRenderEffect(doSet, parentSuspense);\n      } else {\n        doSet();\n      }\n    }\n  }\n}\n\nlet hasMismatch = false;\nconst isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== \"foreignObject\";\nconst isComment = (node) => node.nodeType === 8 /* COMMENT */;\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      createText,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n  const hydrate = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n      patch(null, vnode, container);\n      flushPostFlushCbs();\n      container._vnode = vnode;\n      return;\n    }\n    hasMismatch = false;\n    hydrateNode(container.firstChild, vnode, null, null, null);\n    flushPostFlushCbs();\n    container._vnode = vnode;\n    if (hasMismatch && true) {\n      console.error(`Hydration completed but contains mismatches.`);\n    }\n  };\n  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\n    const isFragmentStart = isComment(node) && node.data === \"[\";\n    const onMismatch = () => handleMismatch(\n      node,\n      vnode,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      isFragmentStart\n    );\n    const { type, ref, shapeFlag, patchFlag } = vnode;\n    let domType = node.nodeType;\n    vnode.el = node;\n    if (patchFlag === -2) {\n      optimized = false;\n      vnode.dynamicChildren = null;\n    }\n    let nextNode = null;\n    switch (type) {\n      case Text:\n        if (domType !== 3 /* TEXT */) {\n          if (vnode.children === \"\") {\n            insert(vnode.el = createText(\"\"), parentNode(node), node);\n            nextNode = node;\n          } else {\n            nextNode = onMismatch();\n          }\n        } else {\n          if (node.data !== vnode.children) {\n            hasMismatch = true;\n            node.data = vnode.children;\n          }\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Comment:\n        if (isTemplateNode(node)) {\n          nextNode = nextSibling(node);\n          replaceNode(\n            vnode.el = node.content.firstChild,\n            node,\n            parentComponent\n          );\n        } else if (domType !== 8 /* COMMENT */ || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Static:\n        if (isFragmentStart) {\n          node = nextSibling(node);\n          domType = node.nodeType;\n        }\n        if (domType === 1 /* ELEMENT */ || domType === 3 /* TEXT */) {\n          nextNode = node;\n          const needToAdoptContent = !vnode.children.length;\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent)\n              vnode.children += nextNode.nodeType === 1 /* ELEMENT */ ? nextNode.outerHTML : nextNode.data;\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n            nextNode = nextSibling(nextNode);\n          }\n          return isFragmentStart ? nextSibling(nextNode) : nextNode;\n        } else {\n          onMismatch();\n        }\n        break;\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            slotScopeIds,\n            optimized\n          );\n        }\n        break;\n      default:\n        if (shapeFlag & 1) {\n          if ((domType !== 1 /* ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = hydrateElement(\n              node,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized\n            );\n          }\n        } else if (shapeFlag & 6) {\n          vnode.slotScopeIds = slotScopeIds;\n          const container = parentNode(node);\n          if (isFragmentStart) {\n            nextNode = locateClosingAnchor(node);\n          } else if (isComment(node) && node.data === \"teleport start\") {\n            nextNode = locateClosingAnchor(node, node.data, \"teleport end\");\n          } else {\n            nextNode = nextSibling(node);\n          }\n          mountComponent(\n            vnode,\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            isSVGContainer(container),\n            optimized\n          );\n          if (isAsyncWrapper(vnode)) {\n            let subTree;\n            if (isFragmentStart) {\n              subTree = createVNode(Fragment);\n              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;\n            } else {\n              subTree = node.nodeType === 3 ? createTextVNode(\"\") : createVNode(\"div\");\n            }\n            subTree.el = node;\n            vnode.component.subTree = subTree;\n          }\n        } else if (shapeFlag & 64) {\n          if (domType !== 8 /* COMMENT */) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = vnode.type.hydrate(\n              node,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized,\n              rendererInternals,\n              hydrateChildren\n            );\n          }\n        } else if (shapeFlag & 128) {\n          nextNode = vnode.type.hydrate(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            isSVGContainer(parentNode(node)),\n            slotScopeIds,\n            optimized,\n            rendererInternals,\n            hydrateNode\n          );\n        } else ;\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode);\n    }\n    return nextNode;\n  };\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;\n    const forcePatch = type === \"input\" || type === \"option\";\n    if (forcePatch || patchFlag !== -1) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n      }\n      if (props) {\n        if (forcePatch || !optimized || patchFlag & (16 | 32)) {\n          for (const key in props) {\n            if (forcePatch && (key.endsWith(\"value\") || key === \"indeterminate\") || shared.isOn(key) && !shared.isReservedProp(key) || // force hydrate v-bind with .prop modifiers\n            key[0] === \".\") {\n              patchProp(\n                el,\n                key,\n                null,\n                props[key],\n                false,\n                void 0,\n                parentComponent\n              );\n            }\n          }\n        } else if (props.onClick) {\n          patchProp(\n            el,\n            \"onClick\",\n            null,\n            props.onClick,\n            false,\n            void 0,\n            parentComponent\n          );\n        }\n      }\n      let vnodeHooks;\n      if (vnodeHooks = props && props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n      }\n      let needCallTransitionHooks = false;\n      if (isTemplateNode(el)) {\n        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;\n        const content = el.content.firstChild;\n        if (needCallTransitionHooks) {\n          transition.beforeEnter(content);\n        }\n        replaceNode(content, el, parentComponent);\n        vnode.el = el = content;\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n          needCallTransitionHooks && transition.enter(el);\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n        }, parentSuspense);\n      }\n      if (shapeFlag & 16 && // skip if element has innerHTML / textContent\n      !(props && (props.innerHTML || props.textContent))) {\n        let next = hydrateChildren(\n          el.firstChild,\n          vnode,\n          el,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n        while (next) {\n          hasMismatch = true;\n          const cur = next;\n          next = next.nextSibling;\n          remove(cur);\n        }\n      } else if (shapeFlag & 8) {\n        if (el.textContent !== vnode.children) {\n          hasMismatch = true;\n          el.textContent = vnode.children;\n        }\n      }\n    }\n    return el.nextSibling;\n  };\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n      if (node) {\n        node = hydrateNode(\n          node,\n          vnode,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n      } else if (vnode.type === Text && !vnode.children) {\n        continue;\n      } else {\n        hasMismatch = true;\n        patch(\n          null,\n          vnode,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          isSVGContainer(container),\n          slotScopeIds\n        );\n      }\n    }\n    return node;\n  };\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    const { slotScopeIds: fragmentSlotScopeIds } = vnode;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    const container = parentNode(node);\n    const next = hydrateChildren(\n      nextSibling(node),\n      vnode,\n      container,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      optimized\n    );\n    if (next && isComment(next) && next.data === \"]\") {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      hasMismatch = true;\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n    hasMismatch = true;\n    vnode.el = null;\n    if (isFragment) {\n      const end = locateClosingAnchor(node);\n      while (true) {\n        const next2 = nextSibling(node);\n        if (next2 && next2 !== end) {\n          remove(next2);\n        } else {\n          break;\n        }\n      }\n    }\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(\n      null,\n      vnode,\n      container,\n      next,\n      parentComponent,\n      parentSuspense,\n      isSVGContainer(container),\n      slotScopeIds\n    );\n    return next;\n  };\n  const locateClosingAnchor = (node, open = \"[\", close = \"]\") => {\n    let match = 0;\n    while (node) {\n      node = nextSibling(node);\n      if (node && isComment(node)) {\n        if (node.data === open)\n          match++;\n        if (node.data === close) {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n    return node;\n  };\n  const replaceNode = (newNode, oldNode, parentComponent) => {\n    const parentNode2 = oldNode.parentNode;\n    if (parentNode2) {\n      parentNode2.replaceChild(newNode, oldNode);\n    }\n    let parent = parentComponent;\n    while (parent) {\n      if (parent.vnode.el === oldNode) {\n        parent.vnode.el = parent.subTree.el = newNode;\n      }\n      parent = parent.parent;\n    }\n  };\n  const isTemplateNode = (node) => {\n    return node.nodeType === 1 /* ELEMENT */ && node.tagName.toLowerCase() === \"template\";\n  };\n  return [hydrate, hydrateNode];\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense ;\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n}\nfunction createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n}\nfunction baseCreateRenderer(options, createHydrationFns) {\n  const target = shared.getGlobalThis();\n  target.__VUE__ = true;\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = shared.NOOP,\n    insertStaticContent: hostInsertStaticContent\n  } = options;\n  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {\n    if (n1 === n2) {\n      return;\n    }\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n    if (n2.patchFlag === -2) {\n      optimized = false;\n      n2.dynamicChildren = null;\n    }\n    const { type, ref, shapeFlag } = n2;\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, isSVG);\n        }\n        break;\n      case Fragment:\n        processFragment(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n        break;\n      default:\n        if (shapeFlag & 1) {\n          processElement(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n        } else if (shapeFlag & 6) {\n          processComponent(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n        } else if (shapeFlag & 64) {\n          type.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        } else if (shapeFlag & 128) {\n          type.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        } else ;\n    }\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n    }\n  };\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        n2.el = hostCreateText(n2.children),\n        container,\n        anchor\n      );\n    } else {\n      const el = n2.el = n1.el;\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        n2.el = hostCreateComment(n2.children || \"\"),\n        container,\n        anchor\n      );\n    } else {\n      n2.el = n1.el;\n    }\n  };\n  const mountStaticNode = (n2, container, anchor, isSVG) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(\n      n2.children,\n      container,\n      anchor,\n      isSVG,\n      n2.el,\n      n2.anchor\n    );\n  };\n  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostInsert(el, container, nextSibling);\n      el = next;\n    }\n    hostInsert(anchor, container, nextSibling);\n  };\n  const removeStaticNode = ({ el, anchor }) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostRemove(el);\n      el = next;\n    }\n    hostRemove(anchor);\n  };\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    isSVG = isSVG || n2.type === \"svg\";\n    if (n1 == null) {\n      mountElement(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      );\n    } else {\n      patchElement(\n        n1,\n        n2,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      );\n    }\n  };\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    let el;\n    let vnodeHook;\n    const { type, props, shapeFlag, transition, dirs } = vnode;\n    el = vnode.el = hostCreateElement(\n      vnode.type,\n      isSVG,\n      props && props.is,\n      props\n    );\n    if (shapeFlag & 8) {\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & 16) {\n      mountChildren(\n        vnode.children,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        isSVG && type !== \"foreignObject\",\n        slotScopeIds,\n        optimized\n      );\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n    }\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n    if (props) {\n      for (const key in props) {\n        if (key !== \"value\" && !shared.isReservedProp(key)) {\n          hostPatchProp(\n            el,\n            key,\n            null,\n            props[key],\n            isSVG,\n            vnode.children,\n            parentComponent,\n            parentSuspense,\n            unmountChildren\n          );\n        }\n      }\n      if (\"value\" in props) {\n        hostPatchProp(el, \"value\", null, props.value);\n      }\n      if (vnodeHook = props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      }\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n    }\n    const needCallTransitionHooks = needTransition(parentSuspense, transition);\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n    hostInsert(el, container, anchor);\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n      }, parentSuspense);\n    }\n  };\n  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i]);\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree;\n      if (vnode === subTree) {\n        const parentVNode = parentComponent.vnode;\n        setScopeId(\n          el,\n          parentVNode,\n          parentVNode.scopeId,\n          parentVNode.slotScopeIds,\n          parentComponent.parent\n        );\n      }\n    }\n  };\n  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(\n        null,\n        child,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      );\n    }\n  };\n  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    const el = n2.el = n1.el;\n    let { patchFlag, dynamicChildren, dirs } = n2;\n    patchFlag |= n1.patchFlag & 16;\n    const oldProps = n1.props || shared.EMPTY_OBJ;\n    const newProps = n2.props || shared.EMPTY_OBJ;\n    let vnodeHook;\n    parentComponent && toggleRecurse(parentComponent, false);\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, \"beforeUpdate\");\n    }\n    parentComponent && toggleRecurse(parentComponent, true);\n    const areChildrenSVG = isSVG && n2.type !== \"foreignObject\";\n    if (dynamicChildren) {\n      patchBlockChildren(\n        n1.dynamicChildren,\n        dynamicChildren,\n        el,\n        parentComponent,\n        parentSuspense,\n        areChildrenSVG,\n        slotScopeIds\n      );\n    } else if (!optimized) {\n      patchChildren(\n        n1,\n        n2,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        areChildrenSVG,\n        slotScopeIds,\n        false\n      );\n    }\n    if (patchFlag > 0) {\n      if (patchFlag & 16) {\n        patchProps(\n          el,\n          n2,\n          oldProps,\n          newProps,\n          parentComponent,\n          parentSuspense,\n          isSVG\n        );\n      } else {\n        if (patchFlag & 2) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, \"class\", null, newProps.class, isSVG);\n          }\n        }\n        if (patchFlag & 4) {\n          hostPatchProp(el, \"style\", oldProps.style, newProps.style, isSVG);\n        }\n        if (patchFlag & 8) {\n          const propsToUpdate = n2.dynamicProps;\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i];\n            const prev = oldProps[key];\n            const next = newProps[key];\n            if (next !== prev || key === \"value\") {\n              hostPatchProp(\n                el,\n                key,\n                prev,\n                next,\n                isSVG,\n                n1.children,\n                parentComponent,\n                parentSuspense,\n                unmountChildren\n              );\n            }\n          }\n        }\n      }\n      if (patchFlag & 1) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children);\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      patchProps(\n        el,\n        n2,\n        oldProps,\n        newProps,\n        parentComponent,\n        parentSuspense,\n        isSVG\n      );\n    }\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, \"updated\");\n      }, parentSuspense);\n    }\n  };\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i];\n      const container = (\n        // oldVNode may be an errored async setup() component inside Suspense\n        // which will not have a mounted element\n        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent\n        // of the Fragment itself so it can move its children.\n        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement\n        // which also requires the correct parent container\n        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.\n        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (\n          // In other cases, the parent container is not actually used so we\n          // just pass the block element here to avoid a DOM parentNode call.\n          fallbackContainer\n        )\n      );\n      patch(\n        oldVNode,\n        newVNode,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        true\n      );\n    }\n  };\n  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== shared.EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!shared.isReservedProp(key) && !(key in newProps)) {\n            hostPatchProp(\n              el,\n              key,\n              oldProps[key],\n              null,\n              isSVG,\n              vnode.children,\n              parentComponent,\n              parentSuspense,\n              unmountChildren\n            );\n          }\n        }\n      }\n      for (const key in newProps) {\n        if (shared.isReservedProp(key))\n          continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n        if (next !== prev && key !== \"value\") {\n          hostPatchProp(\n            el,\n            key,\n            prev,\n            next,\n            isSVG,\n            vnode.children,\n            parentComponent,\n            parentSuspense,\n            unmountChildren\n          );\n        }\n      }\n      if (\"value\" in newProps) {\n        hostPatchProp(el, \"value\", oldProps.value, newProps.value);\n      }\n    }\n  };\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText(\"\");\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText(\"\");\n    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor);\n      mountChildren(\n        n2.children,\n        container,\n        fragmentEndAnchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      );\n    } else {\n      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result\n      // of renderSlot() with no valid children\n      n1.dynamicChildren) {\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          container,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds\n        );\n        if (\n          // #2080 if the stable fragment has a key, it's a <template v-for> that may\n          //  get moved around. Make sure all root level vnodes inherit el.\n          // #2134 or if it's a component root, it may also get moved around\n          // as the component is being moved.\n          n2.key != null || parentComponent && n2 === parentComponent.subTree\n        ) {\n          traverseStaticChildren(\n            n1,\n            n2,\n            true\n            /* shallow */\n          );\n        }\n      } else {\n        patchChildren(\n          n1,\n          n2,\n          container,\n          fragmentEndAnchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n      }\n    }\n  };\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    n2.slotScopeIds = slotScopeIds;\n    if (n1 == null) {\n      if (n2.shapeFlag & 512) {\n        parentComponent.ctx.activate(\n          n2,\n          container,\n          anchor,\n          isSVG,\n          optimized\n        );\n      } else {\n        mountComponent(\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        );\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    const instance = (initialVNode.component = createComponentInstance(\n      initialVNode,\n      parentComponent,\n      parentSuspense\n    ));\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    }\n    {\n      setupComponent(instance);\n    }\n    if (instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n      }\n      return;\n    }\n    setupRenderEffect(\n      instance,\n      initialVNode,\n      container,\n      anchor,\n      parentSuspense,\n      isSVG,\n      optimized\n    );\n  };\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        updateComponentPreRender(instance, n2, optimized);\n        return;\n      } else {\n        instance.next = n2;\n        invalidateJob(instance.update);\n        instance.update();\n      }\n    } else {\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const { el, props } = initialVNode;\n        const { bm, m, parent } = instance;\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n        toggleRecurse(instance, false);\n        if (bm) {\n          shared.invokeArrayFns(bm);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        }\n        toggleRecurse(instance, true);\n        if (el && hydrateNode) {\n          const hydrateSubTree = () => {\n            instance.subTree = renderComponentRoot(instance);\n            hydrateNode(\n              el,\n              instance.subTree,\n              instance,\n              parentSuspense,\n              null\n            );\n          };\n          if (isAsyncWrapperVNode) {\n            initialVNode.type.__asyncLoader().then(\n              // note: we are moving the render call into an async callback,\n              // which means it won't track dependencies - but it's ok because\n              // a server-rendered async wrapper is already in resolved state\n              // and it will never need to change.\n              () => !instance.isUnmounted && hydrateSubTree()\n            );\n          } else {\n            hydrateSubTree();\n          }\n        } else {\n          const subTree = instance.subTree = renderComponentRoot(instance);\n          patch(\n            null,\n            subTree,\n            container,\n            anchor,\n            instance,\n            parentSuspense,\n            isSVG\n          );\n          initialVNode.el = subTree.el;\n        }\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {\n          const scopedInitialVNode = initialVNode;\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),\n            parentSuspense\n          );\n        }\n        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n        }\n        instance.isMounted = true;\n        initialVNode = container = anchor = null;\n      } else {\n        let { next, bu, u, parent, vnode } = instance;\n        let originNext = next;\n        let vnodeHook;\n        toggleRecurse(instance, false);\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        }\n        if (bu) {\n          shared.invokeArrayFns(bu);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        }\n        toggleRecurse(instance, true);\n        const nextTree = renderComponentRoot(instance);\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n        patch(\n          prevTree,\n          nextTree,\n          // parent may have changed if it's in a teleport\n          hostParentNode(prevTree.el),\n          // anchor may have changed if it's in a fragment\n          getNextHostNode(prevTree),\n          instance,\n          parentSuspense,\n          isSVG\n        );\n        next.el = nextTree.el;\n        if (originNext === null) {\n          updateHOCHostEl(instance, nextTree.el);\n        }\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook, parent, next, vnode),\n            parentSuspense\n          );\n        }\n      }\n    };\n    const effect = instance.effect = new reactivity.ReactiveEffect(\n      componentUpdateFn,\n      () => queueJob(update),\n      instance.scope\n      // track it in component's effect scope\n    );\n    const update = instance.update = () => effect.run();\n    update.id = instance.uid;\n    toggleRecurse(instance, true);\n    update();\n  };\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children, optimized);\n    reactivity.pauseTracking();\n    flushPreFlushCbs();\n    reactivity.resetTracking();\n  };\n  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const { patchFlag, shapeFlag } = n2;\n    if (patchFlag > 0) {\n      if (patchFlag & 128) {\n        patchKeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n        return;\n      } else if (patchFlag & 256) {\n        patchUnkeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n        return;\n      }\n    }\n    if (shapeFlag & 8) {\n      if (prevShapeFlag & 16) {\n        unmountChildren(c1, parentComponent, parentSuspense);\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2);\n      }\n    } else {\n      if (prevShapeFlag & 16) {\n        if (shapeFlag & 16) {\n          patchKeyedChildren(\n            c1,\n            c2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n        } else {\n          unmountChildren(c1, parentComponent, parentSuspense, true);\n        }\n      } else {\n        if (prevShapeFlag & 8) {\n          hostSetElementText(container, \"\");\n        }\n        if (shapeFlag & 16) {\n          mountChildren(\n            c2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n        }\n      }\n    }\n  };\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    c1 = c1 || shared.EMPTY_ARR;\n    c2 = c2 || shared.EMPTY_ARR;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(\n        c1[i],\n        nextChild,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      );\n    }\n    if (oldLength > newLength) {\n      unmountChildren(\n        c1,\n        parentComponent,\n        parentSuspense,\n        true,\n        false,\n        commonLength\n      );\n    } else {\n      mountChildren(\n        c2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized,\n        commonLength\n      );\n    }\n  };\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1;\n    let e2 = l2 - 1;\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n      } else {\n        break;\n      }\n      i++;\n    }\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        );\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n        while (i <= e2) {\n          patch(\n            null,\n            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n          i++;\n        }\n      }\n    } else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true);\n        i++;\n      }\n    } else {\n      const s1 = i;\n      const s2 = i;\n      const keyToNewIndexMap = /* @__PURE__ */ new Map();\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (nextChild.key != null) {\n          keyToNewIndexMap.set(nextChild.key, i);\n        }\n      }\n      let j;\n      let patched = 0;\n      const toBePatched = e2 - s2 + 1;\n      let moved = false;\n      let maxNewIndexSoFar = 0;\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      for (i = 0; i < toBePatched; i++)\n        newIndexToOldIndexMap[i] = 0;\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n        if (patched >= toBePatched) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n          continue;\n        }\n        let newIndex;\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          for (j = s2; j <= e2; j++) {\n            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n        if (newIndex === void 0) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n          patch(\n            prevChild,\n            c2[newIndex],\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n          patched++;\n        }\n      }\n      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : shared.EMPTY_ARR;\n      j = increasingNewIndexSequence.length - 1;\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n        if (newIndexToOldIndexMap[i] === 0) {\n          patch(\n            null,\n            nextChild,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n        } else if (moved) {\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, 2);\n          } else {\n            j--;\n          }\n        }\n      }\n    }\n  };\n  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n    const { el, type, transition, children, shapeFlag } = vnode;\n    if (shapeFlag & 6) {\n      move(vnode.component.subTree, container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 128) {\n      vnode.suspense.move(container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 64) {\n      type.move(vnode, container, anchor, internals);\n      return;\n    }\n    if (type === Fragment) {\n      hostInsert(el, container, anchor);\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    }\n    if (type === Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    }\n    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;\n    if (needTransition2) {\n      if (moveType === 0) {\n        transition.beforeEnter(el);\n        hostInsert(el, container, anchor);\n        queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n      } else {\n        const { leave, delayLeave, afterLeave } = transition;\n        const remove2 = () => hostInsert(el, container, anchor);\n        const performLeave = () => {\n          leave(el, () => {\n            remove2();\n            afterLeave && afterLeave();\n          });\n        };\n        if (delayLeave) {\n          delayLeave(el, remove2, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode;\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode, true);\n    }\n    if (shapeFlag & 256) {\n      parentComponent.ctx.deactivate(vnode);\n      return;\n    }\n    const shouldInvokeDirs = shapeFlag & 1 && dirs;\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n    let vnodeHook;\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n    if (shapeFlag & 6) {\n      unmountComponent(vnode.component, parentSuspense, doRemove);\n    } else {\n      if (shapeFlag & 128) {\n        vnode.suspense.unmount(parentSuspense, doRemove);\n        return;\n      }\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeUnmount\");\n      }\n      if (shapeFlag & 64) {\n        vnode.type.remove(\n          vnode,\n          parentComponent,\n          parentSuspense,\n          optimized,\n          internals,\n          doRemove\n        );\n      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments\n      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {\n        unmountChildren(\n          dynamicChildren,\n          parentComponent,\n          parentSuspense,\n          false,\n          true\n        );\n      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {\n        unmountChildren(children, parentComponent, parentSuspense);\n      }\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, \"unmounted\");\n      }, parentSuspense);\n    }\n  };\n  const remove = (vnode) => {\n    const { type, el, anchor, transition } = vnode;\n    if (type === Fragment) {\n      {\n        removeFragment(el, anchor);\n      }\n      return;\n    }\n    if (type === Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n    const performRemove = () => {\n      hostRemove(el);\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {\n      const { leave, delayLeave } = transition;\n      const performLeave = () => leave(el, performRemove);\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n  const removeFragment = (cur, end) => {\n    let next;\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n    hostRemove(end);\n  };\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    const { bum, scope, update, subTree, um } = instance;\n    if (bum) {\n      shared.invokeArrayFns(bum);\n    }\n    scope.stop();\n    if (update) {\n      update.active = false;\n      unmount(subTree, instance, parentSuspense, doRemove);\n    }\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense);\n    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {\n      parentSuspense.deps--;\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve();\n      }\n    }\n  };\n  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n  const getNextHostNode = (vnode) => {\n    if (vnode.shapeFlag & 6) {\n      return getNextHostNode(vnode.component.subTree);\n    }\n    if (vnode.shapeFlag & 128) {\n      return vnode.suspense.next();\n    }\n    return hostNextSibling(vnode.anchor || vnode.el);\n  };\n  const render = (vnode, container, isSVG) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(container._vnode || null, vnode, container, null, null, null, isSVG);\n    }\n    flushPreFlushCbs();\n    flushPostFlushCbs();\n    container._vnode = vnode;\n  };\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(\n      internals\n    );\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\nfunction toggleRecurse({ effect, update }, allowed) {\n  effect.allowRecurse = update.allowRecurse = allowed;\n}\nfunction needTransition(parentSuspense, transition) {\n  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n}\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n  if (shared.isArray(ch1) && shared.isArray(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i]);\n          c2.el = c1.el;\n        }\n        if (!shallow)\n          traverseStaticChildren(c1, c2);\n      }\n      if (c2.type === Text) {\n        c2.el = c1.el;\n      }\n    }\n  }\n}\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\n\nconst isTeleport = (type) => type.__isTeleport;\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === \"\");\nconst isTargetSVG = (target) => typeof SVGElement !== \"undefined\" && target instanceof SVGElement;\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n  if (shared.isString(targetSelector)) {\n    if (!select) {\n      return null;\n    } else {\n      const target = select(targetSelector);\n      return target;\n    }\n  } else {\n    return targetSelector;\n  }\n};\nconst TeleportImpl = {\n  name: \"Teleport\",\n  __isTeleport: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: { insert, querySelector, createText, createComment }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    let { shapeFlag, children, dynamicChildren } = n2;\n    if (n1 == null) {\n      const placeholder = n2.el = createText(\"\");\n      const mainAnchor = n2.anchor = createText(\"\");\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const target = n2.target = resolveTarget(n2.props, querySelector);\n      const targetAnchor = n2.targetAnchor = createText(\"\");\n      if (target) {\n        insert(targetAnchor, target);\n        isSVG = isSVG || isTargetSVG(target);\n      }\n      const mount = (container2, anchor2) => {\n        if (shapeFlag & 16) {\n          mountChildren(\n            children,\n            container2,\n            anchor2,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          );\n        }\n      };\n      if (disabled) {\n        mount(container, mainAnchor);\n      } else if (target) {\n        mount(target, targetAnchor);\n      }\n    } else {\n      n2.el = n1.el;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n      isSVG = isSVG || isTargetSVG(target);\n      if (dynamicChildren) {\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          currentContainer,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds\n        );\n        traverseStaticChildren(n1, n2, true);\n      } else if (!optimized) {\n        patchChildren(\n          n1,\n          n2,\n          currentContainer,\n          currentAnchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          false\n        );\n      }\n      if (disabled) {\n        if (!wasDisabled) {\n          moveTeleport(\n            n2,\n            container,\n            mainAnchor,\n            internals,\n            1\n          );\n        } else {\n          if (n2.props && n1.props && n2.props.to !== n1.props.to) {\n            n2.props.to = n1.props.to;\n          }\n        }\n      } else {\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(\n            n2.props,\n            querySelector\n          );\n          if (nextTarget) {\n            moveTeleport(\n              n2,\n              nextTarget,\n              null,\n              internals,\n              0\n            );\n          }\n        } else if (wasDisabled) {\n          moveTeleport(\n            n2,\n            target,\n            targetAnchor,\n            internals,\n            1\n          );\n        }\n      }\n    }\n    updateCssVars(n2);\n  },\n  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {\n    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;\n    if (target) {\n      hostRemove(targetAnchor);\n    }\n    doRemove && hostRemove(anchor);\n    if (shapeFlag & 16) {\n      const shouldRemove = doRemove || !isTeleportDisabled(props);\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        unmount(\n          child,\n          parentComponent,\n          parentSuspense,\n          shouldRemove,\n          !!child.dynamicChildren\n        );\n      }\n    }\n  },\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {\n  if (moveType === 0) {\n    insert(vnode.targetAnchor, container, parentAnchor);\n  }\n  const { el, anchor, shapeFlag, children, props } = vnode;\n  const isReorder = moveType === 2;\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  }\n  if (!isReorder || isTeleportDisabled(props)) {\n    if (shapeFlag & 16) {\n      for (let i = 0; i < children.length; i++) {\n        move(\n          children[i],\n          container,\n          parentAnchor,\n          2\n        );\n      }\n    }\n  }\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {\n  o: { nextSibling, parentNode, querySelector }\n}, hydrateChildren) {\n  const target = vnode.target = resolveTarget(\n    vnode.props,\n    querySelector\n  );\n  if (target) {\n    const targetNode = target._lpa || target.firstChild;\n    if (vnode.shapeFlag & 16) {\n      if (isTeleportDisabled(vnode.props)) {\n        vnode.anchor = hydrateChildren(\n          nextSibling(node),\n          vnode,\n          parentNode(node),\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n        vnode.targetAnchor = targetNode;\n      } else {\n        vnode.anchor = nextSibling(node);\n        let targetAnchor = targetNode;\n        while (targetAnchor) {\n          targetAnchor = nextSibling(targetAnchor);\n          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === \"teleport anchor\") {\n            vnode.targetAnchor = targetAnchor;\n            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n            break;\n          }\n        }\n        hydrateChildren(\n          targetNode,\n          vnode,\n          target,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n      }\n    }\n    updateCssVars(vnode);\n  }\n  return vnode.anchor && nextSibling(vnode.anchor);\n}\nconst Teleport = TeleportImpl;\nfunction updateCssVars(vnode) {\n  const ctx = vnode.ctx;\n  if (ctx && ctx.ut) {\n    let node = vnode.children[0].el;\n    while (node && node !== vnode.targetAnchor) {\n      if (node.nodeType === 1)\n        node.setAttribute(\"data-v-owner\", ctx.uid);\n      node = node.nextSibling;\n    }\n    ctx.ut();\n  }\n}\n\nconst Fragment = Symbol.for(\"v-fgt\");\nconst Text = Symbol.for(\"v-txt\");\nconst Comment = Symbol.for(\"v-cmt\");\nconst Static = Symbol.for(\"v-stc\");\nconst blockStack = [];\nlet currentBlock = null;\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\nlet isBlockTreeEnabled = 1;\nfunction setBlockTracking(value) {\n  isBlockTreeEnabled += value;\n}\nfunction setupBlock(vnode) {\n  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || shared.EMPTY_ARR : null;\n  closeBlock();\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(\n    createBaseVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      shapeFlag,\n      true\n      /* isBlock */\n    )\n  );\n}\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  return setupBlock(\n    createVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      true\n      /* isBlock: prevent a block from tracking itself */\n    )\n  );\n}\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\nfunction isSameVNodeType(n1, n2) {\n  return n1.type === n2.type && n1.key === n2.key;\n}\nfunction transformVNodeArgs(transformer) {\n}\nconst InternalObjectKey = `__vInternal`;\nconst normalizeKey = ({ key }) => key != null ? key : null;\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}) => {\n  if (typeof ref === \"number\") {\n    ref = \"\" + ref;\n  }\n  return ref != null ? shared.isString(ref) || reactivity.isRef(ref) || shared.isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;\n};\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: currentRenderingInstance\n  };\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children);\n    if (shapeFlag & 128) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    vnode.shapeFlag |= shared.isString(children) ? 8 : 16;\n  }\n  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself\n  !isBlockNode && // has current parent block\n  currentBlock && // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nconst createVNode = _createVNode;\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    type = Comment;\n  }\n  if (isVNode(type)) {\n    const cloned = cloneVNode(\n      type,\n      props,\n      true\n      /* mergeRef: true */\n    );\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n      if (cloned.shapeFlag & 6) {\n        currentBlock[currentBlock.indexOf(type)] = cloned;\n      } else {\n        currentBlock.push(cloned);\n      }\n    }\n    cloned.patchFlag |= -2;\n    return cloned;\n  }\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  }\n  if (props) {\n    props = guardReactiveProps(props);\n    let { class: klass, style } = props;\n    if (klass && !shared.isString(klass)) {\n      props.class = shared.normalizeClass(klass);\n    }\n    if (shared.isObject(style)) {\n      if (reactivity.isProxy(style) && !shared.isArray(style)) {\n        style = shared.extend({}, style);\n      }\n      props.style = shared.normalizeStyle(style);\n    }\n  }\n  const shapeFlag = shared.isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : shared.isObject(type) ? 4 : shared.isFunction(type) ? 2 : 0;\n  return createBaseVNode(\n    type,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    shapeFlag,\n    isBlockNode,\n    true\n  );\n}\nfunction guardReactiveProps(props) {\n  if (!props)\n    return null;\n  return reactivity.isProxy(props) || InternalObjectKey in props ? shared.extend({}, props) : props;\n}\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\n  const { props, ref, patchFlag, children } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ? (\n      // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n      // if the vnode itself already has a ref, cloneVNode will need to merge\n      // the refs so the single vnode can be set on multiple refs\n      mergeRef && ref ? shared.isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)\n    ) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children: children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition: vnode.transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor,\n    ctx: vnode.ctx,\n    ce: vnode.ce\n  };\n  return cloned;\n}\nfunction createTextVNode(text = \" \", flag = 0) {\n  return createVNode(Text, null, text, flag);\n}\nfunction createStaticVNode(content, numberOfNodes) {\n  const vnode = createVNode(Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\nfunction createCommentVNode(text = \"\", asBlock = false) {\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);\n}\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === \"boolean\") {\n    return createVNode(Comment);\n  } else if (shared.isArray(child)) {\n    return createVNode(\n      Fragment,\n      null,\n      // #3666, avoid reference pollution when reusing vnode\n      child.slice()\n    );\n  } else if (typeof child === \"object\") {\n    return cloneIfMounted(child);\n  } else {\n    return createVNode(Text, null, String(child));\n  }\n}\nfunction cloneIfMounted(child) {\n  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const { shapeFlag } = vnode;\n  if (children == null) {\n    children = null;\n  } else if (shared.isArray(children)) {\n    type = 16;\n  } else if (typeof children === \"object\") {\n    if (shapeFlag & (1 | 64)) {\n      const slot = children.default;\n      if (slot) {\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n      return;\n    } else {\n      type = 32;\n      const slotFlag = children._;\n      if (!slotFlag && !(InternalObjectKey in children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3 && currentRenderingInstance) {\n        if (currentRenderingInstance.slots._ === 1) {\n          children._ = 1;\n        } else {\n          children._ = 2;\n          vnode.patchFlag |= 1024;\n        }\n      }\n    }\n  } else if (shared.isFunction(children)) {\n    children = { default: children, _ctx: currentRenderingInstance };\n    type = 32;\n  } else {\n    children = String(children);\n    if (shapeFlag & 64) {\n      type = 16;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8;\n    }\n  }\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\nfunction mergeProps(...args) {\n  const ret = {};\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i];\n    for (const key in toMerge) {\n      if (key === \"class\") {\n        if (ret.class !== toMerge.class) {\n          ret.class = shared.normalizeClass([ret.class, toMerge.class]);\n        }\n      } else if (key === \"style\") {\n        ret.style = shared.normalizeStyle([ret.style, toMerge.style]);\n      } else if (shared.isOn(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n        if (incoming && existing !== incoming && !(shared.isArray(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== \"\") {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n  return ret;\n}\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n  callWithAsyncErrorHandling(hook, instance, 7, [\n    vnode,\n    prevVNode\n  ]);\n}\n\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type;\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    // to be immediately set\n    next: null,\n    subTree: null,\n    // will be set synchronously right after creation\n    effect: null,\n    update: null,\n    // will be set synchronously right after creation\n    scope: new reactivity.EffectScope(\n      true\n      /* detached */\n    ),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    // to be set immediately\n    emitted: null,\n    // props default value\n    propsDefaults: shared.EMPTY_OBJ,\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n    // state\n    ctx: shared.EMPTY_OBJ,\n    data: shared.EMPTY_OBJ,\n    props: shared.EMPTY_OBJ,\n    attrs: shared.EMPTY_OBJ,\n    slots: shared.EMPTY_OBJ,\n    refs: shared.EMPTY_OBJ,\n    setupState: shared.EMPTY_OBJ,\n    setupContext: null,\n    attrsProxy: null,\n    slotsProxy: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  {\n    instance.ctx = { _: instance };\n  }\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n  if (vnode.ce) {\n    vnode.ce(instance);\n  }\n  return instance;\n}\nlet currentInstance = null;\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\nlet internalSetCurrentInstance;\nlet globalCurrentInstanceSetters;\nlet settersKey = \"__VUE_INSTANCE_SETTERS__\";\n{\n  if (!(globalCurrentInstanceSetters = shared.getGlobalThis()[settersKey])) {\n    globalCurrentInstanceSetters = shared.getGlobalThis()[settersKey] = [];\n  }\n  globalCurrentInstanceSetters.push((i) => currentInstance = i);\n  internalSetCurrentInstance = (instance) => {\n    if (globalCurrentInstanceSetters.length > 1) {\n      globalCurrentInstanceSetters.forEach((s) => s(instance));\n    } else {\n      globalCurrentInstanceSetters[0](instance);\n    }\n  };\n}\nconst setCurrentInstance = (instance) => {\n  internalSetCurrentInstance(instance);\n  instance.scope.on();\n};\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  internalSetCurrentInstance(null);\n};\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4;\n}\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance, isSSR = false) {\n  isInSSRComponentSetup = isSSR;\n  const { props, children } = instance.vnode;\n  const isStateful = isStatefulComponent(instance);\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;\n  isInSSRComponentSetup = false;\n  return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n  const Component = instance.type;\n  instance.accessCache = /* @__PURE__ */ Object.create(null);\n  instance.proxy = reactivity.markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\n  const { setup } = Component;\n  if (setup) {\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    setCurrentInstance(instance);\n    reactivity.pauseTracking();\n    const setupResult = callWithErrorHandling(\n      setup,\n      instance,\n      0,\n      [instance.props, setupContext]\n    );\n    reactivity.resetTracking();\n    unsetCurrentInstance();\n    if (shared.isPromise(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n      if (isSSR) {\n        return setupResult.then((resolvedResult) => {\n          handleSetupResult(instance, resolvedResult, isSSR);\n        }).catch((e) => {\n          handleError(e, instance, 0);\n        });\n      } else {\n        instance.asyncDep = setupResult;\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR);\n    }\n  } else {\n    finishComponentSetup(instance, isSSR);\n  }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if (shared.isFunction(setupResult)) {\n    if (instance.type.__ssrInlineRender) {\n      instance.ssrRender = setupResult;\n    } else {\n      instance.render = setupResult;\n    }\n  } else if (shared.isObject(setupResult)) {\n    instance.setupState = reactivity.proxyRefs(setupResult);\n  } else ;\n  finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n  installWithProxy = (i) => {\n    if (i.render._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  };\n}\nconst isRuntimeOnly = () => !compile;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n  const Component = instance.type;\n  if (!instance.render) {\n    if (!isSSR && compile && !Component.render) {\n      const template = Component.template || resolveMergedOptions(instance).template;\n      if (template) {\n        const { isCustomElement, compilerOptions } = instance.appContext.config;\n        const { delimiters, compilerOptions: componentCompilerOptions } = Component;\n        const finalCompilerOptions = shared.extend(\n          shared.extend(\n            {\n              isCustomElement,\n              delimiters\n            },\n            compilerOptions\n          ),\n          componentCompilerOptions\n        );\n        Component.render = compile(template, finalCompilerOptions);\n      }\n    }\n    instance.render = Component.render || shared.NOOP;\n    if (installWithProxy) {\n      installWithProxy(instance);\n    }\n  }\n  {\n    setCurrentInstance(instance);\n    reactivity.pauseTracking();\n    try {\n      applyOptions(instance);\n    } finally {\n      reactivity.resetTracking();\n      unsetCurrentInstance();\n    }\n  }\n}\nfunction getAttrsProxy(instance) {\n  return instance.attrsProxy || (instance.attrsProxy = new Proxy(\n    instance.attrs,\n    {\n      get(target, key) {\n        reactivity.track(instance, \"get\", \"$attrs\");\n        return target[key];\n      }\n    }\n  ));\n}\nfunction createSetupContext(instance) {\n  const expose = (exposed) => {\n    instance.exposed = exposed || {};\n  };\n  {\n    return {\n      get attrs() {\n        return getAttrsProxy(instance);\n      },\n      slots: instance.slots,\n      emit: instance.emit,\n      expose\n    };\n  }\n}\nfunction getExposeProxy(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy(reactivity.proxyRefs(reactivity.markRaw(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      },\n      has(target, key) {\n        return key in target || key in publicPropertiesMap;\n      }\n    }));\n  }\n}\nfunction getComponentName(Component, includeInferred = true) {\n  return shared.isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\nfunction isClassComponent(value) {\n  return shared.isFunction(value) && \"__vccOpts\" in value;\n}\n\nconst computed = (getterOrOptions, debugOptions) => {\n  return reactivity.computed(getterOrOptions, debugOptions, isInSSRComponentSetup);\n};\n\nfunction h(type, propsOrChildren, children) {\n  const l = arguments.length;\n  if (l === 2) {\n    if (shared.isObject(propsOrChildren) && !shared.isArray(propsOrChildren)) {\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren]);\n      }\n      return createVNode(type, propsOrChildren);\n    } else {\n      return createVNode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2);\n    } else if (l === 3 && isVNode(children)) {\n      children = [children];\n    }\n    return createVNode(type, propsOrChildren, children);\n  }\n}\n\nconst ssrContextKey = Symbol.for(\"v-scx\");\nconst useSSRContext = () => {\n  {\n    const ctx = inject(ssrContextKey);\n    return ctx;\n  }\n};\n\nfunction initCustomFormatter() {\n  {\n    return;\n  }\n}\n\nfunction withMemo(memo, render, cache, index) {\n  const cached = cache[index];\n  if (cached && isMemoSame(cached, memo)) {\n    return cached;\n  }\n  const ret = render();\n  ret.memo = memo.slice();\n  return cache[index] = ret;\n}\nfunction isMemoSame(cached, memo) {\n  const prev = cached.memo;\n  if (prev.length != memo.length) {\n    return false;\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if (shared.hasChanged(prev[i], memo[i])) {\n      return false;\n    }\n  }\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached);\n  }\n  return true;\n}\n\nconst version = \"3.3.9\";\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode: isVNode,\n  normalizeVNode\n};\nconst ssrUtils = _ssrUtils ;\nconst resolveFilter = null;\nconst compatUtils = null;\n\nexports.EffectScope = reactivity.EffectScope;\nexports.ReactiveEffect = reactivity.ReactiveEffect;\nexports.customRef = reactivity.customRef;\nexports.effect = reactivity.effect;\nexports.effectScope = reactivity.effectScope;\nexports.getCurrentScope = reactivity.getCurrentScope;\nexports.isProxy = reactivity.isProxy;\nexports.isReactive = reactivity.isReactive;\nexports.isReadonly = reactivity.isReadonly;\nexports.isRef = reactivity.isRef;\nexports.isShallow = reactivity.isShallow;\nexports.markRaw = reactivity.markRaw;\nexports.onScopeDispose = reactivity.onScopeDispose;\nexports.proxyRefs = reactivity.proxyRefs;\nexports.reactive = reactivity.reactive;\nexports.readonly = reactivity.readonly;\nexports.ref = reactivity.ref;\nexports.shallowReactive = reactivity.shallowReactive;\nexports.shallowReadonly = reactivity.shallowReadonly;\nexports.shallowRef = reactivity.shallowRef;\nexports.stop = reactivity.stop;\nexports.toRaw = reactivity.toRaw;\nexports.toRef = reactivity.toRef;\nexports.toRefs = reactivity.toRefs;\nexports.toValue = reactivity.toValue;\nexports.triggerRef = reactivity.triggerRef;\nexports.unref = reactivity.unref;\nexports.camelize = shared.camelize;\nexports.capitalize = shared.capitalize;\nexports.normalizeClass = shared.normalizeClass;\nexports.normalizeProps = shared.normalizeProps;\nexports.normalizeStyle = shared.normalizeStyle;\nexports.toDisplayString = shared.toDisplayString;\nexports.toHandlerKey = shared.toHandlerKey;\nexports.BaseTransition = BaseTransition;\nexports.BaseTransitionPropsValidators = BaseTransitionPropsValidators;\nexports.Comment = Comment;\nexports.Fragment = Fragment;\nexports.KeepAlive = KeepAlive;\nexports.Static = Static;\nexports.Suspense = Suspense;\nexports.Teleport = Teleport;\nexports.Text = Text;\nexports.assertNumber = assertNumber;\nexports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;\nexports.callWithErrorHandling = callWithErrorHandling;\nexports.cloneVNode = cloneVNode;\nexports.compatUtils = compatUtils;\nexports.computed = computed;\nexports.createBlock = createBlock;\nexports.createCommentVNode = createCommentVNode;\nexports.createElementBlock = createElementBlock;\nexports.createElementVNode = createBaseVNode;\nexports.createHydrationRenderer = createHydrationRenderer;\nexports.createPropsRestProxy = createPropsRestProxy;\nexports.createRenderer = createRenderer;\nexports.createSlots = createSlots;\nexports.createStaticVNode = createStaticVNode;\nexports.createTextVNode = createTextVNode;\nexports.createVNode = createVNode;\nexports.defineAsyncComponent = defineAsyncComponent;\nexports.defineComponent = defineComponent;\nexports.defineEmits = defineEmits;\nexports.defineExpose = defineExpose;\nexports.defineModel = defineModel;\nexports.defineOptions = defineOptions;\nexports.defineProps = defineProps;\nexports.defineSlots = defineSlots;\nexports.getCurrentInstance = getCurrentInstance;\nexports.getTransitionRawChildren = getTransitionRawChildren;\nexports.guardReactiveProps = guardReactiveProps;\nexports.h = h;\nexports.handleError = handleError;\nexports.hasInjectionContext = hasInjectionContext;\nexports.initCustomFormatter = initCustomFormatter;\nexports.inject = inject;\nexports.isMemoSame = isMemoSame;\nexports.isRuntimeOnly = isRuntimeOnly;\nexports.isVNode = isVNode;\nexports.mergeDefaults = mergeDefaults;\nexports.mergeModels = mergeModels;\nexports.mergeProps = mergeProps;\nexports.nextTick = nextTick;\nexports.onActivated = onActivated;\nexports.onBeforeMount = onBeforeMount;\nexports.onBeforeUnmount = onBeforeUnmount;\nexports.onBeforeUpdate = onBeforeUpdate;\nexports.onDeactivated = onDeactivated;\nexports.onErrorCaptured = onErrorCaptured;\nexports.onMounted = onMounted;\nexports.onRenderTracked = onRenderTracked;\nexports.onRenderTriggered = onRenderTriggered;\nexports.onServerPrefetch = onServerPrefetch;\nexports.onUnmounted = onUnmounted;\nexports.onUpdated = onUpdated;\nexports.openBlock = openBlock;\nexports.popScopeId = popScopeId;\nexports.provide = provide;\nexports.pushScopeId = pushScopeId;\nexports.queuePostFlushCb = queuePostFlushCb;\nexports.registerRuntimeCompiler = registerRuntimeCompiler;\nexports.renderList = renderList;\nexports.renderSlot = renderSlot;\nexports.resolveComponent = resolveComponent;\nexports.resolveDirective = resolveDirective;\nexports.resolveDynamicComponent = resolveDynamicComponent;\nexports.resolveFilter = resolveFilter;\nexports.resolveTransitionHooks = resolveTransitionHooks;\nexports.setBlockTracking = setBlockTracking;\nexports.setDevtoolsHook = setDevtoolsHook;\nexports.setTransitionHooks = setTransitionHooks;\nexports.ssrContextKey = ssrContextKey;\nexports.ssrUtils = ssrUtils;\nexports.toHandlers = toHandlers;\nexports.transformVNodeArgs = transformVNodeArgs;\nexports.useAttrs = useAttrs;\nexports.useModel = useModel;\nexports.useSSRContext = useSSRContext;\nexports.useSlots = useSlots;\nexports.useTransitionState = useTransitionState;\nexports.version = version;\nexports.warn = warn$1;\nexports.watch = watch;\nexports.watchEffect = watchEffect;\nexports.watchPostEffect = watchPostEffect;\nexports.watchSyncEffect = watchSyncEffect;\nexports.withAsyncContext = withAsyncContext;\nexports.withCtx = withCtx;\nexports.withDefaults = withDefaults;\nexports.withDirectives = withDirectives;\nexports.withMemo = withMemo;\nexports.withScopeId = withScopeId;\n", "'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/runtime-core.cjs.prod.js')\n} else {\n  module.exports = require('./dist/runtime-core.cjs.js')\n}\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar runtimeCore = require('@vue/runtime-core');\nvar shared = require('@vue/shared');\n\nconst svgNS = \"http://www.w3.org/2000/svg\";\nconst doc = typeof document !== \"undefined\" ? document : null;\nconst templateContainer = doc && /* @__PURE__ */ doc.createElement(\"template\");\nconst nodeOps = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null);\n  },\n  remove: (child) => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  createElement: (tag, isSVG, is, props) => {\n    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);\n    if (tag === \"select\" && props && props.multiple != null) {\n      el.setAttribute(\"multiple\", props.multiple);\n    }\n    return el;\n  },\n  createText: (text) => doc.createTextNode(text),\n  createComment: (text) => doc.createComment(text),\n  setText: (node, text) => {\n    node.nodeValue = text;\n  },\n  setElementText: (el, text) => {\n    el.textContent = text;\n  },\n  parentNode: (node) => node.parentNode,\n  nextSibling: (node) => node.nextSibling,\n  querySelector: (selector) => doc.querySelector(selector),\n  setScopeId(el, id) {\n    el.setAttribute(id, \"\");\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, isSVG, start, end) {\n    const before = anchor ? anchor.previousSibling : parent.lastChild;\n    if (start && (start === end || start.nextSibling)) {\n      while (true) {\n        parent.insertBefore(start.cloneNode(true), anchor);\n        if (start === end || !(start = start.nextSibling))\n          break;\n      }\n    } else {\n      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\n      const template = templateContainer.content;\n      if (isSVG) {\n        const wrapper = template.firstChild;\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild);\n        }\n        template.removeChild(wrapper);\n      }\n      parent.insertBefore(template, anchor);\n    }\n    return [\n      // first\n      before ? before.nextSibling : parent.firstChild,\n      // last\n      anchor ? anchor.previousSibling : parent.lastChild\n    ];\n  }\n};\n\nconst TRANSITION = \"transition\";\nconst ANIMATION = \"animation\";\nconst vtcKey = Symbol(\"_vtc\");\nconst Transition = (props, { slots }) => runtimeCore.h(runtimeCore.BaseTransition, resolveTransitionProps(props), slots);\nTransition.displayName = \"Transition\";\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n};\nconst TransitionPropsValidators = Transition.props = /* @__PURE__ */ shared.extend(\n  {},\n  runtimeCore.BaseTransitionPropsValidators,\n  DOMTransitionPropsValidators\n);\nconst callHook = (hook, args = []) => {\n  if (shared.isArray(hook)) {\n    hook.forEach((h2) => h2(...args));\n  } else if (hook) {\n    hook(...args);\n  }\n};\nconst hasExplicitCallback = (hook) => {\n  return hook ? shared.isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;\n};\nfunction resolveTransitionProps(rawProps) {\n  const baseProps = {};\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key];\n    }\n  }\n  if (rawProps.css === false) {\n    return baseProps;\n  }\n  const {\n    name = \"v\",\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps;\n  const durations = normalizeDuration(duration);\n  const enterDuration = durations && durations[0];\n  const leaveDuration = durations && durations[1];\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps;\n  const finishEnter = (el, isAppear, done) => {\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n    done && done();\n  };\n  const finishLeave = (el, done) => {\n    el._isLeaving = false;\n    removeTransitionClass(el, leaveFromClass);\n    removeTransitionClass(el, leaveToClass);\n    removeTransitionClass(el, leaveActiveClass);\n    done && done();\n  };\n  const makeEnterHook = (isAppear) => {\n    return (el, done) => {\n      const hook = isAppear ? onAppear : onEnter;\n      const resolve = () => finishEnter(el, isAppear, done);\n      callHook(hook, [el, resolve]);\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve);\n        }\n      });\n    };\n  };\n  return shared.extend(baseProps, {\n    onBeforeEnter(el) {\n      callHook(onBeforeEnter, [el]);\n      addTransitionClass(el, enterFromClass);\n      addTransitionClass(el, enterActiveClass);\n    },\n    onBeforeAppear(el) {\n      callHook(onBeforeAppear, [el]);\n      addTransitionClass(el, appearFromClass);\n      addTransitionClass(el, appearActiveClass);\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      el._isLeaving = true;\n      const resolve = () => finishLeave(el, done);\n      addTransitionClass(el, leaveFromClass);\n      forceReflow();\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(() => {\n        if (!el._isLeaving) {\n          return;\n        }\n        removeTransitionClass(el, leaveFromClass);\n        addTransitionClass(el, leaveToClass);\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve);\n        }\n      });\n      callHook(onLeave, [el, resolve]);\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false);\n      callHook(onEnterCancelled, [el]);\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true);\n      callHook(onAppearCancelled, [el]);\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el);\n      callHook(onLeaveCancelled, [el]);\n    }\n  });\n}\nfunction normalizeDuration(duration) {\n  if (duration == null) {\n    return null;\n  } else if (shared.isObject(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)];\n  } else {\n    const n = NumberOf(duration);\n    return [n, n];\n  }\n}\nfunction NumberOf(val) {\n  const res = shared.toNumber(val);\n  return res;\n}\nfunction addTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach((c) => c && el.classList.add(c));\n  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach((c) => c && el.classList.remove(c));\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.delete(cls);\n    if (!_vtc.size) {\n      el[vtcKey] = void 0;\n    }\n  }\n}\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb);\n  });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n  const id = el._endId = ++endId;\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve();\n    }\n  };\n  if (explicitTimeout) {\n    return setTimeout(resolveIfNotStale, explicitTimeout);\n  }\n  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\n  if (!type) {\n    return resolve();\n  }\n  const endEvent = type + \"end\";\n  let ended = 0;\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd);\n    resolveIfNotStale();\n  };\n  const onEnd = (e) => {\n    if (e.target === el && ++ended >= propCount) {\n      end();\n    }\n  };\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el);\n  const getStyleProperties = (key) => (styles[key] || \"\").split(\", \");\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type = null;\n  let timeout = 0;\n  let propCount = 0;\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  const hasTransform = type === TRANSITION && /\\b(transform|all)(,|$)/.test(\n    getStyleProperties(`${TRANSITION}Property`).toString()\n  );\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\nfunction getTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\nfunction toMs(s) {\n  if (s === \"auto\")\n    return 0;\n  return Number(s.slice(0, -1).replace(\",\", \".\")) * 1e3;\n}\nfunction forceReflow() {\n  return document.body.offsetHeight;\n}\n\nfunction patchClass(el, value, isSVG) {\n  const transitionClasses = el[vtcKey];\n  if (transitionClasses) {\n    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(\" \");\n  }\n  if (value == null) {\n    el.removeAttribute(\"class\");\n  } else if (isSVG) {\n    el.setAttribute(\"class\", value);\n  } else {\n    el.className = value;\n  }\n}\n\nconst vShowOldKey = Symbol(\"_vod\");\nconst vShow = {\n  beforeMount(el, { value }, { transition }) {\n    el[vShowOldKey] = el.style.display === \"none\" ? \"\" : el.style.display;\n    if (transition && value) {\n      transition.beforeEnter(el);\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  mounted(el, { value }, { transition }) {\n    if (transition && value) {\n      transition.enter(el);\n    }\n  },\n  updated(el, { value, oldValue }, { transition }) {\n    if (!value === !oldValue)\n      return;\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el);\n        setDisplay(el, true);\n        transition.enter(el);\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false);\n        });\n      }\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  beforeUnmount(el, { value }) {\n    setDisplay(el, value);\n  }\n};\nfunction setDisplay(el, value) {\n  el.style.display = value ? el[vShowOldKey] : \"none\";\n}\nfunction initVShowForSSR() {\n  vShow.getSSRProps = ({ value }) => {\n    if (!value) {\n      return { style: { display: \"none\" } };\n    }\n  };\n}\n\nfunction patchStyle(el, prev, next) {\n  const style = el.style;\n  const isCssString = shared.isString(next);\n  if (next && !isCssString) {\n    if (prev && !shared.isString(prev)) {\n      for (const key in prev) {\n        if (next[key] == null) {\n          setStyle(style, key, \"\");\n        }\n      }\n    }\n    for (const key in next) {\n      setStyle(style, key, next[key]);\n    }\n  } else {\n    const currentDisplay = style.display;\n    if (isCssString) {\n      if (prev !== next) {\n        style.cssText = next;\n      }\n    } else if (prev) {\n      el.removeAttribute(\"style\");\n    }\n    if (vShowOldKey in el) {\n      style.display = currentDisplay;\n    }\n  }\n}\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n  if (shared.isArray(val)) {\n    val.forEach((v) => setStyle(style, name, v));\n  } else {\n    if (val == null)\n      val = \"\";\n    if (name.startsWith(\"--\")) {\n      style.setProperty(name, val);\n    } else {\n      const prefixed = autoPrefix(style, name);\n      if (importantRE.test(val)) {\n        style.setProperty(\n          shared.hyphenate(prefixed),\n          val.replace(importantRE, \"\"),\n          \"important\"\n        );\n      } else {\n        style[prefixed] = val;\n      }\n    }\n  }\n}\nconst prefixes = [\"Webkit\", \"Moz\", \"ms\"];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n  const cached = prefixCache[rawName];\n  if (cached) {\n    return cached;\n  }\n  let name = runtimeCore.camelize(rawName);\n  if (name !== \"filter\" && name in style) {\n    return prefixCache[rawName] = name;\n  }\n  name = shared.capitalize(name);\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name;\n    if (prefixed in style) {\n      return prefixCache[rawName] = prefixed;\n    }\n  }\n  return rawName;\n}\n\nconst xlinkNS = \"http://www.w3.org/1999/xlink\";\nfunction patchAttr(el, key, value, isSVG, instance) {\n  if (isSVG && key.startsWith(\"xlink:\")) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    const isBoolean = shared.isSpecialBooleanAttr(key);\n    if (value == null || isBoolean && !shared.includeBooleanAttr(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, isBoolean ? \"\" : value);\n    }\n  }\n}\n\nfunction patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {\n  if (key === \"innerHTML\" || key === \"textContent\") {\n    if (prevChildren) {\n      unmountChildren(prevChildren, parentComponent, parentSuspense);\n    }\n    el[key] = value == null ? \"\" : value;\n    return;\n  }\n  const tag = el.tagName;\n  if (key === \"value\" && tag !== \"PROGRESS\" && // custom elements may use _value internally\n  !tag.includes(\"-\")) {\n    el._value = value;\n    const oldValue = tag === \"OPTION\" ? el.getAttribute(\"value\") : el.value;\n    const newValue = value == null ? \"\" : value;\n    if (oldValue !== newValue) {\n      el.value = newValue;\n    }\n    if (value == null) {\n      el.removeAttribute(key);\n    }\n    return;\n  }\n  let needRemove = false;\n  if (value === \"\" || value == null) {\n    const type = typeof el[key];\n    if (type === \"boolean\") {\n      value = shared.includeBooleanAttr(value);\n    } else if (value == null && type === \"string\") {\n      value = \"\";\n      needRemove = true;\n    } else if (type === \"number\") {\n      value = 0;\n      needRemove = true;\n    }\n  }\n  try {\n    el[key] = value;\n  } catch (e) {\n  }\n  needRemove && el.removeAttribute(key);\n}\n\nfunction addEventListener(el, event, handler, options) {\n  el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n  el.removeEventListener(event, handler, options);\n}\nconst veiKey = Symbol(\"_vei\");\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n  const invokers = el[veiKey] || (el[veiKey] = {});\n  const existingInvoker = invokers[rawName];\n  if (nextValue && existingInvoker) {\n    existingInvoker.value = nextValue;\n  } else {\n    const [name, options] = parseName(rawName);\n    if (nextValue) {\n      const invoker = invokers[rawName] = createInvoker(nextValue, instance);\n      addEventListener(el, name, invoker, options);\n    } else if (existingInvoker) {\n      removeEventListener(el, name, existingInvoker, options);\n      invokers[rawName] = void 0;\n    }\n  }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n  let options;\n  if (optionsModifierRE.test(name)) {\n    options = {};\n    let m;\n    while (m = name.match(optionsModifierRE)) {\n      name = name.slice(0, name.length - m[0].length);\n      options[m[0].toLowerCase()] = true;\n    }\n  }\n  const event = name[2] === \":\" ? name.slice(3) : shared.hyphenate(name.slice(2));\n  return [event, options];\n}\nlet cachedNow = 0;\nconst p = /* @__PURE__ */ Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());\nfunction createInvoker(initialValue, instance) {\n  const invoker = (e) => {\n    if (!e._vts) {\n      e._vts = Date.now();\n    } else if (e._vts <= invoker.attached) {\n      return;\n    }\n    runtimeCore.callWithAsyncErrorHandling(\n      patchStopImmediatePropagation(e, invoker.value),\n      instance,\n      5,\n      [e]\n    );\n  };\n  invoker.value = initialValue;\n  invoker.attached = getNow();\n  return invoker;\n}\nfunction patchStopImmediatePropagation(e, value) {\n  if (shared.isArray(value)) {\n    const originalStop = e.stopImmediatePropagation;\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e);\n      e._stopped = true;\n    };\n    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));\n  } else {\n    return value;\n  }\n}\n\nconst nativeOnRE = /^on[a-z]/;\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\n  if (key === \"class\") {\n    patchClass(el, nextValue, isSVG);\n  } else if (key === \"style\") {\n    patchStyle(el, prevValue, nextValue);\n  } else if (shared.isOn(key)) {\n    if (!shared.isModelListener(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent);\n    }\n  } else if (key[0] === \".\" ? (key = key.slice(1), true) : key[0] === \"^\" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {\n    patchDOMProp(\n      el,\n      key,\n      nextValue,\n      prevChildren,\n      parentComponent,\n      parentSuspense,\n      unmountChildren\n    );\n  } else {\n    if (key === \"true-value\") {\n      el._trueValue = nextValue;\n    } else if (key === \"false-value\") {\n      el._falseValue = nextValue;\n    }\n    patchAttr(el, key, nextValue, isSVG);\n  }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n  if (isSVG) {\n    if (key === \"innerHTML\" || key === \"textContent\") {\n      return true;\n    }\n    if (key in el && nativeOnRE.test(key) && shared.isFunction(value)) {\n      return true;\n    }\n    return false;\n  }\n  if (key === \"spellcheck\" || key === \"draggable\" || key === \"translate\") {\n    return false;\n  }\n  if (key === \"form\") {\n    return false;\n  }\n  if (key === \"list\" && el.tagName === \"INPUT\") {\n    return false;\n  }\n  if (key === \"type\" && el.tagName === \"TEXTAREA\") {\n    return false;\n  }\n  if (nativeOnRE.test(key) && shared.isString(value)) {\n    return false;\n  }\n  return key in el;\n}\n\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineCustomElement(options, hydrate2) {\n  const Comp = runtimeCore.defineComponent(options);\n  class VueCustomElement extends VueElement {\n    constructor(initialProps) {\n      super(Comp, initialProps, hydrate2);\n    }\n  }\n  VueCustomElement.def = Comp;\n  return VueCustomElement;\n}\n/*! #__NO_SIDE_EFFECTS__ */\nconst defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options) => {\n  return /* @__PURE__ */ defineCustomElement(options, hydrate);\n};\nconst BaseClass = typeof HTMLElement !== \"undefined\" ? HTMLElement : class {\n};\nclass VueElement extends BaseClass {\n  constructor(_def, _props = {}, hydrate2) {\n    super();\n    this._def = _def;\n    this._props = _props;\n    /**\n     * @internal\n     */\n    this._instance = null;\n    this._connected = false;\n    this._resolved = false;\n    this._numberProps = null;\n    this._ob = null;\n    if (this.shadowRoot && hydrate2) {\n      hydrate2(this._createVNode(), this.shadowRoot);\n    } else {\n      this.attachShadow({ mode: \"open\" });\n      if (!this._def.__asyncLoader) {\n        this._resolveProps(this._def);\n      }\n    }\n  }\n  connectedCallback() {\n    this._connected = true;\n    if (!this._instance) {\n      if (this._resolved) {\n        this._update();\n      } else {\n        this._resolveDef();\n      }\n    }\n  }\n  disconnectedCallback() {\n    this._connected = false;\n    if (this._ob) {\n      this._ob.disconnect();\n      this._ob = null;\n    }\n    runtimeCore.nextTick(() => {\n      if (!this._connected) {\n        render(null, this.shadowRoot);\n        this._instance = null;\n      }\n    });\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    this._resolved = true;\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name);\n    }\n    this._ob = new MutationObserver((mutations) => {\n      for (const m of mutations) {\n        this._setAttr(m.attributeName);\n      }\n    });\n    this._ob.observe(this, { attributes: true });\n    const resolve = (def, isAsync = false) => {\n      const { props, styles } = def;\n      let numberProps;\n      if (props && !shared.isArray(props)) {\n        for (const key in props) {\n          const opt = props[key];\n          if (opt === Number || opt && opt.type === Number) {\n            if (key in this._props) {\n              this._props[key] = shared.toNumber(this._props[key]);\n            }\n            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[shared.camelize(key)] = true;\n          }\n        }\n      }\n      this._numberProps = numberProps;\n      if (isAsync) {\n        this._resolveProps(def);\n      }\n      this._applyStyles(styles);\n      this._update();\n    };\n    const asyncDef = this._def.__asyncLoader;\n    if (asyncDef) {\n      asyncDef().then((def) => resolve(def, true));\n    } else {\n      resolve(this._def);\n    }\n  }\n  _resolveProps(def) {\n    const { props } = def;\n    const declaredPropKeys = shared.isArray(props) ? props : Object.keys(props || {});\n    for (const key of Object.keys(this)) {\n      if (key[0] !== \"_\" && declaredPropKeys.includes(key)) {\n        this._setProp(key, this[key], true, false);\n      }\n    }\n    for (const key of declaredPropKeys.map(shared.camelize)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return this._getProp(key);\n        },\n        set(val) {\n          this._setProp(key, val);\n        }\n      });\n    }\n  }\n  _setAttr(key) {\n    let value = this.getAttribute(key);\n    const camelKey = shared.camelize(key);\n    if (this._numberProps && this._numberProps[camelKey]) {\n      value = shared.toNumber(value);\n    }\n    this._setProp(camelKey, value, false);\n  }\n  /**\n   * @internal\n   */\n  _getProp(key) {\n    return this._props[key];\n  }\n  /**\n   * @internal\n   */\n  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\n    if (val !== this._props[key]) {\n      this._props[key] = val;\n      if (shouldUpdate && this._instance) {\n        this._update();\n      }\n      if (shouldReflect) {\n        if (val === true) {\n          this.setAttribute(shared.hyphenate(key), \"\");\n        } else if (typeof val === \"string\" || typeof val === \"number\") {\n          this.setAttribute(shared.hyphenate(key), val + \"\");\n        } else if (!val) {\n          this.removeAttribute(shared.hyphenate(key));\n        }\n      }\n    }\n  }\n  _update() {\n    render(this._createVNode(), this.shadowRoot);\n  }\n  _createVNode() {\n    const vnode = runtimeCore.createVNode(this._def, shared.extend({}, this._props));\n    if (!this._instance) {\n      vnode.ce = (instance) => {\n        this._instance = instance;\n        instance.isCE = true;\n        const dispatch = (event, args) => {\n          this.dispatchEvent(\n            new CustomEvent(event, {\n              detail: args\n            })\n          );\n        };\n        instance.emit = (event, ...args) => {\n          dispatch(event, args);\n          if (shared.hyphenate(event) !== event) {\n            dispatch(shared.hyphenate(event), args);\n          }\n        };\n        let parent = this;\n        while (parent = parent && (parent.parentNode || parent.host)) {\n          if (parent instanceof VueElement) {\n            instance.parent = parent._instance;\n            instance.provides = parent._instance.provides;\n            break;\n          }\n        }\n      };\n    }\n    return vnode;\n  }\n  _applyStyles(styles) {\n    if (styles) {\n      styles.forEach((css) => {\n        const s = document.createElement(\"style\");\n        s.textContent = css;\n        this.shadowRoot.appendChild(s);\n      });\n    }\n  }\n}\n\nfunction useCssModule(name = \"$style\") {\n  {\n    const instance = runtimeCore.getCurrentInstance();\n    if (!instance) {\n      return shared.EMPTY_OBJ;\n    }\n    const modules = instance.type.__cssModules;\n    if (!modules) {\n      return shared.EMPTY_OBJ;\n    }\n    const mod = modules[name];\n    if (!mod) {\n      return shared.EMPTY_OBJ;\n    }\n    return mod;\n  }\n}\n\nfunction useCssVars(getter) {\n  return;\n}\n\nconst positionMap = /* @__PURE__ */ new WeakMap();\nconst newPositionMap = /* @__PURE__ */ new WeakMap();\nconst moveCbKey = Symbol(\"_moveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nconst TransitionGroupImpl = {\n  name: \"TransitionGroup\",\n  props: /* @__PURE__ */ shared.extend({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(props, { slots }) {\n    const instance = runtimeCore.getCurrentInstance();\n    const state = runtimeCore.useTransitionState();\n    let prevChildren;\n    let children;\n    runtimeCore.onUpdated(() => {\n      if (!prevChildren.length) {\n        return;\n      }\n      const moveClass = props.moveClass || `${props.name || \"v\"}-move`;\n      if (!hasCSSTransform(\n        prevChildren[0].el,\n        instance.vnode.el,\n        moveClass\n      )) {\n        return;\n      }\n      prevChildren.forEach(callPendingCbs);\n      prevChildren.forEach(recordPosition);\n      const movedChildren = prevChildren.filter(applyTranslation);\n      forceReflow();\n      movedChildren.forEach((c) => {\n        const el = c.el;\n        const style = el.style;\n        addTransitionClass(el, moveClass);\n        style.transform = style.webkitTransform = style.transitionDuration = \"\";\n        const cb = el[moveCbKey] = (e) => {\n          if (e && e.target !== el) {\n            return;\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(\"transitionend\", cb);\n            el[moveCbKey] = null;\n            removeTransitionClass(el, moveClass);\n          }\n        };\n        el.addEventListener(\"transitionend\", cb);\n      });\n    });\n    return () => {\n      const rawProps = runtimeCore.toRaw(props);\n      const cssTransitionProps = resolveTransitionProps(rawProps);\n      let tag = rawProps.tag || runtimeCore.Fragment;\n      prevChildren = children;\n      children = slots.default ? runtimeCore.getTransitionRawChildren(slots.default()) : [];\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.key != null) {\n          runtimeCore.setTransitionHooks(\n            child,\n            runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance)\n          );\n        }\n      }\n      if (prevChildren) {\n        for (let i = 0; i < prevChildren.length; i++) {\n          const child = prevChildren[i];\n          runtimeCore.setTransitionHooks(\n            child,\n            runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance)\n          );\n          positionMap.set(child, child.el.getBoundingClientRect());\n        }\n      }\n      return runtimeCore.createVNode(tag, null, children);\n    };\n  }\n};\nconst removeMode = (props) => delete props.mode;\n/* @__PURE__ */ removeMode(TransitionGroupImpl.props);\nconst TransitionGroup = TransitionGroupImpl;\nfunction callPendingCbs(c) {\n  const el = c.el;\n  if (el[moveCbKey]) {\n    el[moveCbKey]();\n  }\n  if (el[enterCbKey]) {\n    el[enterCbKey]();\n  }\n}\nfunction recordPosition(c) {\n  newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n  const oldPos = positionMap.get(c);\n  const newPos = newPositionMap.get(c);\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    const s = c.el.style;\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = \"0s\";\n    return c;\n  }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n  const clone = el.cloneNode();\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.forEach((cls) => {\n      cls.split(/\\s+/).forEach((c) => c && clone.classList.remove(c));\n    });\n  }\n  moveClass.split(/\\s+/).forEach((c) => c && clone.classList.add(c));\n  clone.style.display = \"none\";\n  const container = root.nodeType === 1 ? root : root.parentNode;\n  container.appendChild(clone);\n  const { hasTransform } = getTransitionInfo(clone);\n  container.removeChild(clone);\n  return hasTransform;\n}\n\nconst getModelAssigner = (vnode) => {\n  const fn = vnode.props[\"onUpdate:modelValue\"] || false;\n  return shared.isArray(fn) ? (value) => shared.invokeArrayFns(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n  const target = e.target;\n  if (target.composing) {\n    target.composing = false;\n    target.dispatchEvent(new Event(\"input\"));\n  }\n}\nconst assignKey = Symbol(\"_assign\");\nconst vModelText = {\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    const castToNumber = number || vnode.props && vnode.props.type === \"number\";\n    addEventListener(el, lazy ? \"change\" : \"input\", (e) => {\n      if (e.target.composing)\n        return;\n      let domValue = el.value;\n      if (trim) {\n        domValue = domValue.trim();\n      }\n      if (castToNumber) {\n        domValue = shared.looseToNumber(domValue);\n      }\n      el[assignKey](domValue);\n    });\n    if (trim) {\n      addEventListener(el, \"change\", () => {\n        el.value = el.value.trim();\n      });\n    }\n    if (!lazy) {\n      addEventListener(el, \"compositionstart\", onCompositionStart);\n      addEventListener(el, \"compositionend\", onCompositionEnd);\n      addEventListener(el, \"change\", onCompositionEnd);\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, { value }) {\n    el.value = value == null ? \"\" : value;\n  },\n  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (el.composing)\n      return;\n    const elValue = number || el.type === \"number\" ? shared.looseToNumber(el.value) : el.value;\n    const newValue = value == null ? \"\" : value;\n    if (elValue === newValue) {\n      return;\n    }\n    if (document.activeElement === el && el.type !== \"range\") {\n      if (lazy) {\n        return;\n      }\n      if (trim && el.value.trim() === newValue) {\n        return;\n      }\n    }\n    el.value = newValue;\n  }\n};\nconst vModelCheckbox = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      const modelValue = el._modelValue;\n      const elementValue = getValue(el);\n      const checked = el.checked;\n      const assign = el[assignKey];\n      if (shared.isArray(modelValue)) {\n        const index = shared.looseIndexOf(modelValue, elementValue);\n        const found = index !== -1;\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue));\n        } else if (!checked && found) {\n          const filtered = [...modelValue];\n          filtered.splice(index, 1);\n          assign(filtered);\n        }\n      } else if (shared.isSet(modelValue)) {\n        const cloned = new Set(modelValue);\n        if (checked) {\n          cloned.add(elementValue);\n        } else {\n          cloned.delete(elementValue);\n        }\n        assign(cloned);\n      } else {\n        assign(getCheckboxValue(el, checked));\n      }\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    setChecked(el, binding, vnode);\n  }\n};\nfunction setChecked(el, { value, oldValue }, vnode) {\n  el._modelValue = value;\n  if (shared.isArray(value)) {\n    el.checked = shared.looseIndexOf(value, vnode.props.value) > -1;\n  } else if (shared.isSet(value)) {\n    el.checked = value.has(vnode.props.value);\n  } else if (value !== oldValue) {\n    el.checked = shared.looseEqual(value, getCheckboxValue(el, true));\n  }\n}\nconst vModelRadio = {\n  created(el, { value }, vnode) {\n    el.checked = shared.looseEqual(value, vnode.props.value);\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      el[assignKey](getValue(el));\n    });\n  },\n  beforeUpdate(el, { value, oldValue }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (value !== oldValue) {\n      el.checked = shared.looseEqual(value, vnode.props.value);\n    }\n  }\n};\nconst vModelSelect = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, { value, modifiers: { number } }, vnode) {\n    const isSetModel = shared.isSet(value);\n    addEventListener(el, \"change\", () => {\n      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(\n        (o) => number ? shared.looseToNumber(getValue(o)) : getValue(o)\n      );\n      el[assignKey](\n        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]\n      );\n    });\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, { value }) {\n    setSelected(el, value);\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  updated(el, { value }) {\n    setSelected(el, value);\n  }\n};\nfunction setSelected(el, value) {\n  const isMultiple = el.multiple;\n  if (isMultiple && !shared.isArray(value) && !shared.isSet(value)) {\n    return;\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i];\n    const optionValue = getValue(option);\n    if (isMultiple) {\n      if (shared.isArray(value)) {\n        option.selected = shared.looseIndexOf(value, optionValue) > -1;\n      } else {\n        option.selected = value.has(optionValue);\n      }\n    } else {\n      if (shared.looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i)\n          el.selectedIndex = i;\n        return;\n      }\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1;\n  }\n}\nfunction getValue(el) {\n  return \"_value\" in el ? el._value : el.value;\n}\nfunction getCheckboxValue(el, checked) {\n  const key = checked ? \"_trueValue\" : \"_falseValue\";\n  return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"created\");\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"mounted\");\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"beforeUpdate\");\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"updated\");\n  }\n};\nfunction resolveDynamicModel(tagName, type) {\n  switch (tagName) {\n    case \"SELECT\":\n      return vModelSelect;\n    case \"TEXTAREA\":\n      return vModelText;\n    default:\n      switch (type) {\n        case \"checkbox\":\n          return vModelCheckbox;\n        case \"radio\":\n          return vModelRadio;\n        default:\n          return vModelText;\n      }\n  }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n  const modelToUse = resolveDynamicModel(\n    el.tagName,\n    vnode.props && vnode.props.type\n  );\n  const fn = modelToUse[hook];\n  fn && fn(el, binding, vnode, prevVNode);\n}\nfunction initVModelForSSR() {\n  vModelText.getSSRProps = ({ value }) => ({ value });\n  vModelRadio.getSSRProps = ({ value }, vnode) => {\n    if (vnode.props && shared.looseEqual(vnode.props.value, value)) {\n      return { checked: true };\n    }\n  };\n  vModelCheckbox.getSSRProps = ({ value }, vnode) => {\n    if (shared.isArray(value)) {\n      if (vnode.props && shared.looseIndexOf(value, vnode.props.value) > -1) {\n        return { checked: true };\n      }\n    } else if (shared.isSet(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return { checked: true };\n      }\n    } else if (value) {\n      return { checked: true };\n    }\n  };\n  vModelDynamic.getSSRProps = (binding, vnode) => {\n    if (typeof vnode.type !== \"string\") {\n      return;\n    }\n    const modelToUse = resolveDynamicModel(\n      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n      vnode.type.toUpperCase(),\n      vnode.props && vnode.props.type\n    );\n    if (modelToUse.getSSRProps) {\n      return modelToUse.getSSRProps(binding, vnode);\n    }\n  };\n}\n\nconst systemModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\"];\nconst modifierGuards = {\n  stop: (e) => e.stopPropagation(),\n  prevent: (e) => e.preventDefault(),\n  self: (e) => e.target !== e.currentTarget,\n  ctrl: (e) => !e.ctrlKey,\n  shift: (e) => !e.shiftKey,\n  alt: (e) => !e.altKey,\n  meta: (e) => !e.metaKey,\n  left: (e) => \"button\" in e && e.button !== 0,\n  middle: (e) => \"button\" in e && e.button !== 1,\n  right: (e) => \"button\" in e && e.button !== 2,\n  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))\n};\nconst withModifiers = (fn, modifiers) => {\n  return (event, ...args) => {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]];\n      if (guard && guard(event, modifiers))\n        return;\n    }\n    return fn(event, ...args);\n  };\n};\nconst keyNames = {\n  esc: \"escape\",\n  space: \" \",\n  up: \"arrow-up\",\n  left: \"arrow-left\",\n  right: \"arrow-right\",\n  down: \"arrow-down\",\n  delete: \"backspace\"\n};\nconst withKeys = (fn, modifiers) => {\n  return (event) => {\n    if (!(\"key\" in event)) {\n      return;\n    }\n    const eventKey = shared.hyphenate(event.key);\n    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {\n      return fn(event);\n    }\n  };\n};\n\nconst rendererOptions = /* @__PURE__ */ shared.extend({ patchProp }, nodeOps);\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n  return renderer || (renderer = runtimeCore.createRenderer(rendererOptions));\n}\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration ? renderer : runtimeCore.createHydrationRenderer(rendererOptions);\n  enabledHydration = true;\n  return renderer;\n}\nconst render = (...args) => {\n  ensureRenderer().render(...args);\n};\nconst hydrate = (...args) => {\n  ensureHydrationRenderer().hydrate(...args);\n};\nconst createApp = (...args) => {\n  const app = ensureRenderer().createApp(...args);\n  const { mount } = app;\n  app.mount = (containerOrSelector) => {\n    const container = normalizeContainer(containerOrSelector);\n    if (!container)\n      return;\n    const component = app._component;\n    if (!shared.isFunction(component) && !component.render && !component.template) {\n      component.template = container.innerHTML;\n    }\n    container.innerHTML = \"\";\n    const proxy = mount(container, false, container instanceof SVGElement);\n    if (container instanceof Element) {\n      container.removeAttribute(\"v-cloak\");\n      container.setAttribute(\"data-v-app\", \"\");\n    }\n    return proxy;\n  };\n  return app;\n};\nconst createSSRApp = (...args) => {\n  const app = ensureHydrationRenderer().createApp(...args);\n  const { mount } = app;\n  app.mount = (containerOrSelector) => {\n    const container = normalizeContainer(containerOrSelector);\n    if (container) {\n      return mount(container, true, container instanceof SVGElement);\n    }\n  };\n  return app;\n};\nfunction normalizeContainer(container) {\n  if (shared.isString(container)) {\n    const res = document.querySelector(container);\n    return res;\n  }\n  return container;\n}\nlet ssrDirectiveInitialized = false;\nconst initDirectivesForSSR = () => {\n  if (!ssrDirectiveInitialized) {\n    ssrDirectiveInitialized = true;\n    initVModelForSSR();\n    initVShowForSSR();\n  }\n} ;\n\nexports.Transition = Transition;\nexports.TransitionGroup = TransitionGroup;\nexports.VueElement = VueElement;\nexports.createApp = createApp;\nexports.createSSRApp = createSSRApp;\nexports.defineCustomElement = defineCustomElement;\nexports.defineSSRCustomElement = defineSSRCustomElement;\nexports.hydrate = hydrate;\nexports.initDirectivesForSSR = initDirectivesForSSR;\nexports.render = render;\nexports.useCssModule = useCssModule;\nexports.useCssVars = useCssVars;\nexports.vModelCheckbox = vModelCheckbox;\nexports.vModelDynamic = vModelDynamic;\nexports.vModelRadio = vModelRadio;\nexports.vModelSelect = vModelSelect;\nexports.vModelText = vModelText;\nexports.vShow = vShow;\nexports.withKeys = withKeys;\nexports.withModifiers = withModifiers;\nObject.keys(runtimeCore).forEach(function (k) {\n  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeCore[k];\n});\n", "'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/runtime-dom.cjs.prod.js')\n} else {\n  module.exports = require('./dist/runtime-dom.cjs.js')\n}\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar compilerDom = require('@vue/compiler-dom');\nvar runtimeDom = require('@vue/runtime-dom');\nvar shared = require('@vue/shared');\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    for (var k in e) {\n      n[k] = e[k];\n    }\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar runtimeDom__namespace = /*#__PURE__*/_interopNamespaceDefault(runtimeDom);\n\nconst compileCache = /* @__PURE__ */ Object.create(null);\nfunction compileToFunction(template, options) {\n  if (!shared.isString(template)) {\n    if (template.nodeType) {\n      template = template.innerHTML;\n    } else {\n      return shared.NOOP;\n    }\n  }\n  const key = template;\n  const cached = compileCache[key];\n  if (cached) {\n    return cached;\n  }\n  if (template[0] === \"#\") {\n    const el = document.querySelector(template);\n    template = el ? el.innerHTML : ``;\n  }\n  const opts = shared.extend(\n    {\n      hoistStatic: true,\n      onError: void 0,\n      onWarn: shared.NOOP\n    },\n    options\n  );\n  if (!opts.isCustomElement && typeof customElements !== \"undefined\") {\n    opts.isCustomElement = (tag) => !!customElements.get(tag);\n  }\n  const { code } = compilerDom.compile(template, opts);\n  const render = new Function(\"Vue\", code)(runtimeDom__namespace);\n  render._rc = true;\n  return compileCache[key] = render;\n}\nruntimeDom.registerRuntimeCompiler(compileToFunction);\n\nexports.compile = compileToFunction;\nObject.keys(runtimeDom).forEach(function (k) {\n  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeDom[k];\n});\n", "'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/vue.cjs.prod.js')\n} else {\n  module.exports = require('./dist/vue.cjs.js')\n}\n", "import { createApp, watch } from \"vue\";\nimport NcBrowserComponent from './NcBrowser.vue';\n\nclass Browser {\n  constructor(options = {}) {\n    const { wrapper, ...componentProps } = options;\n    this.initializeWrapper(wrapper);\n    this.initializeVueComponent(componentProps);\n  }\n  //\n  initializeWrapper(wrapper) {\n    if (!wrapper) {\n      this.make_dialog();\n    } else {\n      this.wrapper = wrapper.get ? wrapper.get(0) : wrapper;\n    }\n  }\n  //\n  initializeVueComponent(props) {\n    const app = createApp(NcBrowserComponent, {\n      show_upload_button: !this.dialog,\n      ...props\n    });\n    this.browser = app.mount(this.wrapper);\n\n    this.setupWatchers();\n  }\n  //\n  setupWatchers() {\n    watch(\n      () => this.browser.close_dialog,\n      (close_dialog) => {\n        if (close_dialog) this.dialog?.hide();\n      }\n    );\n  }\n  //\n  select_folder() {\n    this.dialog?.get_primary_btn().prop('disabled', true);\n    return this.browser.select_folder();\n  }\n  //\n  make_dialog() {\n    this.dialog = new frappe.ui.Dialog({\n      title: __('Select NextCloud Folder'),\n      size: 'large',\n      primary_action_label: __('Select'),\n      primary_action: () => this.handlePrimaryAction()\n    });\n\n    this.wrapper = this.dialog.body;\n    this.dialog.show();\n    this.setupDialogCleanup();\n  }\n  //\n  handlePrimaryAction() {\n    const nc_folder = this.select_folder();\n    const [doctype, docname] = this.getDocumentInfo();\n    if (nc_folder.is_folder) {\n      frappe.db.set_value(\"PibiDAV Addon\", `pbc_${docname}`, {\n        \"nc_folder\": nc_folder.path,\n        \"nc_enable\": 1\n      });\n    } else {\n      frappe.msgprint(__('You have selected a file and not a folder'), nc_folder.file_name);\n    }\n    this.dialog.hide();\n    this.postSelectionAction(doctype);\n  }\n  //\n  getDocumentInfo() {\n    const dtdn = this.wrapper.ownerDocument.body.getAttribute('data-route').replace('Form/', '');\n    const pos = dtdn.lastIndexOf('/');\n    const docname = dtdn.substr(pos + 1);\n    const doctype = dtdn.replace('/' + docname, '');\n    return [doctype, docname];\n  }\n  //\n  postSelectionAction(doctype) {\n    if (doctype === 'Folder Set') {\n      window.location.reload();\n    } else {\n      document.querySelector('.add-attachment-btn').click();\n    }\n  }\n  //\n  setupDialogCleanup() {\n    this.dialog.$wrapper.on('hidden.bs.modal', function() {\n      $(this).data('bs.modal', null);\n      $(this).remove();\n    });\n  }\n}\n//\nfrappe.provide(\"frappe.ui\");\nfrappe.ui.pibiDocs = Browser;\nexport default Browser;", "<template>\n  <div class=\"tree-node\" :class=\"{ opened: node.open }\">\n    <span\n      class=\"tree-link\"\n      @click=\"$emit('node-click', node)\"\n      :class=\"{ active: node.value === selected_node.value }\"\n      :disabled=\"node.fetching\"\n    >\n      <div v-html=\"icon\"></div>\n      <a class=\"tree-label\">{{ node.label }}</a>\n    </span>\n    <ul class=\"tree-children\" v-show=\"node.open\">\n      <TreeNode\n        v-for=\"n in node.children\"\n        :key=\"n.value\"\n        :node=\"n\"\n        :selected_node=\"selected_node\"\n        @node-click=\"n => $emit('node-click', n)\"\n        @load-more=\"n => $emit('load-more', n)\"\n      />\n      <button\n        class=\"btn btn-xs btn-load-more\"\n        v-if=\"node.has_more_children\"\n        @click=\"$emit('load-more', node)\"\n        :disabled=\"node.children_loading\"\n      >\n        {{ node.children_loading ? __(\"Loading...\") : __(\"Load more\") }}\n      </button>\n    </ul>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"TreeNode\",\n  props: [\"node\", \"selected_node\"],\n  components: {\n    TreeNode: () => frappe.ui.components.TreeNode\n  },\n  computed: {\n    icon() {\n      let icons = {\n        open: frappe.utils.icon(\"folder-open\", \"md\"),\n        closed: frappe.utils.icon(\"folder-normal\", \"md\"),\n        leaf: frappe.utils.icon(\"file\", \"md\")\n      };\n      if (this.node.is_leaf) return icons.leaf;\n      if (this.node.open) return icons.open;\n      return icons.closed;\n    }\n  }\n};\n</script>\n<style scoped>\n  .btn-load-more {\n    margin-left: 1.6rem;\n    margin-top: 0.5rem;\n  }\n</style>\n", "import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, normalizeClass as _normalizeClass, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, resolveComponent as _resolveComponent, createBlock as _createBlock, createCommentVNode as _createCommentVNode, vShow as _vShow, withDirectives as _withDirectives, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-64e3173d\"),n=n(),_popScopeId(),n)\nconst _hoisted_1 = [\"disabled\"]\nconst _hoisted_2 = [\"innerHTML\"]\nconst _hoisted_3 = { class: \"tree-label\" }\nconst _hoisted_4 = { class: \"tree-children\" }\nconst _hoisted_5 = [\"disabled\"]\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_TreeNode = _resolveComponent(\"TreeNode\", true)\n\n  return (_openBlock(), _createElementBlock(\"div\", {\n    class: _normalizeClass([\"tree-node\", { opened: $props.node.open }])\n  }, [\n    _createElementVNode(\"span\", {\n      class: _normalizeClass([\"tree-link\", { active: $props.node.value === $props.selected_node.value }]),\n      onClick: _cache[0] || (_cache[0] = $event => (_ctx.$emit('node-click', $props.node))),\n      disabled: $props.node.fetching\n    }, [\n      _createElementVNode(\"div\", { innerHTML: $options.icon }, null, 8 /* PROPS */, _hoisted_2),\n      _createElementVNode(\"a\", _hoisted_3, _toDisplayString($props.node.label), 1 /* TEXT */)\n    ], 10 /* CLASS, PROPS */, _hoisted_1),\n    _withDirectives(_createElementVNode(\"ul\", _hoisted_4, [\n      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList($props.node.children, (n) => {\n        return (_openBlock(), _createBlock(_component_TreeNode, {\n          key: n.value,\n          node: n,\n          selected_node: $props.selected_node,\n          onNodeClick: n => _ctx.$emit('node-click', n),\n          onLoadMore: n => _ctx.$emit('load-more', n)\n        }, null, 8 /* PROPS */, [\"node\", \"selected_node\", \"onNodeClick\", \"onLoadMore\"]))\n      }), 128 /* KEYED_FRAGMENT */)),\n      ($props.node.has_more_children)\n        ? (_openBlock(), _createElementBlock(\"button\", {\n            key: 0,\n            class: \"btn btn-xs btn-load-more\",\n            onClick: _cache[1] || (_cache[1] = $event => (_ctx.$emit('load-more', $props.node))),\n            disabled: $props.node.children_loading\n          }, _toDisplayString($props.node.children_loading ? _ctx.__(\"Loading...\") : _ctx.__(\"Load more\")), 9 /* TEXT, PROPS */, _hoisted_5))\n        : _createCommentVNode(\"v-if\", true)\n    ], 512 /* NEED_PATCH */), [\n      [_vShow, $props.node.open]\n    ])\n  ], 2 /* CLASS */))\n}", "import script from \"/home/erpnext/erpnext-dev/apps/pibidav/pibidav/public/js/dist/nc_browser/TreeNode.vue?type=script\";import \"/home/erpnext/erpnext-dev/apps/pibidav/pibidav/public/js/dist/nc_browser/TreeNode.vue?type=style&index=0\";import { render } from \"/home/erpnext/erpnext-dev/apps/pibidav/pibidav/public/js/dist/nc_browser/TreeNode.vue?type=template\"; script.render = render;script.__file = \"../pibidav/pibidav/public/js/dist/nc_browser/TreeNode.vue\";script.__scopeId = \"data-v-64e3173d\";export default script;", "<template>\n  <div class=\"file-browser\">\n    <div class=\"nc-browser-list\">\n      <TreeNode\n        class=\"tree with-skeleton\"\n        :node=\"node\"\n        :selected_node=\"selected_node\"\n        @node-click=\"n => toggle_node(n)\"\n        @load-more=\"n => load_more(n)\"\n      />\n    </div>\n  </div>\n</template>\n<script>\nimport TreeNode from \"./TreeNode.vue\";\n\nexport default {\n  name: \"NcBrowser\",  \n  components: {\n    TreeNode\n  },\n  data() {\n    return {\n      node: {\n        label: __(\"/\"),\n        value: \"/\",\n        children: [],\n        children_start: 0,\n        children_loading: false,\n        is_leaf: false,\n        fetching: false,\n        fetched: false,\n        open: false\n      },\n      selected_node: {},\n      page_length: 500\n    };\n  },\n  mounted() {\n    this.toggle_node(this.node);\n  },\n  methods: {\n    toggle_node(node) {\n      if (!node.is_leaf && !node.fetched) {\n        node.fetching = true;\n        node.children_start = 0;\n        node.children_loading = false;\n        this.get_files_in_folder(node.value, 0).then(\n          ({ files, has_more }) => {\n            node.open = true;\n            node.children = files;\n            node.fetched = true;\n            node.fetching = false;\n            node.children_start += this.page_length;\n            node.has_more_children = has_more;\n            this.select_node(node);\n          }\n        );\n      } else {\n        node.open = !node.open;\n        this.select_node(node);\n      }\n    },\n    load_more(node) {\n      if (node.has_more_children) {\n        let start = node.children_start;\n        node.children_loading = true;\n        this.get_files_in_folder(node.value, start).then(\n          ({ files, has_more }) => {\n            node.children = node.children.concat(files);\n            node.children_start += this.page_length;\n            node.has_more_children = has_more;\n            node.children_loading = false;\n          }\n        );\n      }\n    },\n    select_node(node) {\n      //if (node.is_leaf) {\n        this.selected_node = node;\n      //}\n    },\n    get_files_in_folder(folder, start) {\n      return frappe\n      .call(\"pibidav.pibidav.custom.get_nc_files_in_folder\", {\n        folder,\n        start,\n        page_length: this.page_length\n      })\n      .then(r => {\n        let { files = [], has_more = false } = r.message || {};\n        files = files.map(file => this.make_file_node(file));\n        return { files, has_more };\n      });\n    },\n    make_file_node(file) {\n      let filename = file.file_name || file.name;\n      let label = frappe.utils.file_name_ellipsis(filename, 40);\n      return {\n        label: label,\n        filename: filename,\n        file_url: file.file_url,\n        value: file.name,\n        is_leaf: !file.is_folder,\n        fetched: !file.is_folder, // fetched if node is leaf\n        children: [],\n        children_loading: false,\n        children_start: 0,\n        open: false,\n        fetching: false\n      };\n    },\n    select_folder() {\n      let selected_file = this.selected_node;\n      return this.upload_to_folder({\n        is_folder: !selected_file.is_leaf,\n\tfile_name: selected_file.filename,\n        fileid: selected_file.file_url,\n        path: selected_file.value\n      });\n    },\n    upload_to_folder(file) {\n      return file;\n    }\n  }\n};\n</script>\n\n<style>\n  .nc-browser-list {\n    height: 420px;\n    overflow: hidden;\n    margin-top: 6px;\n  }\n  .tree {\n    overflow: auto;\n    height: 100%;\n    padding-left: 0;\n    padding-right: 0;\n    padding-bottom: 4rem;\n  }\n</style>\n", "import { resolveComponent as _resolveComponent, createVNode as _createVNode, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = { class: \"file-browser\" }\nconst _hoisted_2 = { class: \"nc-browser-list\" }\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_TreeNode = _resolveComponent(\"TreeNode\")\n\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n    _createElementVNode(\"div\", _hoisted_2, [\n      _createVNode(_component_TreeNode, {\n        class: \"tree with-skeleton\",\n        node: $data.node,\n        selected_node: $data.selected_node,\n        onNodeClick: _cache[0] || (_cache[0] = n => $options.toggle_node(n)),\n        onLoadMore: _cache[1] || (_cache[1] = n => $options.load_more(n))\n      }, null, 8 /* PROPS */, [\"node\", \"selected_node\"])\n    ])\n  ]))\n}", "import script from \"/home/erpnext/erpnext-dev/apps/pibidav/pibidav/public/js/dist/nc_browser/NcBrowser.vue?type=script\";import \"/home/erpnext/erpnext-dev/apps/pibidav/pibidav/public/js/dist/nc_browser/NcBrowser.vue?type=style&index=0\";import { render } from \"/home/erpnext/erpnext-dev/apps/pibidav/pibidav/public/js/dist/nc_browser/NcBrowser.vue?type=template\"; script.render = render;script.__file = \"../pibidav/pibidav/public/js/dist/nc_browser/NcBrowser.vue\";export default script;"],
  "mappings": "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E,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,GAAG,GAAG,KAAK,GAAG,EAAE,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,KAAK,EAAE,KAAK,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,KAAK,GAAG,EAAE,EAAE,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,EAAE,IAAI,EAAE,KAAK,GAAG,KAAK,GAAG,IAAI,KAAK,IAAI,KAAK,KAAK,EAAE,IAAI,EAEj+CC,GAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE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ACR,OAAQ,YACR,OAAQ,YACR,OAAQ,OACR,OAAQ,OACR,OAAQ,OACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,OACR,OAAQ,OACR,KAAM,OACN,KAAM,OACN,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,IACR,OAAQ,SACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,KAAM,OACN,KAAM,OACN,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,KAAM,OACN,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,KAAM,OACN,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,eACR,OAAQ,SACR,OAAQ,eACR,OAAQ,eACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,eACR,OAAQ,SACR,OAAQ,eACR,OAAQ,eACR,OAAQ,SACR,OAAQ,SACR,OAAQ,OACR,OAAQ,SACR,OAAQ,SACR,OAAQ,IACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,KAAM,OACN,KAAM,OACN,OAAQ,SACR,KAAM,OACN,KAAM,OACN,OAAQ,SACR,KAAM,OACN,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,KAAM,IACN,KAAM,IACN,OAAQ,SACR,OAAQ,SACR,OAAQ,OACR,OAAQ,OACR,OAAQ,SACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,KAAM,OACN,OAAQ,YACR,OAAQ,YACR,OAAQ,OACR,OAAQ,SACR,OAAQ,SACR,OAAQ,IACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,KAAM,OACN,KAAM,OACN,KAAM,OACN,OAAQ,IACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,OACR,KAAM,OACN,KAAM,OACN,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,YACR,OAAQ,YACR,OAAQ,YACR,OAAQ,YACR,OAAQ,YACR,OAAQ,SACR,OAAQ,SACR,OAAQ,OACR,OAAQ,YACR,OAAQ,YACR,KAAM,OACN,OAAQ,SACR,OAAQ,SACR,OAAQ,SACR,OAAQ,YACR,OAAQ,SACR,MAAO,OACP,MAAO,OACP,MAAO,OACP,MAAO,OACP,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,IACT,MAAO,OACP,MAAO,OACP,QAAS,YACT,QAAS,YACT,QAAS,OACT,QAAS,OACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,SACT,QAAS,KACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,QAAS,OACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,OACT,QAAS,OACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,OACT,QAAS,OACT,QAAS,SACT,QAAS,IACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,OACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,SACT,QAAS,YACT,MAAO,OACP,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,SACT,QAAS,OACT,QAAS,OACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,IACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,IACT,QAAS,SACT,QAAS,YACT,QAAS,SACT,QAAS,IACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,OACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,YACT,QAAS,eACT,QAAS,eACT,QAAS,OACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,SACT,QAAS,eACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,eACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,SACT,QAAS,eACT,QAAS,eACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,eACT,QAAS,eACT,QAAS,UACT,QAAS,eACT,QAAS,UACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,OACT,QAAS,OACT,QAAS,SACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,OACT,QAAS,OACT,QAAS,OACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,IACT,QAAS,SACT,QAAS,YACT,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,IACT,QAAS,IACT,QAAS,eACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,IACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,IACT,QAAS,SACT,QAAS,YACT,QAAS,IACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,OACT,QAAS,IACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,OACT,QAAS,OACT,QAAS,OACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,QAAS,SACT,QAAS,SACT,MAAO,OACP,MAAO,OACP,MAAO,OACP,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,MAAO,OACP,MAAO,OACP,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,OACT,QAAS,OACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,IACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,OACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,SACT,QAAS,YACT,QAAS,YACT,QAAS,YACT,QAAS,SACT,OAAQ,OACR,OAAQ,OACR,SAAU,OACV,SAAU,OACV,SAAU,OACV,SAAU,OACV,SAAU,OACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,OACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,IACV,SAAU,IACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,OACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,KACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,IACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,OACV,SAAU,OACV,SAAU,OACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,SACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,eACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,OACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,IACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,OACV,SAAU,OACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,eACV,SAAU,eACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,SAAU,SACV,OAAQ,OACR,OAAQ,OACR,SAAU,SACV,SAAU,SACV,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,IACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,eACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,eACX,UAAW,eACX,UAAW,SACX,UAAW,eACX,UAAW,eACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,IACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,IACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,eACX,UAAW,eACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,IACX,UAAW,eACX,UAAW,eACX,UAAW,eACX,UAAW,eACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,OACX,UAAW,OACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,UAAW,SACX,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,eACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,OACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY;AAAA,EACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,eACZ,WAAY,SACZ,WAAY,SACZ,WAAY,eACZ,WAAY,eACZ,WAAY,eACZ,WAAY,SACZ,WAAY,eACZ,WAAY,eACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,WAAY,SACZ,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,OACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,eACb,YAAa,SACb,YAAa,eACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,IACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,YAAa,SACb,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,OACd,aAAc,OACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,OACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,eACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,eACd,aAAc,SACd,aAAc,SACd,aAAc,eACd,aAAc,eACd,aAAc,SACd,aAAc,SACd,aAAc,eACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,OACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,aAAc,SACd,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,eACf,cAAe,eACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,eACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,eAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,eAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,eAAgB,SAChB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,eACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,SACjB,gBAAiB,eACjB,gBAAiB,eACjB,gBAAiB,IACjB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,eAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,SAClB,iBAAkB,eAClB,iBAAkB,eAClB,iBAAkB,SAClB,iBAAkB,SAClB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,kBAAmB,SACnB,mBAAoB,SACpB,mBAAoB,SACpB,mBAAoB,SACpB,mBAAoB,SACpB,mBAAoB,SACpB,mBAAoB,SACpB,mBAAo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",
  "names": ["require_shared_cjs_prod", "__commonJSMin", "exports", "makeMap", "str", "expectsLowerCase", "map", "list", "val", "EMPTY_OBJ", "EMPTY_ARR", "NOOP", "NO", "onRE", "isOn", "key", "isModelListener", "extend", "remove", "arr", "el", "i", "hasOwnProperty", "hasOwn", "isArray", "isMap", "toTypeString", "isSet", "isDate", "isRegExp", "isFunction", "isString", "isSymbol", "isObject", "isPromise", "objectToString", "value", "toRawType", "isPlainObject", "isIntegerKey", "isReservedProp", "isBuiltInDirective", "cacheStringFunction", "fn", "cache", "camelizeRE", "camelize", "_", "c", "hyphenateRE", "hyphenate", "capitalize", "toHandlerKey", "hasChanged", "oldValue", "invokeArrayFns", "fns", "arg", "def", "obj", "looseToNumber", "n", "toNumber", "_globalThis", "getGlobalThis", "identRE", "genPropsAccessExp", "name", "PatchFlagNames", "slotFlagsText", "GLOBALS_ALLOWED", "isGloballyAllowed", "isGloballyWhitelisted", "range", "generateCodeFrame", "source", "start", "end", "lines", "newlineSequences", "idx", "count", "res", "j", "line", "lineLength", "newLineSeqLength", "pad", "length", "normalizeStyle", "item", "normalized", "parseStringStyle", "listDelimiterRE", "propertyDelimiterRE", "styleCommentRE", "cssText", "ret", "tmp", "stringifyStyle", "styles", "normalizedKey", "normalizeClass", "normalizeProps", "props", "klass", "style", "HTML_TAGS", "SVG_TAGS", "VOID_TAGS", "isHTMLTag", "isSVGTag", "isVoidTag", "specialBooleanAttrs", "isSpecialBooleanAttr", "isBooleanAttr", "includeBooleanAttr", "unsafeAttrCharRE", "attrValidationCache", "isSSRSafeAttrName", "isUnsafe", "propsToAttrMap", "isKnownHtmlAttr", "isKnownSvgAttr", "escapeRE", "escapeHtml", "string", "match", "html", "escaped", "index", "lastIndex", "commentStripRE", "escapeHtmlComment", "src", "looseCompareArrays", "a", "b", "equal", "looseEqual", "aValidType", "bValidType", "aKeysCount", "bKeysCount", "aHasKey", "bHasKey", "looseIndexOf", "toDisplayString", "replacer", "_key", "entries", "val2", "require_shared", "__commonJSMin", "exports", "module", "Position", "constructor", "line", "col", "index", "column", "SourceLocation", "start", "end", "filename", "identifierName", "createPositionWithColumnOffset", "position", "columnOffset", "code", "ModuleErrors", "ImportMetaOutsideModule", "message", "ImportOutsideModule", "NodeDescriptions", "ArrayPattern", "AssignmentExpression", "AssignmentPattern", "ArrowFunctionExpression", "ConditionalExpression", "CatchClause", "ForOfStatement", "ForInStatement", "ForStatement", "FormalParameters", "Identifier", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier", "ObjectPattern", "ParenthesizedExpression", "RestElement", "UpdateExpression", "true", "false", "VariableDeclarator", "YieldExpression", "toNodeDescription", "type", "prefix", "String", "StandardErrors", "AccessorIsGenerator", "kind", "ArgumentsInClass", "AsyncFunctionInSingleStatementContext", "AwaitBindingIdentifier", "AwaitBindingIdentifierInStaticBlock", "AwaitExpressionFormalParameter", "AwaitUsingNotInAsyncContext", "AwaitNotInAsyncContext", "AwaitNotInAsyncFunction", "BadGetterArity", "BadSetterArity", "BadSetterRestParameter", "ConstructorClassField", "ConstructorClassPrivateField", "ConstructorIsAccessor", "ConstructorIsAsync", "ConstructorIsGenerator", "DeclarationMissingInitializer", "DecoratorArgumentsOutsideParentheses", "DecoratorBeforeExport", "DecoratorsBeforeAfterExport", "DecoratorConstructor", "DecoratorExportClass", "DecoratorSemicolon", "DecoratorStaticBlock", "DeferImportRequiresNamespace", "DeletePrivateField", "DestructureNamedImport", "DuplicateConstructor", "DuplicateDefaultExport", "DuplicateExport", "exportName", "DuplicateProto", "DuplicateRegExpFlags", "DynamicImportPhaseRequiresImportExpressions", "phase", "ElementAfterRest", "EscapedCharNotAnIdentifier", "ExportBindingIsString", "localName", "ExportDefaultFromAsIdentifier", "ForInOfLoopInitializer", "ForInUsing", "ForOfAsync", "ForOfLet", "GeneratorInSingleStatementContext", "IllegalBreakContinue", "IllegalLanguageModeDirective", "IllegalReturn", "ImportAttributesUseAssert", "ImportBindingIsString", "importName", "ImportCallArgumentTrailingComma", "ImportCallArity", "maxArgumentCount", "ImportCallNotNewExpression", "ImportCallSpreadArgument", "ImportJSONBindingNotDefault", "ImportReflectionHasAssertion", "ImportReflectionNotBinding", "IncompatibleRegExpUVFlags", "InvalidBigIntLiteral", "InvalidCodePoint", "InvalidCoverInitializedName", "InvalidDecimal", "InvalidDigit", "radix", "InvalidEscapeSequence", "InvalidEscapeSequenceTemplate", "InvalidEscapedReservedWord", "reservedWord", "InvalidIdentifier", "InvalidLhs", "ancestor", "InvalidLhsBinding", "InvalidLhsOptionalChaining", "InvalidNumber", "InvalidOrMissingExponent", "InvalidOrUnexpectedToken", "unexpected", "InvalidParenthesizedAssignment", "InvalidPrivateFieldResolution", "InvalidPropertyBindingPattern", "InvalidRecordProperty", "InvalidRestAssignmentPattern", "LabelRedeclaration", "labelName", "LetInLexicalBinding", "LineTerminatorBeforeArrow", "MalformedRegExpFlags", "MissingClassName", "MissingEqInAssignment", "MissingSemicolon", "MissingPlugin", "missingPlugin", "map", "name", "JSON", "stringify", "join", "MissingOneOfPlugins", "MissingUnicodeEscape", "MixingCoalesceWithLogical", "ModuleAttributeDifferentFromType", "ModuleAttributeInvalidValue", "ModuleAttributesWithDuplicateKeys", "key", "ModuleExportNameHasLoneSurrogate", "surrogateCharCode", "toString", "ModuleExportUndefined", "MultipleDefaultsInSwitch", "NewlineAfterThrow", "NoCatchOrFinally", "NumberIdentifier", "NumericSeparatorInEscapeSequence", "ObsoleteAwaitStar", "OptionalChainingNoNew", "OptionalChainingNoTemplate", "OverrideOnConstructor", "ParamDupe", "PatternHasAccessor", "PatternHasMethod", "PrivateInExpectedIn", "PrivateNameRedeclaration", "RecordExpressionBarIncorrectEndSyntaxType", "RecordExpressionBarIncorrectStartSyntaxType", "RecordExpressionHashIncorrectStartSyntaxType", "RecordNoProto", "RestTrailingComma", "SloppyFunction", "SloppyFunctionAnnexB", "SourcePhaseImportRequiresDefault", "StaticPrototype", "SuperNotAllowed", "SuperPrivateField", "TrailingDecorator", "TupleExpressionBarIncorrectEndSyntaxType", "TupleExpressionBarIncorrectStartSyntaxType", "TupleExpressionHashIncorrectStartSyntaxType", "UnexpectedArgumentPlaceholder", "UnexpectedAwaitAfterPipelineBody", "UnexpectedDigitAfterHash", "UnexpectedImportExport", "UnexpectedKeyword", "keyword", "UnexpectedLeadingDecorator", "UnexpectedLexicalDeclaration", "UnexpectedNewTarget", "UnexpectedNumericSeparator", "UnexpectedPrivateField", "UnexpectedReservedWord", "UnexpectedSuper", "UnexpectedToken", "expected", "UnexpectedTokenUnaryExponentiation", "UnexpectedUsingDeclaration", "UnsupportedBind", "UnsupportedDecoratorExport", "UnsupportedDefaultExport", "UnsupportedImport", "UnsupportedMetaProperty", "target", "onlyValidPropertyName", "UnsupportedParameterDecorator", "UnsupportedPropertyDecorator", "UnsupportedSuper", "UnterminatedComment", "UnterminatedRegExp", "UnterminatedString", "UnterminatedTemplate", "UsingDeclarationHasBindingPattern", "VarRedeclaration", "YieldBindingIdentifier", "YieldInParameter", "ZeroDigitNumericSeparator", "StrictModeErrors", "StrictDelete", "StrictEvalArguments", "referenceName", "StrictEvalArgumentsBinding", "bindingName", "StrictFunction", "StrictNumericEscape", "StrictOctalLiteral", "StrictWith", "UnparenthesizedPipeBodyDescriptions", "Set", "PipelineOperatorErrors", "PipeBodyIsTighter", "PipeTopicRequiresHackPipes", "PipeTopicUnbound", "PipeTopicUnconfiguredToken", "token", "PipeTopicUnused", "PipeUnparenthesizedBody", "PipelineBodyNoArrow", "PipelineBodySequenceExpression", "PipelineHeadSequenceExpression", "PipelineTopicUnused", "PrimaryTopicNotAllowed", "PrimaryTopicRequiresSmartPipeline", "defineHidden", "obj", "value", "Object", "defineProperty", "enumerable", "configurable", "toParseErrorConstructor", "_ref", "toMessage", "properties", "_objectWithoutPropertiesLoose", "_excluded", "loc", "details", "error", "SyntaxError", "assign", "pos", "overrides", "_overrides$loc", "get", "set", "writable", "ParseErrorEnum", "argument", "syntaxPlugin", "Array", "isArray", "parseErrorTemplates", "ParseErrorConstructors", "reasonCode", "keys", "template", "_ref2", "rest", "_excluded2", "Errors", "toUnenumerable", "object", "toESTreeLocation", "node", "estree", "superClass", "parse", "file", "options", "tokens", "parseRegExpLiteral", "pattern", "flags", "regex", "RegExp", "e", "estreeParseLiteral", "parseBigIntLiteral", "bigInt", "BigInt", "_unused", "bigint", "parseDecimalLiteral", "decimal", "parseLiteral", "parseStringLiteral", "parseNumericLiteral", "parseNullLiteral", "parseBooleanLiteral", "directiveToStmt", "directive", "expression", "raw", "extra", "expressionValue", "stmt", "rawValue", "initFunction", "isAsync", "checkDeclaration", "isObjectProperty", "getObjectOrClassMethodParams", "method", "params", "isValidDirective", "_stmt$expression$extr", "parenthesized", "parseBlockBody", "allowDirectives", "topLevel", "afterBlockParse", "directiveStatements", "directives", "d", "body", "concat", "pushClassMethod", "classBody", "isGenerator", "isConstructor", "allowsDirectSuper", "parseMethod", "typeParameters", "push", "parsePrivateName", "getPluginOption", "convertPrivateNameToPrivateIdentifier", "getPrivateNameSV", "id", "isPrivateName", "parseFunctionBody", "allowExpression", "isMethod", "allowDirectSuper", "inClassScope", "funcNode", "startNode", "computed", "finishNode", "parseClassProperty", "args", "propertyNode", "parseClassPrivateProperty", "parseObjectMethod", "prop", "isPattern", "isAccessor", "shorthand", "parseObjectProperty", "startLoc", "refExpressionErrors", "isValidLVal", "isUnparenthesizedInAssign", "binding", "isAssignable", "isBinding", "toAssignable", "isLHS", "classScope", "usePrivateName", "toAssignableObjectExpressionProp", "isLast", "raise", "at", "finishCallExpression", "unfinished", "optional", "callee", "source", "arguments", "hasPlugin", "_node$arguments$", "_node$arguments$2", "attributes", "toReferencedArguments", "parseExport", "decorators", "exportStartLoc", "state", "lastTokStartLoc", "exported", "specifiers", "length", "_declaration$decorato", "declaration", "resetStartLocation", "parseSubscript", "base", "noCalls", "optionalChainMember", "substring", "stop", "chain", "startNodeAtNode", "isOptionalMemberExpression", "hasPropertyAsPrivateName", "isObjectMethod", "finishNodeAt", "endLoc", "resetEndLocation", "lastTokEndLoc", "TokContext", "preserveSpace", "types", "brace", "j_oTag", "j_cTag", "j_expr", "beforeExpr", "startsExpr", "isLoop", "isAssign", "postfix", "ExportedTokenType", "label", "conf", "rightAssociative", "binop", "updateContext", "keywords", "Map", "createKeyword", "createToken", "createBinop", "tokenTypeCounter", "tokenTypes", "tokenLabels", "tokenBinops", "tokenBeforeExprs", "tokenStartsExprs", "tokenPrefixes", "_options$binop", "_options$beforeExpr", "_options$startsExpr", "_options$prefix", "createKeywordLike", "_options$binop2", "_options$beforeExpr2", "_options$startsExpr2", "_options$prefix2", "tt", "bracketL", "bracketHashL", "bracketBarL", "bracketR", "bracketBarR", "braceL", "braceBarL", "braceHashL", "braceR", "braceBarR", "parenL", "parenR", "comma", "semi", "colon", "doubleColon", "dot", "question", "questionDot", "arrow", "ellipsis", "backQuote", "dollarBraceL", "templateTail", "templateNonTail", "hash", "interpreterDirective", "eq", "slashAssign", "xorAssign", "moduloAssign", "incDec", "bang", "tilde", "doubleCaret", "doubleAt", "pipeline", "nullishCoalescing", "logicalOR", "logicalAND", "bitwiseOR", "bitwiseXOR", "bitwiseAND", "equality", "lt", "gt", "relational", "bitShift", "bitShiftL", "bitShiftR", "plusMin", "modulo", "star", "slash", "exponent", "_in", "_instanceof", "_break", "_case", "_catch", "_continue", "_debugger", "_default", "_else", "_finally", "_function", "_if", "_return", "_switch", "_throw", "_try", "_var", "_const", "_with", "_new", "_this", "_super", "_class", "_extends", "_export", "_import", "_null", "_true", "_false", "_typeof", "_void", "_delete", "_do", "_for", "_while", "_as", "_assert", "_async", "_await", "_defer", "_from", "_get", "_let", "_meta", "_of", "_sent", "_set", "_source", "_static", "_using", "_yield", "_asserts", "_checks", "_exports", "_global", "_implements", "_intrinsic", "_infer", "_is", "_mixins", "_proto", "_require", "_satisfies", "_keyof", "_readonly", "_unique", "_abstract", "_declare", "_enum", "_module", "_namespace", "_interface", "_type", "_opaque", "string", "num", "regexp", "privateName", "eof", "jsxName", "jsxText", "jsxTagStart", "jsxTagEnd", "placeholder", "tokenIsIdentifier", "tokenKeywordOrIdentifierIsKeyword", "tokenIsKeywordOrIdentifier", "tokenIsLiteralPropertyName", "tokenComesBeforeExpression", "tokenCanStartExpression", "tokenIsAssignment", "tokenIsFlowInterfaceOrTypeOrOpaque", "tokenIsLoop", "tokenIsKeyword", "tokenIsOperator", "tokenIsPostfix", "tokenIsPrefix", "tokenIsTSTypeOperator", "tokenIsTSDeclarationStart", "tokenLabelName", "tokenOperatorPrecedence", "tokenIsRightAssociative", "tokenIsTemplate", "getExportedToken", "context", "pop", "tc", "nonASCIIidentifierStartChars", "nonASCIIidentifierChars", "nonASCIIidentifierStart", "nonASCIIidentifier", "astralIdentifierStartCodes", "astralIdentifierCodes", "isInAstralSet", "i", "isIdentifierStart", "test", "fromCharCode", "isIdentifierChar", "reservedWords", "strict", "strictBind", "reservedWordsStrictSet", "reservedWordsStrictBindSet", "isReservedWord", "word", "inModule", "isStrictReservedWord", "has", "isStrictBindOnlyReservedWord", "isStrictBindReservedWord", "isKeyword", "isIteratorStart", "current", "next", "next2", "reservedWordLikeSet", "canBeReservedWord", "Scope", "var", "lexical", "functions", "ScopeHandler", "parser", "scopeStack", "undefinedExports", "inTopLevel", "currentScope", "inFunction", "currentVarScopeFlags", "allowSuper", "currentThisScopeFlags", "inClass", "inClassAndNotInNonArrowFunction", "inStaticBlock", "ScopeFlag", "inNonArrowFunction", "treatFunctionsAsVar", "treatFunctionsAsVarInScope", "createScope", "enter", "exit", "scope", "declareName", "bindingType", "checkRedeclarationInScope", "add", "maybeExportDefined", "delete", "isRedeclaredInScope", "values", "checkLocalExport", "topLevelScope", "FlowScope", "declareFunctions", "FlowScopeHandler", "BaseParser", "sawUnambiguousESM", "ambiguousScriptDifferentAst", "pluginConfig", "plugins", "pluginName", "pluginOptions", "actualOptions", "plugin", "_this$plugins$get", "setTrailingComments", "comments", "trailingComments", "undefined", "unshift", "setLeadingComments", "leadingComments", "setInnerComments", "innerComments", "adjustInnerComments", "elements", "commentWS", "lastElement", "CommentsParser", "addComment", "comment", "processComment", "commentStack", "commentStackLength", "lastCommentWS", "leadingNode", "nodeStart", "commentEnd", "containingNode", "finalizeComment", "splice", "trailingNode", "commentStart", "input", "charCodeAt", "finalizeRemainingComments", "resetPreviousNodeTrailingComments", "resetPreviousIdentifierLeadingComments", "takeSurroundingComments", "lineBreak", "lineBreakG", "isNewLine", "skipWhiteSpace", "skipWhiteSpaceInLine", "skipWhiteSpaceToLineBreak", "isWhitespace", "State", "curLine", "lineStart", "errors", "potentialArrowAt", "noArrowAt", "noArrowParamsConversionAt", "maybeInArrowParameters", "inType", "noAnonFunctionType", "hasFlowComment", "isAmbientContext", "inAbstractClass", "inDisallowConditionalTypesContext", "topicContext", "maxNumOfResolvableTopics", "maxTopicIndex", "soloAwait", "inFSharpPipelineDirectBody", "labels", "lastTokStart", "ct", "canStartJSXElement", "containsEsc", "firstInvalidTemplateEscapePos", "strictErrors", "tokensLength", "init", "strictMode", "sourceType", "startLine", "startColumn", "curPosition", "clone", "skipArrays", "val", "slice", "forbiddenNumericSeparatorSiblings", "decBinOct", "hex", "isAllowedNumericSeparatorSibling", "bin", "ch", "oct", "dec", "readStringContents", "initialPos", "initialLineStart", "initialCurLine", "out", "firstInvalidLoc", "chunkStart", "unterminated", "isStringEnd", "res", "readEscapedChar", "str", "containsInvalid", "inTemplate", "throwOnInvalid", "readHexChar", "readCodePoint", "fromCodePoint", "strictNumericEscape", "startPos", "octalStr", "match", "octal", "parseInt", "len", "forceLen", "n", "readInt", "invalidEscapeSequence", "allowNumSeparator", "bailOnError", "forbiddenSiblings", "isAllowedSibling", "invalid", "total", "Infinity", "prev", "Number", "isNaN", "unexpectedNumericSeparator", "numericSeparatorInEscapeSequence", "_isDigit", "invalidDigit", "indexOf", "invalidCodePoint", "buildPosition", "VALID_REGEX_FLAGS", "Token", "Tokenizer", "isLookahead", "errorHandlers_readInt", "errorRecovery", "errorBuilder", "errorHandlers_readCodePoint", "errorHandlers_readStringContents_string", "recordStrictModeErrors", "errorHandlers_readStringContents_template", "pushToken", "checkKeywordEscapes", "nextToken", "eat", "createLookaheadState", "curContext", "lookahead", "old", "curr", "nextTokenStart", "nextTokenStartSince", "lastIndex", "lookaheadCharCode", "nextTokenInLineStart", "nextTokenInLineStartSince", "lookaheadInLineCharCode", "codePointAtPos", "cp", "trail", "setStrict", "forEach", "toParseError", "clear", "skipSpace", "finishToken", "getTokenFromCode", "skipBlockComment", "skipLineComment", "startSkip", "spaceStart", "loop", "attachComment", "annexB", "commentWhitespace", "prevType", "replaceToken", "readToken_numberSign", "readToken_interpreter", "nextPos", "expectPlugin", "readWord1", "finishOp", "readToken_dot", "readNumber", "readToken_slash", "readToken_mult_modulo", "width", "readToken_pipe_amp", "readToken_caret", "proposal", "topicToken", "codePointAt", "readToken_atSign", "readToken_plus_min", "readToken_lt", "readToken_gt", "size", "readToken_eq_excl", "readToken_question", "readTemplateToken", "readRadixNumber", "readString", "readWord", "readRegexp", "escaped", "content", "mods", "char", "includes", "isBigInt", "replace", "startsWithDot", "isFloat", "isDecimal", "hasExponent", "isOctal", "hasLeadingZero", "integer", "underscorePos", "parseFloat", "quote", "readTemplateContinuation", "opening", "firstCode", "escStart", "identifierCheck", "esc", "keywordTypes", "raiseProperties", "raiseOverwrite", "expectOnePlugin", "pluginNames", "some", "ClassScope", "privateNames", "loneAccessors", "undefinedPrivateNames", "ClassScopeHandler", "stack", "oldClassScope", "from", "declarePrivateName", "elementType", "redefined", "accessor", "oldStatic", "newStatic", "oldKind", "newKind", "ExpressionScope", "canBeArrowParameterDeclaration", "isCertainlyParameterDeclaration", "ArrowHeadParsingScope", "declarationErrors", "recordDeclarationError", "ParsingErrorClass", "clearDeclarationError", "iterateErrors", "iterator", "ExpressionScopeHandler", "recordParameterInitializerError", "origin", "recordArrowParameterBindingError", "recordAsyncArrowParametersError", "validateAsPattern", "newParameterDeclarationScope", "newArrowHeadScope", "newAsyncArrowScope", "newExpressionScope", "ProductionParameterHandler", "stacks", "currentFlags", "hasAwait", "hasYield", "hasReturn", "hasIn", "functionFlags", "UtilParser", "addExtra", "isContextual", "isUnparsedContextual", "nameStart", "nameEnd", "nextCh", "isLookaheadContextual", "eatContextual", "expectContextual", "canInsertSemicolon", "hasPrecedingLineBreak", "hasFollowingLineBreak", "isLineTerminator", "semicolon", "allowAsi", "expect", "tryParse", "fn", "oldState", "abortSignal", "failState", "thrown", "aborted", "checkExpressionErrors", "andThrow", "shorthandAssignLoc", "doubleProtoLoc", "privateKeyLoc", "optionalParametersLoc", "hasErrors", "isLiteralPropertyName", "property", "initializeScopes", "oldLabels", "oldExportedIdentifiers", "exportedIdentifiers", "oldInModule", "oldScope", "getScopeHandler", "oldProdParam", "prodParam", "oldExpressionScope", "expressionScope", "enterInitialScopes", "paramFlags", "checkDestructuringPrivate", "ExpressionErrors", "Node", "ranges", "range", "NodePrototype", "prototype", "__clone", "newNode", "clonePlaceholder", "cloneIdentifier", "cloned", "create", "expectedNode", "cloneStringLiteral", "NodeUtils", "startNodeAt", "resetStartLocationFromNode", "locationNode", "reservedTypes", "FlowErrors", "AmbiguousConditionalArrow", "AmbiguousDeclareModuleKind", "AssignReservedType", "reservedType", "DeclareClassElement", "DeclareClassFieldInitializer", "DuplicateDeclareModuleExports", "EnumBooleanMemberNotInitialized", "memberName", "enumName", "EnumDuplicateMemberName", "EnumInconsistentMemberValues", "EnumInvalidExplicitType", "invalidEnumType", "EnumInvalidExplicitTypeUnknownSupplied", "EnumInvalidMemberInitializerPrimaryType", "explicitType", "EnumInvalidMemberInitializerSymbolType", "EnumInvalidMemberInitializerUnknownType", "EnumInvalidMemberName", "suggestion", "EnumNumberMemberNotInitialized", "EnumStringMemberInconsistentlyInitialized", "GetterMayNotHaveThisParam", "ImportReflectionHasImportType", "ImportTypeShorthandOnlyInPureImport", "InexactInsideExact", "InexactInsideNonObject", "InexactVariance", "InvalidNonTypeImportInDeclareModule", "MissingTypeParamDefault", "NestedDeclareModule", "NestedFlowComment", "PatternIsOptional", "SetterMayNotHaveThisParam", "SpreadVariance", "ThisParamAnnotationRequired", "ThisParamBannedInConstructor", "ThisParamMayNotBeOptional", "ThisParamMustBeFirst", "ThisParamNoDefault", "TypeBeforeInitializer", "TypeCastInPattern", "UnexpectedExplicitInexactInObject", "UnexpectedReservedType", "UnexpectedReservedUnderscore", "UnexpectedSpaceBetweenModuloChecks", "UnexpectedSpreadType", "UnexpectedSubtractionOperand", "UnexpectedTokenAfterTypeParameter", "UnexpectedTypeParameterBeforeAsyncArrowFunction", "UnsupportedDeclareExportKind", "unsupportedExportKind", "UnsupportedStatementInDeclareModule", "UnterminatedFlowComment", "isEsModuleType", "bodyElement", "hasTypeImportKind", "importKind", "exportSuggestions", "const", "let", "interface", "partition", "list", "list1", "list2", "FLOW_PRAGMA_REGEX", "flow", "flowPragma", "shouldParseTypes", "shouldParseEnums", "matches", "exec", "Error", "flowParseTypeInitialiser", "tok", "oldInType", "flowParseType", "flowParsePredicate", "moduloLoc", "parseExpression", "flowParseTypeAndPredicateInitialiser", "predicate", "flowParseDeclareClass", "flowParseInterfaceish", "flowParseDeclareFunction", "parseIdentifier", "typeNode", "typeContainer", "flowParseTypeParameterDeclaration", "tmp", "flowParseFunctionTypeParams", "this", "returnType", "typeAnnotation", "flowParseDeclare", "insideModule", "flowParseDeclareVariable", "flowParseDeclareModuleExports", "flowParseDeclareModule", "flowParseDeclareTypeAlias", "flowParseDeclareOpaqueType", "flowParseDeclareInterface", "flowParseDeclareExportDeclaration", "flowParseTypeAnnotatableIdentifier", "parseExprAtom", "bodyNode", "parseImport", "hasModuleExport", "default", "isLet", "exportKind", "flowParseTypeAnnotation", "finished", "flowParseTypeAlias", "flowParseOpaqueType", "isClass", "flowParseRestrictedIdentifier", "extends", "flowParseInterfaceExtends", "implements", "mixins", "flowParseObjectType", "allowStatic", "allowExact", "allowSpread", "allowProto", "allowInexact", "flowParseQualifiedTypeIdentifier", "flowParseTypeParameterInstantiation", "flowParseInterface", "checkNotUnderscore", "checkReservedType", "liberal", "right", "declare", "supertype", "impltype", "flowParseTypeParameter", "requireDefault", "nodeStartLoc", "variance", "flowParseVariance", "ident", "bound", "defaultRequired", "typeParameter", "oldNoAnonFunctionType", "flowParseTypeParameterInstantiationCallOrNew", "flowParseTypeOrImplicitInstantiation", "flowParseInterfaceType", "flowParseObjectPropertyKey", "flowParseObjectTypeIndexer", "isStatic", "static", "flowParseObjectTypeInternalSlot", "flowParseObjectTypeMethodish", "flowParseFunctionTypeParam", "flowParseObjectTypeCallProperty", "valueNode", "callProperties", "indexers", "internalSlots", "endDelim", "exact", "inexact", "protoStartLoc", "inexactStartLoc", "propOrInexact", "flowParseObjectTypeProperty", "flowObjectTypeSemicolon", "proto", "flowCheckGetterSetterParams", "paramCount", "_startLoc", "node2", "qualification", "flowParseGenericType", "flowParseTypeofType", "flowParsePrimaryType", "flowParseTupleType", "first", "lh", "isThis", "reinterpretTypeAsFunctionTypeParam", "flowIdentToTypeAnnotation", "isGroupedType", "parseLiteralAtNode", "createIdentifier", "flowParsePostfixType", "seenOptionalIndexedAccess", "objectType", "indexType", "flowParsePrefixType", "flowParseAnonFunctionWithoutParens", "param", "flowParseIntersectionType", "flowParseUnionType", "allowPrimitiveOverride", "typeCastToParameter", "allowExpressionBody", "forwardNoArrowParamsConversionAt", "parseFunctionBodyAndFinish", "parseStatementLike", "flowParseEnumDeclaration", "parseExpressionStatement", "expr", "shouldParseExportDeclaration", "isExportDefaultSpecifier", "parseExportDefaultExpression", "parseConditional", "setOptionalParametersError", "originalNoArrowAt", "consequent", "failed", "tryParseConditionalConsequent", "valid", "getArrowLikeExpressions", "alternate", "parseMaybeAssign", "parseMaybeAssignAllowIn", "disallowInvalid", "arrows", "finishArrowValidation", "every", "_node$extra", "toAssignableList", "trailingCommaLoc", "checkParams", "result", "parseParenItem", "typeCastNode", "assertModuleNodeAllowed", "parseExportDeclaration", "declarationNode", "parseExportSpecifiers", "parseExportFrom", "eatExportStar", "maybeParseExportNamespaceSpecifier", "hasNamespace", "parseClassId", "isStatement", "optionalId", "parseClassMember", "member", "parseClassMemberFromModifier", "isIterator", "readIterator", "fullWord", "left", "exprList", "toReferencedList", "isParenthesizedExpr", "_expr$extra", "parseArrayLike", "close", "canBePattern", "isTuple", "isParenthesized", "isClassMethod", "isClassProperty", "isNonstaticConstructor", "isThisParam", "pushClassPrivateMethod", "parseClassSuper", "superTypeParameters", "implemented", "checkGetterSetterParams", "parsePropertyNamePrefixOperator", "parseObjPropValue", "parseAssignableListItemTypes", "parseMaybeDefault", "checkImportReflection", "module", "parseImportSpecifierLocal", "specifier", "local", "finishImportSpecifier", "isPotentialImportPhase", "isExport", "applyImportPhase", "parseImportSpecifier", "importedIsString", "isInTypeOnlyImport", "isMaybeTypeOnly", "firstIdent", "imported", "specifierTypeKind", "as_ident", "specifierIsTypeImport", "checkReservedWord", "parseBindingAtom", "parseFunctionParams", "parseVarId", "decl", "parseAsyncArrowFromCallExpression", "call", "shouldParseAsyncArrow", "afterLeftParse", "_jsx", "jsx", "currentContext", "_jsx2", "_jsx3", "abort", "_arrowExpression$extr", "arrowExpression", "maybeUnwrapTypeCastExpression", "async", "parseArrow", "shouldParseArrow", "setArrowFunctionParameters", "allowDuplicates", "isArrowFunction", "strictModeChanged", "parseParenAndDistinguishExpression", "canBeArrow", "parseSubscripts", "parseCallExpressionArguments", "parseAsyncArrowWithTypeParameters", "subscriptState", "isLookaheadToken_lt", "typeArguments", "parseNewCallee", "targs", "parseArrowExpression", "parseTopLevel", "program", "fileNode", "skipFlowComment", "hasFlowCommentCompletion", "commentSkip", "shiftToFirstNonWhiteSpace", "ch2", "ch3", "flowEnumErrorBooleanMemberNotInitialized", "flowEnumErrorInvalidMemberInitializer", "enumContext", "flowEnumErrorNumberMemberNotInitialized", "flowEnumErrorStringMemberInconsistentlyInitialized", "flowEnumMemberInit", "endOfInit", "literal", "flowEnumMemberRaw", "flowEnumCheckExplicitTypeMismatch", "expectedType", "flowEnumMembers", "seenNames", "members", "booleanMembers", "numberMembers", "stringMembers", "defaultedMembers", "hasUnknownMembers", "memberNode", "toUpperCase", "flowEnumStringMembers", "initializedMembers", "flowEnumParseExplicitType", "flowEnumBody", "nameLoc", "empty", "boolsLen", "numsLen", "strsLen", "defaultedLen", "afterNext", "entities", "__proto__", "quot", "amp", "apos", "nbsp", "iexcl", "cent", "pound", "curren", "yen", "brvbar", "sect", "uml", "copy", "ordf", "laquo", "not", "shy", "reg", "macr", "deg", "plusmn", "sup2", "sup3", "acute", "micro", "para", "middot", "cedil", "sup1", "ordm", "raquo", "frac14", "frac12", "frac34", "iquest", "Agrave", "Aacute", "Acirc", "Atilde", "Auml", "Aring", "AElig", "Ccedil", "Egrave", "Eacute", "Ecirc", "Euml", "Igrave", "Iacute", "Icirc", "Iuml", "ETH", "Ntilde", "Ograve", "Oacute", "Ocirc", "Otilde", "Ouml", "times", "Oslash", "Ugrave", "Uacute", "Ucirc", "Uuml", "Yacute", "THORN", "szlig", "agrave", "aacute", "acirc", "atilde", "auml", "aring", "aelig", "ccedil", "egrave", "eacute", "ecirc", "euml", "igrave", "iacute", "icirc", "iuml", "eth", "ntilde", "ograve", "oacute", "ocirc", "otilde", "ouml", "divide", "oslash", "ugrave", "uacute", "ucirc", "uuml", "yacute", "thorn", "yuml", "OElig", "oelig", "Scaron", "scaron", "Yuml", "fnof", "circ", "Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Zeta", "Eta", "Theta", "Iota", "Kappa", "Lambda", "Mu", "Nu", "Xi", "Omicron", "Pi", "Rho", "Sigma", "Tau", "Upsilon", "Phi", "Chi", "Psi", "Omega", "alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota", "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigmaf", "sigma", "tau", "upsilon", "phi", "chi", "psi", "omega", "thetasym", "upsih", "piv", "ensp", "emsp", "thinsp", "zwnj", "zwj", "lrm", "rlm", "ndash", "mdash", "lsquo", "rsquo", "sbquo", "ldquo", "rdquo", "bdquo", "dagger", "Dagger", "bull", "hellip", "permil", "prime", "Prime", "lsaquo", "rsaquo", "oline", "frasl", "euro", "image", "weierp", "real", "trade", "alefsym", "larr", "uarr", "rarr", "darr", "harr", "crarr", "lArr", "uArr", "rArr", "dArr", "hArr", "forall", "part", "exist", "nabla", "isin", "notin", "ni", "prod", "sum", "minus", "lowast", "radic", "infin", "ang", "and", "or", "cap", "cup", "int", "there4", "sim", "cong", "asymp", "ne", "equiv", "le", "ge", "sub", "sup", "nsub", "sube", "supe", "oplus", "otimes", "perp", "sdot", "lceil", "rceil", "lfloor", "rfloor", "lang", "rang", "loz", "spades", "clubs", "hearts", "diams", "JsxErrors", "AttributeIsEmpty", "MissingClosingTagElement", "openingTagName", "MissingClosingTagFragment", "UnexpectedSequenceExpression", "HTMLEntity", "UnsupportedJsxValue", "UnterminatedJsxContent", "UnwrappedAdjacentJSXElements", "isFragment", "getQualifiedJSXName", "namespace", "jsxReadToken", "jsxReadEntity", "jsxReadNewLine", "normalizeCRLF", "jsxReadString", "codePoint", "count", "desc", "entity", "XHTMLEntities", "jsxReadWord", "jsxParseIdentifier", "jsxParseNamespacedName", "jsxParseElementName", "jsxParseAttributeValue", "setContext", "jsxParseExpressionContainer", "jsxParseEmptyExpression", "jsxParseSpreadChild", "previousContext", "jsxParseAttribute", "jsxParseOpeningElementAt", "jsxParseOpeningElementAfterName", "selfClosing", "jsxParseClosingElementAt", "jsxParseElementAt", "children", "openingElement", "closingElement", "contents", "openingFragment", "closingFragment", "jsxParseElement", "newContext", "TypeScriptScope", "enums", "constEnums", "classes", "exportOnlyBindings", "TypeScriptScopeHandler", "importsStack", "hasImport", "allowShadow", "isConst", "wasConst", "getOwn", "hasOwnProperty", "unwrapParenthesizedExpression", "LValParser", "_node$extra3", "last", "_node$extra2", "operator", "arg", "checkToRestConversion", "elt", "element", "toReferencedListDeep", "parseSpread", "parseRestBinding", "parseBindingList", "ParseBindingListFlags", "parseObjectLike", "closeCharCode", "allowEmpty", "elts", "checkCommaAfterRest", "parseDecorator", "parseAssignableListItem", "parseBindingRestProperty", "parseBindingProperty", "parsePropertyName", "_left", "ObjectProperty", "checkLVal", "in", "checkClashes", "hasParenthesizedAncestor", "_expression$extra", "checkIdentifier", "validity", "ParseErrorClass", "isParenthesizedExpression", "nextAncestor", "child", "declareNameFromIdentifier", "identifier", "allowPattern", "nonNull", "x", "assert", "TSErrors", "AbstractMethodHasImplementation", "methodName", "AbstractPropertyHasInitializer", "propertyName", "AccesorCannotDeclareThisParameter", "AccesorCannotHaveTypeParameters", "AccessorCannotBeOptional", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference", "ConstructorHasTypeParameters", "DeclareAccessor", "DeclareClassFieldHasInitializer", "DeclareFunctionHasImplementation", "DuplicateAccessibilityModifier", "modifier", "DuplicateModifier", "EmptyHeritageClauseType", "EmptyTypeArguments", "EmptyTypeParameters", "ExpectedAmbientAfterExportDeclare", "ImportAliasHasImportType", "IncompatibleModifiers", "modifiers", "IndexSignatureHasAbstract", "IndexSignatureHasAccessibility", "IndexSignatureHasDeclare", "IndexSignatureHasOverride", "IndexSignatureHasStatic", "InitializerNotAllowedInAmbientContext", "InvalidModifierOnTypeMember", "InvalidModifierOnTypeParameter", "InvalidModifierOnTypeParameterPositions", "InvalidModifiersOrder", "orderedModifiers", "InvalidPropertyAccessAfterInstantiationExpression", "InvalidTupleMemberLabel", "MissingInterfaceName", "NonAbstractClassHasAbstractMethod", "NonClassMethodPropertyHasAbstractModifer", "OptionalTypeBeforeRequired", "OverrideNotInSubClass", "PrivateElementHasAbstract", "PrivateElementHasAccessibility", "ReadonlyForMethodSignature", "ReservedArrowTypeParam", "ReservedTypeAssertion", "SetAccesorCannotHaveOptionalParameter", "SetAccesorCannotHaveRestParameter", "SetAccesorCannotHaveReturnType", "SingleTypeParameterWithoutTrailingComma", "typeParameterName", "StaticBlockCannotHaveModifier", "TupleOptionalAfterType", "TypeAnnotationAfterAssign", "TypeImportCannotSpecifyDefaultAndNamed", "TypeModifierIsUsedInTypeExports", "TypeModifierIsUsedInTypeImports", "UnexpectedParameterModifier", "UnexpectedReadonly", "UnexpectedTypeAnnotation", "UnexpectedTypeCastInParameter", "UnsupportedImportTypeArgument", "UnsupportedParameterPropertyKind", "UnsupportedSignatureParameterKind", "keywordTypeFromName", "tsIsAccessModifier", "tsIsVarianceAnnotations", "typescript", "tsParseInOutModifiers", "tsParseModifiers", "bind", "allowedModifiers", "disallowedModifiers", "errorTemplate", "tsParseConstModifier", "tsParseInOutConstModifiers", "tsIsIdentifier", "tsTokenCanFollowModifier", "tsNextTokenCanFollowModifier", "tsParseModifier", "stopOnStartOfClassStaticBlock", "tsIsStartOfStaticBlocks", "tsTryParse", "modified", "enforceOrder", "before", "after", "incompatible", "mod1", "mod2", "accessibility", "tsIsListTerminator", "tsParseList", "parseElement", "tsParseDelimitedList", "refTrailingCommaPos", "tsParseDelimitedListWorker", "expectSuccess", "trailingCommaPos", "tsParseBracketedList", "bracket", "skipFirstToken", "tsParseImportType", "qualifier", "tsParseEntityName", "tsParseTypeArguments", "allowReservedWords", "tsParseTypeReference", "typeName", "tsParseThisTypePredicate", "lhs", "parameterName", "tsParseTypeAnnotation", "asserts", "tsParseThisTypeNode", "tsParseTypeQuery", "exprName", "tsParseTypeParameter", "parseModifiers", "tsParseTypeParameterName", "constraint", "tsEatThenParseType", "tsTryParseTypeParameters", "tsParseTypeParameters", "tsFillSignature", "returnToken", "signature", "returnTokenRequired", "paramsKey", "returnTypeKey", "tsParseBindingListForSignature", "tsParseTypeOrTypePredicateAnnotation", "tsParseTypeMemberSemicolon", "tsParseSignatureMember", "tsIsUnambiguouslyIndexSignature", "tsTryParseIndexSignature", "tsLookAhead", "parameters", "tsTryParseTypeAnnotation", "tsParsePropertyOrMethodSignature", "readonly", "nodeAny", "firstParameter", "tsParseTypeMember", "idx", "tsParseTypeLiteral", "tsParseObjectTypeMembers", "tsIsStartOfMappedType", "tsParseMappedTypeParameter", "tsExpectThenParseType", "tsParseMappedType", "nameType", "tsParseType", "tsTryParseType", "tsParseTupleType", "elementTypes", "tsParseTupleElementType", "seenOptionalElement", "elementNode", "labeled", "chAfterWord", "wordName", "typeOrLabel", "tsParseNonArrayType", "labeledNode", "optionalTypeNode", "restNode", "tsParseParenthesizedType", "tsParseFunctionOrConstructorType", "abstract", "tsInAllowConditionalTypesContext", "tsParseLiteralTypeNode", "tsParseTemplateLiteralType", "parseTemplate", "parseTemplateSubstitution", "tsParseThisTypeOrThisTypePredicate", "thisKeyword", "parseMaybeUnary", "nodeType", "tsParseArrayTypeOrHigher", "tsParseTypeOperator", "tsParseTypeOperatorOrHigher", "tsCheckTypeAnnotationForReadOnly", "tsParseInferType", "tsParseConstraintForInferType", "tsInDisallowConditionalTypesContext", "tsParseUnionOrIntersectionType", "parseConstituentType", "hasLeadingOperator", "tsParseIntersectionTypeOrHigher", "tsParseUnionTypeOrHigher", "tsIsStartOfFunctionType", "tsIsUnambiguouslyStartOfFunctionType", "tsSkipParameterStart", "previousErrorCount", "_unused2", "tsInType", "t", "tsParseTypePredicateAsserts", "thisTypePredicate", "typePredicateVariable", "tsParseTypePredicatePrefix", "tsTryParseTypeOrTypePredicateAnnotation", "eatColon", "tsParseNonConditionalType", "checkType", "extendsType", "trueType", "falseType", "isAbstractConstructorSignature", "tsParseTypeAssertion", "tsParseHeritageClause", "originalStartLoc", "delimitedList", "tsParseInterfaceDeclaration", "tsParseTypeAliasDeclaration", "tsInNoContext", "cb", "oldContext", "oldInDisallowConditionalTypesContext", "tsNextThenParseType", "tsParseEnumMember", "initializer", "tsParseEnumDeclaration", "tsParseModuleBlock", "parseBlockOrModuleBlockBody", "tsParseModuleOrNamespaceDeclaration", "nested", "inner", "tsParseAmbientExternalModuleDeclaration", "global", "tsParseImportEqualsDeclaration", "maybeDefaultIdentifier", "moduleReference", "tsParseModuleReference", "tsIsExternalModuleReference", "tsParseExternalModuleReference", "f", "tsTryParseAndCatch", "tsTryParseDeclare", "nany", "startType", "tsInAmbientContext", "parseFunctionStatement", "parseClass", "parseVarStatement", "tsParseDeclaration", "tsTryParseExportDeclaration", "tsParseExpressionStatement", "mod", "tsCheckLineTerminator", "tsParseAbstractDeclaration", "tsTryParseGenericAsyncArrowFunction", "oldMaybeInArrowParameters", "tsParseTypeArgumentsInExpression", "reScan_lt", "reScan_lt_gt", "tsIsDeclarationStart", "override", "pp", "parameter", "isSimpleParameter", "tsDisallowOptionalPattern", "bodilessType", "registerFunctionStatementId", "tsCheckForInvalidTypeCasts", "items", "isInParens", "nonNullExpression", "isOptionalCall", "missingParenErrorLoc", "atPossibleAsyncArrow", "asyncArrowFn", "parseTaggedTemplateExpression", "tokenType", "_callee$extra", "parseExprOp", "leftStartLoc", "minPrec", "isSatisfies", "checkKeywords", "checkDuplicateExports", "importNode", "parseMaybeImportPhase", "parseImportSpecifiersAndAfter", "isAbstractClass", "cls", "allowMissingInitializer", "declarations", "isValidAmbientConstInitializer", "parseStatementContent", "parseAccessModifier", "tsHasSomeModifiers", "callParseClassMemberWithIsStatic", "parseClassStaticBlock", "parseClassMemberWithIsStatic", "hadSuperClass", "parsePostMemberNameModifiers", "methodOrProp", "isDeclare", "parseClassPropertyAnnotation", "definite", "parseClassAccessorProperty", "declareClassPrivateMethodInScope", "_typeCast", "_typeCast2", "typeCast", "_typeParameters", "reportReservedArrowTypeParam", "trailingComma", "sawUnary", "toAssignableParenthesizedExpression", "TSTypeCastExpression", "TSParameterProperty", "TSNonNullExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "parseMaybeDecoratorArguments", "canHaveLeadingDecorator", "getGetterSetterExpectedParamCount", "baseCount", "firstParam", "parseCatchClauseParam", "oldIsAmbientContext", "oldInAbstractClass", "maybeTakeDecorators", "shouldParseAsAmbientContext", "getExpression", "parseExportSpecifier", "isString", "isInTypeExport", "parseTypeOnlyImportExportSpecifier", "isImport", "isInTypeOnlyImportExport", "leftOfAsKey", "rightOfAsKey", "leftOfAs", "rightOfAs", "hasTypeSpecifier", "canParseAsKeyword", "firstAs", "secondAs", "parseModuleExportName", "kindKey", "isPossiblyLiteralEnum", "expressions", "isUncomputedMemberExpressionChain", "isNumber", "isNegativeNumber", "PlaceholderErrors", "ClassNameIsRequired", "UnexpectedSpace", "placeholders", "parsePlaceholder", "assertNoSpace", "finishPlaceholder", "isFinished", "chStartsBindingIdentifier", "verifyBreakContinue", "isBreak", "parseStatementOrSloppyAnnexBFunctionDeclaration", "parseBlock", "createNewLexicalScope", "parseFunctionId", "requireId", "oldStrict", "parseClassBody", "startsWith", "maybeParseExportDefaultSpecifier", "_specifiers", "checkExport", "filter", "maybeParseStarImportSpecifier", "parseNamedImportSpecifiers", "parseImportSource", "v8intrinsic", "parseV8Intrinsic", "v8IntrinsicStartLoc", "parseIdentifierName", "expectedConfig", "expectedName", "expectedOptions", "expectedKeys", "expectedOptionsIsEmpty", "p", "option", "find", "PIPELINE_PROPOSALS", "TOPIC_TOKENS", "RECORD_AND_TUPLE_SYNTAX_TYPES", "validatePlugins", "decoratorsBeforeExport", "allowCallParenthesized", "proposalList", "tupleSyntaxIsHash", "syntaxType", "tokenList", "missingPlugins", "mixinPlugins", "mixinPluginNames", "defaultOptions", "sourceFilename", "allowAwaitOutsideFunction", "allowReturnOutsideFunction", "allowNewTargetOutsideFunction", "allowImportExportEverywhere", "allowSuperOutsideMethod", "allowUndeclaredExports", "createImportExpressions", "createParenthesizedExpressions", "getOptions", "opts", "_opts$key", "ExpressionParser", "checkProto", "isRecord", "protoRef", "used", "shouldExitDescending", "disallowIn", "disallowInAnd", "parseExpressionBase", "allowInAnd", "parseMaybeAssignDisallowIn", "resultError", "_resultError$loc", "parseYield", "ownExpressionErrors", "parseMaybeConditional", "startIndex", "parseExprOps", "parseMaybeUnaryOrPrivate", "op", "prec", "checkPipelineAtInfixOperator", "logical", "coalesce", "parseExprOpRightExpr", "finishedNode", "nextOp", "withTopicBindingContext", "parseHackPipeBody", "parseSmartPipelineBodyInStyle", "parseExprOpBaseRightExpr", "withSoloAwaitPermittingContext", "parseFSharpPipelineBody", "_body$extra", "topicReferenceWasUsedInCurrentContext", "checkExponentialAfterUnary", "isAwait", "isAwaitAllowed", "parseAwait", "update", "isDelete", "parseUpdate", "isAmbiguousAwait", "updateExpressionNode", "parseExprSubscripts", "maybeAsyncArrow", "parseBind", "parseCoverCallAndAsyncArrowHead", "parseMember", "parseNoCallExpr", "tag", "quasi", "expectImportAttributesPlugin", "dynamicImport", "allowPlaceholder", "nodeForExtra", "oldInFSharpPipelineDirectBody", "addTrailingCommaExtraToNode", "parseExprListItem", "_call$extra", "parseSuper", "parseImportMetaProperty", "parseImportCall", "parseDo", "parseFunctionOrFunctionSent", "parseDecorators", "parseNewOrNewTarget", "parseTopicReferenceThenEqualsSign", "parseTopicReference", "pipeProposal", "lookaheadCh", "parseModuleExpression", "parseAsyncFunctionExpression", "parseAsyncArrowUnaryFunction", "topicTokenType", "topicTokenValue", "finishTopicReference", "testTopicReferenceConfiguration", "topicReferenceIsAllowedInCurrentContext", "registerTopicReference", "meta", "parseMetaProperty", "parseFunction", "isSource", "innerStartLoc", "spreadStartLoc", "optionalCommaStartLoc", "spreadNodeStartLoc", "innerEndLoc", "arrowNode", "wrapParenthesis", "parenExpression", "metaProp", "parseNew", "parseExprList", "parseTemplateElement", "isTagged", "elemStart", "elem", "isTail", "endOffset", "elemEnd", "cooked", "tail", "curElt", "quasis", "propHash", "parsePropertyDefinition", "maybeAsyncOrAccessorProp", "keyName", "_params", "finishedProp", "generator", "isExpression", "hasStrictModeDirective", "nonSimple", "isSimpleParamList", "formalParameters", "delegating", "delegate", "childExpr", "isSimpleReference", "checkSmartPipeTopicBodyEarlyErrors", "callback", "outerContextTopicState", "withSmartMixTopicForbiddingContext", "outerContextSoloAwaitState", "ParamKind", "ret", "revertScopes", "parseProgram", "loopLabel", "switchLabel", "loneSurrogate", "keywordRelationalOperator", "babel7CompatTokens", "hashEndPos", "hashEndLoc", "backquoteEnd", "backquoteEndLoc", "startToken", "templateValue", "templateElementEnd", "templateElementEndLoc", "endToken", "StatementParser", "interpreter", "parseInterpreterDirective", "finishedProgram", "stmtToDirective", "directiveLiteral", "hasFollowingBindingAtom", "endCh", "chStartsBindingPattern", "hasInLineFollowingBindingIdentifier", "startsUsingForOf", "startsAwaitUsing", "parseModuleItem", "ParseStatementFlag", "parseStatementListItem", "allowLabeledFunction", "parseStatement", "starttype", "allowDeclaration", "allowFunctionDeclaration", "parseBreakContinueStatement", "parseDebuggerStatement", "parseDoWhileStatement", "parseForStatement", "parseIfStatement", "parseReturnStatement", "parseSwitchStatement", "parseThrowStatement", "parseTryStatement", "parseWhileStatement", "parseWithStatement", "parseEmptyStatement", "nextTokenCharCode", "isAsyncFunction", "maybeName", "parseLabeledStatement", "decoratorsEnabledBeforeExport", "maybeDecorators", "classNode", "exportNode", "allowExport", "paramsStartLoc", "lab", "parseHeaderExpression", "awaitAt", "parseFor", "startsWithLet", "startsWithAwaitUsing", "starsWithUsingDeclaration", "isLetOrUsing", "initNode", "parseVar", "isForIn", "parseForIn", "startsWithAsync", "isForOf", "isHangingDeclaration", "ParseFunctionFlag", "discriminant", "cases", "cur", "sawDefault", "isCase", "block", "handler", "clause", "finalizer", "statementStart", "parsedNonDirective", "await", "isFor", "hangingDeclaration", "isDeclaration", "hadConstructor", "publicMethod", "privateMethod", "publicProp", "privateProp", "accessorProp", "publicMember", "parseClassElementName", "isPrivate", "maybeQuestionTokenStartLoc", "pushClassPrivateProperty", "pushClassProperty", "pushClassAccessorProperty", "_member$decorators", "parseInitializer", "hasDefault", "parseAfterDefault", "hasStar", "parseAfterNamespace", "isFromRequired", "hasSpecifiers", "maybeParseExportNamedSpecifiers", "hasDeclaration", "maybeParseExportDeclaration", "_node2$declaration", "isTypeExport", "assertions", "nextType", "hasFrom", "nextAfterFrom", "maybeParseImportAttributes", "checkJSONModuleImport", "checkNames", "isDefault", "isFrom", "_node$specifiers", "_declaration$extra", "nodes", "surrogate", "isJSONModuleImport", "singleBindingType", "_node$assertions", "nonDefaultNamedSpecifier", "phaseIdentifier", "isPrecedingIdImportPhase", "parseImportSourceAndAttributes", "parseNext", "maybeParseDefaultImportSpecifier", "_node$specifiers2", "parseImportAttributes", "attrs", "attrNames", "parseModuleAttributes", "useWith", "importSpecifier", "Parser", "pluginsMap", "pluginMap", "_options", "getParser", "ast", "moduleError", "generateExportedTokenTypes", "internalTokenTypes", "tokTypes", "getParserClass", "parserClassCache", "pluginsFromOptions", "pluginList", "require_base64", "__commonJSMin", "exports", "intToCharMap", "number", "charCode", "bigA", "bigZ", "littleA", "littleZ", "zero", "nine", "plus", "slash", "littleOffset", "numberOffset", "require_base64_vlq", "__commonJSMin", "exports", "base64", "VLQ_BASE_SHIFT", "VLQ_BASE", "VLQ_BASE_MASK", "VLQ_CONTINUATION_BIT", "toVLQSigned", "aValue", "fromVLQSigned", "isNegative", "shifted", "encoded", "digit", "vlq", "aStr", "aIndex", "aOutParam", "strLen", "result", "shift", "continuation", "require_util", "__commonJSMin", "exports", "getArg", "aArgs", "aName", "aDefaultValue", "urlRegexp", "dataUrlRegexp", "urlParse", "aUrl", "match", "urlGenerate", "aParsedUrl", "url", "MAX_CACHED_INPUTS", "lruMemoize", "f", "cache", "input", "i", "temp", "result", "normalize", "aPath", "path", "isAbsolute", "parts", "start", "part", "up", "join", "aRoot", "aPathUrl", "aRootUrl", "joined", "relative", "level", "index", "supportsNullProto", "obj", "identity", "toSetString", "aStr", "isProtoString", "fromSetString", "length", "compareByOriginalPositions", "mappingA", "mappingB", "onlyCompareOriginal", "cmp", "strcmp", "compareByOriginalPositionsNoSource", "compareByGeneratedPositionsDeflated", "onlyCompareGenerated", "compareByGeneratedPositionsDeflatedNoLine", "aStr1", "aStr2", "compareByGeneratedPositionsInflated", "parseSourceMapInput", "str", "computeSourceURL", "sourceRoot", "sourceURL", "sourceMapURL", "parsed", "require_array_set", "__commonJSMin", "exports", "util", "has", "hasNativeMap", "ArraySet", "aArray", "aAllowDuplicates", "set", "len", "aStr", "sStr", "isDuplicate", "idx", "aIdx", "require_mapping_list", "__commonJSMin", "exports", "util", "generatedPositionAfter", "mappingA", "mappingB", "lineA", "lineB", "columnA", "columnB", "MappingList", "aCallback", "aThisArg", "aMapping", "require_source_map_generator", "__commonJSMin", "exports", "base64VLQ", "util", "ArraySet", "MappingList", "SourceMapGenerator", "aArgs", "aSourceMapConsumer", "sourceRoot", "generator", "mapping", "newMapping", "sourceFile", "sourceRelative", "content", "generated", "original", "source", "name", "aSourceFile", "aSourceContent", "aSourceMapPath", "newSources", "newNames", "aGenerated", "aOriginal", "aSource", "aName", "previousGeneratedColumn", "previousGeneratedLine", "previousOriginalColumn", "previousOriginalLine", "previousName", "previousSource", "result", "next", "nameIdx", "sourceIdx", "mappings", "i", "len", "aSources", "aSourceRoot", "key", "map", "require_binary_search", "__commonJSMin", "exports", "recursiveSearch", "aLow", "aHigh", "aNeedle", "aHaystack", "aCompare", "aBias", "mid", "cmp", "index", "require_quick_sort", "__commonJSMin", "exports", "SortTemplate", "comparator", "swap", "ary", "x", "y", "temp", "randomIntInRange", "low", "high", "doQuickSort", "p", "r", "pivotIndex", "i", "pivot", "j", "q", "cloneSort", "template", "sortCache", "start", "require_source_map_consumer", "__commonJSMin", "exports", "util", "binarySearch", "ArraySet", "base64VLQ", "quickSort", "SourceMapConsumer", "aSourceMap", "aSourceMapURL", "sourceMap", "IndexedSourceMapConsumer", "BasicSourceMapConsumer", "aStr", "index", "c", "aSourceRoot", "aCallback", "aContext", "aOrder", "context", "order", "mappings", "sourceRoot", "boundCallback", "names", "sources", "sourceMapURL", "i", "n", "mapping", "source", "aArgs", "line", "needle", "originalLine", "originalColumn", "version", "sourcesContent", "file", "s", "aSource", "relativeSource", "smc", "generatedMappings", "destGeneratedMappings", "destOriginalMappings", "length", "srcMapping", "destMapping", "Mapping", "compareGenerated", "sortGenerated", "array", "start", "l", "a", "b", "j", "generatedLine", "previousGeneratedColumn", "previousOriginalLine", "previousOriginalColumn", "previousSource", "previousName", "cachedSegments", "temp", "originalMappings", "str", "segment", "end", "value", "subarrayStart", "currentSource", "aNeedle", "aMappings", "aLineName", "aColumnName", "aComparator", "aBias", "nextMapping", "name", "sc", "nullOnMissing", "url", "fileUriAbsPath", "sections", "lastOffset", "offset", "offsetLine", "offsetColumn", "sectionIndex", "section", "cmp", "content", "generatedPosition", "ret", "sectionMappings", "adjustedMapping", "require_source_node", "__commonJSMin", "exports", "SourceMapGenerator", "util", "REGEX_NEWLINE", "NEWLINE_CODE", "isSourceNode", "SourceNode", "aLine", "aColumn", "aSource", "aChunks", "aName", "aGeneratedCode", "aSourceMapConsumer", "aRelativePath", "node", "remainingLines", "remainingLinesIndex", "shiftNextLine", "lineContents", "getNextLine", "newLine", "lastGeneratedLine", "lastGeneratedColumn", "lastMapping", "mapping", "addMappingWithCode", "nextLine", "code", "sourceFile", "content", "source", "aChunk", "chunk", "i", "aFn", "len", "aSep", "newChildren", "aPattern", "aReplacement", "lastChild", "aSourceFile", "aSourceContent", "sources", "str", "aArgs", "generated", "map", "sourceMappingActive", "lastOriginalSource", "lastOriginalLine", "lastOriginalColumn", "lastOriginalName", "original", "idx", "length", "sourceContent", "require_source_map", "__commonJSMin", "exports", "require_estree_walker", "__commonJSMin", "exports", "module", "global", "factory", "WalkerBase", "node", "parent", "prop", "index", "SyncWalker", "enter", "leave", "_should_skip", "_should_remove", "_replacement", "skipped", "removed", "key", "value", "i", "AsyncWalker", "walk", "ast", "asyncWalk", "require_compiler_core_cjs_prod", "__commonJSMin", "exports", "shared", "parser", "sourceMapJs", "estreeWalker", "defaultOnError", "error", "defaultOnWarn", "msg", "createCompilerError", "code", "loc", "messages", "additionalMessage", "errorMessages", "FRAGMENT", "TELEPORT", "SUSPENSE", "KEEP_ALIVE", "BASE_TRANSITION", "OPEN_BLOCK", "CREATE_BLOCK", "CREATE_ELEMENT_BLOCK", "CREATE_VNODE", "CREATE_ELEMENT_VNODE", "CREATE_COMMENT", "CREATE_TEXT", "CREATE_STATIC", "RESOLVE_COMPONENT", "RESOLVE_DYNAMIC_COMPONENT", "RESOLVE_DIRECTIVE", "RESOLVE_FILTER", "WITH_DIRECTIVES", "RENDER_LIST", "RENDER_SLOT", "CREATE_SLOTS", "TO_DISPLAY_STRING", "MERGE_PROPS", "NORMALIZE_CLASS", "NORMALIZE_STYLE", "NORMALIZE_PROPS", "GUARD_REACTIVE_PROPS", "TO_HANDLERS", "CAMELIZE", "CAPITALIZE", "TO_HANDLER_KEY", "SET_BLOCK_TRACKING", "PUSH_SCOPE_ID", "POP_SCOPE_ID", "WITH_CTX", "UNREF", "IS_REF", "WITH_MEMO", "IS_MEMO_SAME", "helperNameMap", "registerRuntimeHelpers", "helpers", "s", "locStub", "createRoot", "children", "createVNodeCall", "context", "tag", "props", "patchFlag", "dynamicProps", "directives", "isBlock", "disableTracking", "isComponent", "getVNodeBlockHelper", "getVNodeHelper", "createArrayExpression", "elements", "createObjectExpression", "properties", "createObjectProperty", "key", "value", "createSimpleExpression", "content", "isStatic", "constType", "createInterpolation", "createCompoundExpression", "createCallExpression", "callee", "args", "createFunctionExpression", "params", "returns", "newline", "isSlot", "createConditionalExpression", "test", "consequent", "alternate", "createCacheExpression", "index", "isVNode", "createBlockStatement", "body", "createTemplateLiteral", "createIfStatement", "createAssignmentExpression", "left", "right", "createSequenceExpression", "expressions", "createReturnStatement", "ssr", "convertToBlock", "node", "helper", "removeHelper", "inSSR", "isStaticExp", "p", "isBuiltInType", "expected", "isCoreComponent", "nonIdentifierRE", "isSimpleIdentifier", "name", "validFirstIdentCharRE", "validIdentCharRE", "whitespaceRE", "isMemberExpressionBrowser", "path", "state", "stateStack", "currentOpenBracketCount", "currentOpenParensCount", "currentStringType", "i", "char", "isMemberExpressionNode", "ret", "isMemberExpression", "getInnerRange", "offset", "length", "newLoc", "advancePositionWithClone", "pos", "source", "numberOfCharacters", "advancePositionWithMutation", "linesCount", "lastNewLinePos", "assert", "condition", "findDir", "allowEmpty", "findProp", "dynamicOnly", "isStaticArgOf", "arg", "hasDynamicKeyVBind", "isText$1", "isVSlot", "isTemplateNode", "isSlotOutlet", "propsHelperSet", "getUnnormalizedProps", "callPath", "injectProp", "prop", "propsWithInjection", "parentCall", "first", "hasProp", "result", "propKeyName", "toValidAssetId", "type", "searchValue", "replaceValue", "hasScopeRef", "ids", "c", "b", "getMemoedVNodeCall", "forAliasRE", "deprecationData", "getCompatValue", "config", "isCompatEnabled", "mode", "checkCompatEnabled", "warnDeprecation", "message", "link", "err", "decodeRE", "decodeMap", "defaultParserOptions", "rawText", "_", "p1", "baseParse", "options", "createParserContext", "start", "getCursor", "parseChildren", "getSelection", "rawOptions", "ancestors", "parent", "last", "ns", "nodes", "isEnd", "startsWith", "parseInterpolation", "emitError", "parseComment", "parseBogusComment", "parseCDATA", "advanceBy", "parseTag", "parseElement", "isSpecialTemplateDirective", "parseText", "pushNode", "removedWhitespace", "shouldCondense", "prev", "next", "match", "prevIndex", "nestedIndex", "contentStart", "closeIndex", "wasInPre", "wasInVPre", "element", "isPreBoundary", "isVPreBoundary", "inlineTemplateProp", "startsWithEndTagOpen", "advanceSpaces", "cursor", "currentSource", "parseAttributes", "isSelfClosing", "tagType", "attributeNames", "attr", "parseAttribute", "nameSet", "_a", "pattern", "m", "parseAttributeValue", "match2", "isPropShorthand", "dirName", "startOffset", "loc2", "getNewPosition", "valueLoc", "modifiers", "quote", "isQuoted", "endIndex", "parseTextData", "unexpectedChars", "open", "close", "innerStart", "innerEnd", "rawContentLength", "rawContent", "preTrimContent", "endOffset", "endTokens", "column", "line", "end", "xs", "searchString", "hoistStatic", "root", "walk", "isSingleElementRoot", "child", "doNotHoistNode", "originalCount", "hoistedCount", "constantType", "getConstantType", "codegenNode", "flag", "getPatchFlag", "getGeneratedPropsConstantType", "getNodeProps", "i2", "hoisted", "constantCache", "cached", "returnType2", "generatedPropsType", "childType", "expType", "returnType", "allowHoistedHelperSet", "getConstantTypeOfHelperCall", "keyType", "valueType", "createTransformContext", "filename", "prefixIdentifiers", "hoistStatic2", "hmr", "cacheHandlers", "nodeTransforms", "directiveTransforms", "transformHoist", "isBuiltInComponent", "isCustomElement", "expressionPlugins", "scopeId", "slotted", "ssrCssVars", "bindingMetadata", "inline", "isTS", "onError", "onWarn", "compatConfig", "nameMatch", "count", "currentCount", "list", "removalIndex", "exp", "addId", "removeId", "identifier", "id", "identifiers", "transform", "traverseNode", "createRootCodegen", "traverseChildren", "nodeRemoved", "exitFns", "onExit", "createStructuralDirectiveTransform", "fn", "matches", "n", "PURE_ANNOTATION", "aliasHelper", "createCodegenContext", "ast", "sourceMap", "optimizeImports", "runtimeGlobalName", "runtimeModuleName", "ssrRuntimeModuleName", "addMapping", "withoutNewLine", "generate", "push", "indent", "deindent", "hasHelpers", "useWithBlock", "genScopeId", "isSetupInlined", "preambleContext", "genModulePreamble", "genFunctionPreamble", "functionName", "signature", "genAssets", "genNode", "VueBinding", "staticHelpers", "genHoists", "genImports", "assets", "resolver", "maybeSelfReference", "hoists", "needScopeIdWrapper", "importsOptions", "imports", "isText", "genNodeListAsArray", "multilines", "genNodeList", "comma", "genText", "genExpression", "genInterpolation", "genCompoundExpression", "genComment", "genVNodeCall", "genCallExpression", "genObjectExpression", "genArrayExpression", "genFunctionExpression", "genConditionalExpression", "genCacheExpression", "genTemplateLiteral", "genIfStatement", "genAssignmentExpression", "genSequenceExpression", "genReturnStatement", "pure", "genExpressionAsPropertyKey", "text", "callHelper", "genNullableArgs", "needNewline", "needsParens", "isNested", "l", "e", "walkIdentifiers", "onIdentifier", "includeAll", "parentStack", "knownIds", "rootExp", "TS_NODE_TYPES", "isLocal", "isRefed", "isReferencedIdentifier", "isFunctionType", "walkFunctionParams", "markScopeIdentifier", "walkBlockDeclarations", "isReferenced", "isInDestructureAssignment", "onIdent", "extractIdentifiers", "block", "stmt", "decl", "variable", "param", "object", "isStaticProperty", "isStaticPropertyKey", "grandparent", "isLiteralWhitelisted", "constantBailRE", "transformExpression", "processExpression", "dir", "asParams", "asRawStatements", "localVars", "rewriteIdentifier", "raw", "isAssignmentLVal", "isUpdateArg", "isDestructureAssignment", "isConst", "rVal", "operator", "rExp", "rawExp", "rExpString", "stringifyExpression", "isPrefix", "prefix", "postfix", "bailConstant", "isScopeVarReference", "isAllowedGlobal", "isLiteral", "node2", "needPrefix", "canPrefix", "a", "leadingText", "source2", "transformIf", "processIf", "ifNode", "branch", "isRoot", "siblings", "sibling", "createCodegenNodeForBranch", "parentCondition", "getParentCondition", "processCodegen", "createIfBranch", "userKey", "isSameKey", "isTemplateIf", "keyIndex", "createChildrenCodegenNode", "keyProperty", "firstChild", "vnodeCall", "branchExp", "transformFor", "processFor", "forNode", "renderExp", "isTemplate", "memo", "keyProp", "keyExp", "isStableFragment", "fragmentFlag", "childBlock", "needFragmentWrapper", "slotOutlet", "loop", "createForLoopParams", "parseResult", "parseForExpression", "addIdentifiers", "removeIdentifiers", "scopes", "forIteratorRE", "stripParensRE", "input", "inMatch", "LHS", "RHS", "createAliasExpression", "valueContent", "trimmedOffset", "iteratorMatch", "keyContent", "keyOffset", "indexContent", "range", "memoArgs", "createParamsList", "defaultFallback", "trackSlotScopes", "vSlot", "slotProps", "trackVForSlotScopes", "vFor", "buildClientSlotFn", "_vForExp", "buildSlots", "buildSlotFn", "slotsProperties", "dynamicSlots", "hasDynamicSlots", "onComponentSlot", "hasTemplateSlots", "hasNamedDefaultSlot", "implicitDefaultChildren", "seenSlotNames", "conditionalBranchIndex", "slotElement", "slotDir", "slotChildren", "slotLoc", "slotName", "dirLoc", "staticSlotName", "slotFunction", "vIf", "vElse", "buildDynamicSlot", "j", "conditional", "buildDefaultSlotProperty", "children2", "isNonWhitespaceContent", "slotFlag", "hasForwardedSlots", "slots", "directiveImportMap", "transformElement", "vnodeTag", "resolveComponentType", "isDynamicComponent", "vnodeProps", "vnodeChildren", "vnodePatchFlag", "vnodeDynamicProps", "dynamicPropNames", "vnodeDirectives", "shouldUseBlock", "propsBuildResult", "buildProps", "buildDirectiveArgs", "hasDynamicTextChild", "stringifyDynamicPropNames", "isExplicitDynamic", "isComponentTag", "isProp", "isDir", "builtIn", "fromSetup", "resolveSetupReference", "dotIndex", "bindings", "camelName", "PascalName", "checkType", "fromConst", "fromMaybeRef", "elementLoc", "mergeArgs", "runtimeDirectives", "hasChildren", "hasRef", "hasClassBinding", "hasStyleBinding", "hasHydrationEventBinding", "hasDynamicKeys", "hasVnodeHook", "pushMergeArg", "dedupeProperties", "analyzePatchFlag", "isEventHandler", "binding", "isVBind", "isVOn", "directiveTransform", "props2", "needRuntime", "propsExpression", "classKeyIndex", "styleKeyIndex", "hasDynamicKey", "classProp", "styleProp", "knownProps", "deduped", "existing", "mergeAsArray", "incoming", "dirArgs", "runtime", "trueExpression", "modifier", "propsNamesString", "transformSlotOutlet", "processSlotOutlet", "slotArgs", "expectedLen", "nonNameProps", "fnExpRE", "transformOn", "augmentor", "eventName", "rawName", "eventString", "shouldCache", "isMemberExp", "isInlineStatement", "hasMultipleStatements", "transformBind", "_node", "injectPrefix", "transformText", "currentContainer", "hasText", "callArgs", "seen$1", "transformOnce", "cur", "transformModel", "createTransformProps", "expString", "bindingType", "maybeRef", "propName", "assignmentExp", "eventArg", "altAssignment", "modifiersKey", "validDivisionCharRE", "transformFilter", "rewriteFilter", "parseFilter", "inSingle", "inDouble", "inTemplateString", "inRegex", "curly", "square", "paren", "lastFilterIndex", "expression", "filters", "pushFilter", "wrapFilter", "filter", "seen", "transformMemo", "getBaseTransformPreset", "baseCompile", "template", "isModuleMode", "noopDirectiveTransform", "require_compiler_core", "__commonJSMin", "exports", "module", "require_compiler_dom_cjs_prod", "__commonJSMin", "exports", "compilerCore", "shared", "V_MODEL_RADIO", "V_MODEL_CHECKBOX", "V_MODEL_TEXT", "V_MODEL_SELECT", "V_MODEL_DYNAMIC", "V_ON_WITH_MODIFIERS", "V_ON_WITH_KEYS", "V_SHOW", "TRANSITION", "TRANSITION_GROUP", "namedCharacterReferences", "maxCRNameLength", "decodeHtml", "rawText", "asAttr", "offset", "end", "decodedText", "advance", "length", "head", "remaining", "name", "value", "max", "name2", "semi", "hex", "body", "cp", "CCR_REPLACEMENTS", "isRawTextContainer", "parserOptions", "tag", "parent", "ns", "a", "transformStyle", "node", "p", "i", "parseInlineCSS", "cssText", "loc", "normalized", "createDOMCompilerError", "code", "DOMErrorMessages", "transformVHtml", "dir", "context", "exp", "transformVText", "transformModel", "baseResult", "isCustomElement", "directiveToUse", "isInvalidType", "type", "isEventOptionModifier", "isNonKeyModifier", "maybeKeyModifier", "isKeyboardEvent", "resolveModifiers", "key", "modifiers", "keyModifiers", "nonKeyModifiers", "eventOptionModifiers", "modifier", "transformClick", "event", "transformOn", "handlerExp", "modifierPostfix", "transformShow", "expReplaceRE", "stringifyStatic", "children", "nc", "ec", "currentChunk", "stringifyCurrentChunk", "currentIndex", "staticCall", "stringifyNode", "replaceHoist", "i2", "deleteCount", "child", "getHoistedNode", "result", "analyzeNode", "dataAriaRE", "isStringifiableAttr", "replacement", "hoistToReplace", "isNonStringifiable", "bailed", "bail", "walk", "node2", "stringifyElement", "evaluateConstant", "res", "innerHTML", "evaluated", "arg", "c", "ignoreSideEffectTags", "DOMNodeTransforms", "DOMDirectiveTransforms", "compile", "template", "options", "parse", "k", "require_compiler_dom", "__commonJSMin", "exports", "module", "require_reactivity_cjs_prod", "__commonJSMin", "exports", "shared", "activeEffectScope", "EffectScope", "detached", "fn", "currentEffectScope", "fromParent", "i", "l", "last", "effectScope", "recordEffectScope", "effect", "scope", "getCurrentScope", "onScopeDispose", "createDep", "effects", "dep", "wasTracked", "trackOpBit", "newTracked", "initDepMarkers", "deps", "finalizeDepMarkers", "ptr", "targetMap", "effectTrackDepth", "maxMarkerBits", "activeEffect", "ITERATE_KEY", "MAP_KEY_ITERATE_KEY", "ReactiveEffect", "scheduler", "parent", "lastShouldTrack", "shouldTrack", "cleanupEffect", "effect2", "options", "_effect", "runner", "stop", "trackStack", "pauseTracking", "enableTracking", "resetTracking", "track", "target", "type", "key", "depsMap", "trackEffects", "debuggerEventExtraInfo", "shouldTrack2", "trigger", "newValue", "oldValue", "oldTarget", "newLength", "key2", "triggerEffects", "triggerEffect", "getDepFromReactive", "object", "_a", "isNonTrackableKeys", "builtInSymbols", "arrayInstrumentations", "createArrayInstrumentations", "instrumentations", "args", "arr", "toRaw", "res", "hasOwnProperty", "obj", "BaseReactiveHandler", "_isReadonly", "_shallow", "receiver", "isReadonly2", "shallow", "shallowReadonlyMap", "readonlyMap", "shallowReactiveMap", "reactiveMap", "targetIsArray", "isRef", "readonly", "reactive", "MutableReactiveHandler", "value", "isReadonly", "isShallow", "hadKey", "result", "ReadonlyReactiveHandler", "mutableHandlers", "readonlyHandlers", "shallowReactiveHandlers", "shallowReadonlyHandlers", "toShallow", "getProto", "v", "get", "rawTarget", "rawKey", "has2", "wrap", "toReadonly", "toReactive", "has", "size", "add", "set", "get2", "deleteEntry", "clear", "hadItems", "createForEach", "callback", "thisArg", "observed", "createIterableMethod", "method", "targetIsMap", "isPair", "isKeyOnly", "innerIterator", "done", "createReadonlyMethod", "createInstrumentations", "mutableInstrumentations2", "shallowInstrumentations2", "readonlyInstrumentations2", "shallowReadonlyInstrumentations2", "mutableInstrumentations", "readonlyInstrumentations", "shallowInstrumentations", "shallowReadonlyInstrumentations", "createInstrumentationGetter", "mutableCollectionHandlers", "shallowCollectionHandlers", "readonlyCollectionHandlers", "shallowReadonlyCollectionHandlers", "targetTypeMap", "rawType", "getTargetType", "createReactiveObject", "shallowReactive", "shallowReadonly", "baseHandlers", "collectionHandlers", "proxyMap", "existingProxy", "targetType", "proxy", "isReactive", "isProxy", "raw", "markRaw", "trackRefValue", "ref2", "triggerRefValue", "newVal", "r", "ref", "createRef", "shallowRef", "rawValue", "RefImpl", "__v_isShallow", "useDirectValue", "triggerRef", "unref", "toValue", "source", "shallowUnwrapHandlers", "proxyRefs", "objectWithRefs", "CustomRefImpl", "factory", "customRef", "toRefs", "ret", "propertyToRef", "ObjectRefImpl", "_object", "_key", "_defaultValue", "val", "GetterRefImpl", "_getter", "toRef", "defaultValue", "ComputedRefImpl", "getter", "_setter", "isSSR", "self", "computed", "getterOrOptions", "debugOptions", "setter", "onlyGetter", "tick", "queue", "queued", "flush", "DeferredComputedRefImpl", "compareTarget", "hasCompareTarget", "scheduled", "computedTrigger", "valueToCompare", "e", "deferredComputed", "require_reactivity", "__commonJSMin", "exports", "module", "require_runtime_core_cjs_prod", "__commonJSMin", "exports", "reactivity", "shared", "warn$1", "msg", "args", "assertNumber", "val", "type", "callWithErrorHandling", "fn", "instance", "res", "err", "handleError", "callWithAsyncErrorHandling", "values", "i", "throwInDev", "contextVNode", "cur", "exposedInstance", "errorInfo", "errorCapturedHooks", "appErrorHandler", "logError", "isFlushing", "isFlushPending", "queue", "flushIndex", "pendingPostFlushCbs", "activePostFlushCbs", "postFlushIndex", "resolvedPromise", "currentFlushPromise", "nextTick", "p", "findInsertionIndex", "id", "start", "end", "middle", "middleJob", "middleJobId", "getId", "queueJob", "job", "queueFlush", "flushJobs", "invalidateJob", "queuePostFlushCb", "cb", "flushPreFlushCbs", "seen", "flushPostFlushCbs", "deduped", "a", "b", "comparator", "diff", "buffer", "setDevtoolsHook", "hook", "target", "_a", "_b", "event", "newHook", "emit", "rawArgs", "props", "isModelListener", "modelArg", "modifiersKey", "number", "trim", "handlerName", "handler", "onceHandler", "normalizeEmitsOptions", "comp", "appContext", "asMixin", "cache", "cached", "raw", "normalized", "hasExtends", "extendEmits", "raw2", "normalizedFromExtend", "key", "isEmitListener", "options", "currentRenderingInstance", "currentScopeId", "setCurrentRenderingInstance", "prev", "pushScopeId", "popScopeId", "withScopeId", "_id", "withCtx", "ctx", "isNonScopedSlot", "renderFnWithContext", "setBlockTracking", "prevInstance", "renderComponentRoot", "Component", "vnode", "proxy", "withProxy", "propsOptions", "slots", "attrs", "render", "renderCache", "data", "setupState", "inheritAttrs", "result", "fallthroughAttrs", "proxyToUse", "thisProxy", "normalizeVNode", "render2", "getFunctionalFallthrough", "blockStack", "createVNode", "Comment", "root", "keys", "shapeFlag", "filterModelListeners", "cloneVNode", "filterSingleRoot", "children", "singleRoot", "child", "isVNode", "shouldUpdateComponent", "prevVNode", "nextVNode", "optimized", "prevProps", "prevChildren", "component", "nextProps", "nextChildren", "patchFlag", "emits", "hasPropsChanged", "dynamicProps", "emitsOptions", "nextKeys", "updateHOCHostEl", "parent", "el", "COMPONENTS", "DIRECTIVES", "resolveComponent", "name", "maybeSelfReference", "resolveAsset", "NULL_DYNAMIC_COMPONENT", "resolveDynamicComponent", "resolveDirective", "warnMissing", "currentInstance", "selfName", "getComponentName", "resolve", "registry", "isSuspense", "SuspenseImpl", "n1", "n2", "container", "anchor", "parentComponent", "parentSuspense", "isSVG", "slotScopeIds", "rendererInternals", "mountSuspense", "patchSuspense", "hydrateSuspense", "createSuspenseBoundary", "normalizeSuspenseChildren", "Suspense", "triggerEvent", "eventListener", "patch", "createElement", "hiddenContainer", "suspense", "setActiveBranch", "unmount", "newBranch", "newFallback", "activeBranch", "pendingBranch", "isInFallback", "isHydrating", "isSameVNodeType", "timeout", "pendingId", "move", "next", "parentNode", "remove", "parentSuspenseId", "isSuspensible", "isVNodeSuspensible", "resume", "sync", "vnode2", "effects", "parentComponent2", "container2", "delayEnter", "anchor2", "hasUnresolvedAncestor", "fallbackVNode", "isSVG2", "mountFallback", "setupRenderEffect", "isInPendingSuspense", "hydratedEl", "asyncSetupResult", "handleSetupResult", "placeholder", "parentSuspense2", "doRemove", "node", "hydrateNode", "isSlotChildren", "normalizeSuspenseSlot", "block", "trackBlock", "isBlockTreeEnabled", "openBlock", "currentBlock", "closeBlock", "c", "queueEffectWithSuspense", "branch", "watchEffect", "effect", "doWatch", "watchPostEffect", "watchSyncEffect", "INITIAL_WATCHER_VALUE", "watch", "source", "immediate", "deep", "flush", "onTrack", "onTrigger", "getter", "forceTrigger", "isMultiSource", "s", "traverse", "cleanup", "onCleanup", "baseGetter", "ssrCleanup", "isInSSRComponentSetup", "useSSRContext", "oldValue", "newValue", "v", "scheduler", "queuePostRenderEffect", "unwatch", "instanceWatch", "value", "publicThis", "createPathGetter", "setCurrentInstance", "unsetCurrentInstance", "path", "segments", "withDirectives", "directives", "internalInstance", "getExposeProxy", "bindings", "dir", "arg", "modifiers", "invokeDirectiveHook", "oldBindings", "binding", "leaveCbKey", "enterCbKey", "useTransitionState", "state", "onMounted", "onBeforeUnmount", "TransitionHookValidator", "BaseTransitionPropsValidators", "BaseTransitionImpl", "getCurrentInstance", "prevTransitionKey", "getTransitionRawChildren", "rawProps", "mode", "emptyPlaceholder", "innerChild", "getKeepAliveChild", "enterHooks", "resolveTransitionHooks", "setTransitionHooks", "oldChild", "oldInnerChild", "transitionKeyChanged", "getTransitionKey", "leavingHooks", "earlyRemove", "delayedLeave", "leavingVNodesCache", "getLeavingNodesForType", "BaseTransition", "leavingVNodes", "appear", "persisted", "onBeforeEnter", "onEnter", "onAfterEnter", "onEnterCancelled", "onBeforeLeave", "onLeave", "onAfterLeave", "onLeaveCancelled", "onBeforeAppear", "onAppear", "onAfterAppear", "onAppearCancelled", "callHook", "callAsyncHook", "done", "hook2", "hooks", "leavingVNode", "afterHook", "cancelHook", "called", "cancelled", "key2", "isKeepAlive", "keepComment", "parentKey", "ret", "keyedFragmentCount", "Fragment", "defineComponent", "extraOptions", "isAsyncWrapper", "defineAsyncComponent", "loader", "loadingComponent", "errorComponent", "delay", "suspensible", "userOnError", "pendingRequest", "resolvedComp", "retries", "retry", "load", "thisRequest", "reject", "createInnerComp", "onError", "loaded", "error", "delayed", "ref2", "ce", "KeepAliveImpl", "sharedContext", "current", "_unmount", "storageContainer", "instance2", "vnodeHook", "invokeVNodeHook", "resetShapeFlag", "pruneCache", "filter", "pruneCacheEntry", "include", "exclude", "matches", "pendingCacheKey", "cacheSubtree", "getInnerChild", "onUpdated", "subTree", "da", "rawVNode", "max", "cachedVNode", "KeepAlive", "pattern", "onActivated", "registerKeepAliveHook", "onDeactivated", "wrappedHook", "injectHook", "injectToKeepAliveRoot", "keepAliveRoot", "injected", "onUnmounted", "prepend", "createHook", "lifecycle", "onBeforeMount", "onBeforeUpdate", "onServerPrefetch", "onRenderTriggered", "onRenderTracked", "onErrorCaptured", "renderList", "renderItem", "index", "l", "item", "createSlots", "dynamicSlots", "slot", "j", "renderSlot", "fallback", "noSlotted", "validSlotContent", "ensureValidVNode", "rendered", "createBlock", "vnodes", "toHandlers", "obj", "preserveCaseIfNecessary", "getPublicInstance", "isStatefulComponent", "publicPropertiesMap", "resolveMergedOptions", "hasSetupBinding", "PublicInstanceProxyHandlers", "accessCache", "normalizedProps", "n", "shouldCacheAccess", "publicGetter", "cssModule", "globalProperties", "descriptor", "RuntimeCompiledPublicInstanceProxyHandlers", "_", "defineProps", "defineEmits", "defineExpose", "exposed", "defineOptions", "defineSlots", "defineModel", "withDefaults", "defaults", "useSlots", "getContext", "useAttrs", "useModel", "createSetupContext", "normalizePropsOrEmits", "mergeDefaults", "opt", "mergeModels", "createPropsRestProxy", "excludedKeys", "withAsyncContext", "getAwaitable", "awaitable", "e", "applyOptions", "dataOptions", "computedOptions", "methods", "watchOptions", "provideOptions", "injectOptions", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "activated", "deactivated", "beforeDestroy", "beforeUnmount", "destroyed", "unmounted", "renderTracked", "renderTriggered", "errorCaptured", "serverPrefetch", "expose", "components", "filters", "resolveInjections", "methodHandler", "get", "set", "computed", "createWatcher", "provides", "provide", "registerLifecycleHook", "register", "_hook", "checkDuplicateProperties", "normalizeInject", "inject", "h", "r", "base", "mixins", "extendsOptions", "globalMixins", "optionMergeStrategies", "resolved", "m", "mergeOptions", "to", "from", "strats", "strat", "internalOptionMergeStrats", "mergeDataFn", "mergeEmitsOrPropsOptions", "mergeObjectOptions", "mergeAsArray", "mergeWatchOptions", "mergeInject", "merged", "createAppContext", "uid$1", "createAppAPI", "hydrate", "rootComponent", "rootProps", "context", "installedPlugins", "isMounted", "app", "version", "plugin", "mixin", "directive", "rootContainer", "isHydrate", "currentApp", "parentProvides", "defaultValue", "treatDefaultAsFactory", "hasInjectionContext", "initProps", "isStateful", "isSSR", "InternalObjectKey", "setFullProps", "updateProps", "rawPrevProps", "rawCurrentProps", "hasAttrsChanged", "propsToUpdate", "camelizedKey", "resolvePropValue", "kebabKey", "needCastKeys", "rawCastValues", "camelKey", "castValues", "isAbsent", "hasDefault", "propsDefaults", "normalizePropsOptions", "extendProps", "normalizedKey", "validatePropName", "prop", "booleanIndex", "getTypeIndex", "stringIndex", "getType", "ctor", "match", "isSameType", "expectedTypes", "t", "isInternalKey", "normalizeSlotValue", "normalizeSlot", "rawSlot", "normalizeObjectSlots", "rawSlots", "normalizeVNodeSlots", "initSlots", "updateSlots", "needDeletionCheck", "deletionComparisonTarget", "setRef", "rawRef", "oldRawRef", "isUnmount", "refValue", "owner", "ref", "oldRef", "refs", "_isString", "_isRef", "doSet", "existing", "hasMismatch", "isSVGContainer", "isComment", "createHydrationFunctions", "mountComponent", "patchProp", "createText", "nextSibling", "insert", "createComment", "isFragmentStart", "onMismatch", "handleMismatch", "domType", "nextNode", "Text", "isTemplateNode", "replaceNode", "Static", "needToAdoptContent", "hydrateFragment", "hydrateElement", "locateClosingAnchor", "createTextVNode", "hydrateChildren", "dirs", "transition", "forcePatch", "vnodeHooks", "needCallTransitionHooks", "needTransition", "content", "parentVNode", "fragmentSlotScopeIds", "isFragment", "next2", "open", "close", "newNode", "oldNode", "parentNode2", "createRenderer", "baseCreateRenderer", "createHydrationRenderer", "createHydrationFns", "hostInsert", "hostRemove", "hostPatchProp", "hostCreateElement", "hostCreateText", "hostCreateComment", "hostSetText", "hostSetElementText", "hostParentNode", "hostNextSibling", "hostSetScopeId", "hostInsertStaticContent", "getNextHostNode", "processText", "processCommentNode", "mountStaticNode", "processFragment", "processElement", "processComponent", "internals", "moveStaticNode", "removeStaticNode", "mountElement", "patchElement", "mountChildren", "setScopeId", "unmountChildren", "scopeId", "cloneIfMounted", "dynamicChildren", "oldProps", "newProps", "toggleRecurse", "areChildrenSVG", "patchBlockChildren", "patchChildren", "patchProps", "oldChildren", "newChildren", "fallbackContainer", "oldVNode", "newVNode", "fragmentStartAnchor", "fragmentEndAnchor", "traverseStaticChildren", "updateComponent", "initialVNode", "createComponentInstance", "setupComponent", "updateComponentPreRender", "componentUpdateFn", "bu", "u", "originNext", "nextTree", "prevTree", "bm", "isAsyncWrapperVNode", "hydrateSubTree", "scopedInitialVNode", "update", "c1", "prevShapeFlag", "c2", "patchKeyedChildren", "patchUnkeyedChildren", "oldLength", "newLength", "commonLength", "nextChild", "parentAnchor", "l2", "e1", "e2", "nextPos", "s1", "s2", "keyToNewIndexMap", "patched", "toBePatched", "moved", "maxNewIndexSoFar", "newIndexToOldIndexMap", "prevChild", "newIndex", "increasingNewIndexSequence", "getSequence", "nextIndex", "moveType", "leave", "delayLeave", "afterLeave", "remove2", "performLeave", "shouldInvokeDirs", "shouldInvokeVnodeHook", "unmountComponent", "removeFragment", "performRemove", "bum", "scope", "um", "allowed", "shallow", "ch1", "ch2", "arr", "len", "arrI", "isTeleport", "isTeleportDisabled", "isTargetSVG", "resolveTarget", "select", "targetSelector", "TeleportImpl", "querySelector", "disabled", "mainAnchor", "targetAnchor", "mount", "wasDisabled", "currentContainer", "currentAnchor", "moveTeleport", "nextTarget", "updateCssVars", "shouldRemove", "hydrateTeleport", "isReorder", "targetNode", "Teleport", "disableTracking", "setupBlock", "createElementBlock", "createBaseVNode", "transformVNodeArgs", "transformer", "normalizeKey", "normalizeRef", "ref_key", "ref_for", "isBlockNode", "needFullChildrenNormalization", "normalizeChildren", "_createVNode", "cloned", "isClassComponent", "guardReactiveProps", "klass", "style", "extraProps", "mergeRef", "mergedProps", "mergeProps", "text", "flag", "createStaticVNode", "numberOfNodes", "createCommentVNode", "asBlock", "slotFlag", "toMerge", "incoming", "emptyAppContext", "uid", "internalSetCurrentInstance", "globalCurrentInstanceSetters", "settersKey", "setupResult", "setupStatefulComponent", "setup", "setupContext", "resolvedResult", "finishComponentSetup", "compile", "installWithProxy", "registerRuntimeCompiler", "_compile", "isRuntimeOnly", "skipOptions", "template", "isCustomElement", "compilerOptions", "delimiters", "componentCompilerOptions", "finalCompilerOptions", "getAttrsProxy", "includeInferred", "getterOrOptions", "debugOptions", "propsOrChildren", "ssrContextKey", "initCustomFormatter", "withMemo", "memo", "isMemoSame", "_ssrUtils", "ssrUtils", "resolveFilter", "compatUtils", "require_runtime_core", "__commonJSMin", "exports", "module", "require_runtime_dom_cjs_prod", "__commonJSMin", "exports", "runtimeCore", "shared", "svgNS", "doc", "templateContainer", "nodeOps", "child", "parent", "anchor", "tag", "isSVG", "is", "props", "el", "text", "node", "selector", "id", "content", "start", "end", "before", "template", "wrapper", "TRANSITION", "ANIMATION", "vtcKey", "Transition", "slots", "resolveTransitionProps", "DOMTransitionPropsValidators", "TransitionPropsValidators", "callHook", "hook", "args", "h2", "hasExplicitCallback", "rawProps", "baseProps", "key", "name", "type", "duration", "enterFromClass", "enterActiveClass", "enterToClass", "appearFromClass", "appearActiveClass", "appearToClass", "leaveFromClass", "leaveActiveClass", "leaveToClass", "durations", "normalizeDuration", "enterDuration", "leaveDuration", "onBeforeEnter", "onEnter", "onEnterCancelled", "onLeave", "onLeaveCancelled", "onBeforeAppear", "onAppear", "onAppearCancelled", "finishEnter", "isAppear", "done", "removeTransitionClass", "finishLeave", "makeEnterHook", "resolve", "nextFrame", "addTransitionClass", "whenTransitionEnds", "forceReflow", "NumberOf", "n", "val", "cls", "c", "_vtc", "cb", "endId", "expectedType", "explicitTimeout", "resolveIfNotStale", "timeout", "propCount", "getTransitionInfo", "endEvent", "ended", "onEnd", "e", "styles", "getStyleProperties", "transitionDelays", "transitionDurations", "transitionTimeout", "getTimeout", "animationDelays", "animationDurations", "animationTimeout", "hasTransform", "delays", "d", "i", "toMs", "patchClass", "value", "transitionClasses", "vShowOldKey", "vShow", "transition", "setDisplay", "oldValue", "initVShowForSSR", "patchStyle", "prev", "next", "style", "isCssString", "setStyle", "currentDisplay", "importantRE", "v", "prefixed", "autoPrefix", "prefixes", "prefixCache", "rawName", "cached", "xlinkNS", "patchAttr", "instance", "isBoolean", "patchDOMProp", "prevChildren", "parentComponent", "parentSuspense", "unmountChildren", "newValue", "needRemove", "addEventListener", "event", "handler", "options", "removeEventListener", "veiKey", "patchEvent", "prevValue", "nextValue", "invokers", "existingInvoker", "parseName", "invoker", "createInvoker", "optionsModifierRE", "m", "cachedNow", "p", "getNow", "initialValue", "patchStopImmediatePropagation", "originalStop", "fn", "e2", "nativeOnRE", "patchProp", "shouldSetAsProp", "defineCustomElement", "hydrate2", "Comp", "VueCustomElement", "VueElement", "initialProps", "defineSSRCustomElement", "hydrate", "BaseClass", "_def", "_props", "render", "mutations", "def", "isAsync", "numberProps", "opt", "asyncDef", "declaredPropKeys", "camelKey", "shouldReflect", "shouldUpdate", "vnode", "dispatch", "css", "s", "useCssModule", "modules", "mod", "useCssVars", "getter", "positionMap", "newPositionMap", "moveCbKey", "enterCbKey", "TransitionGroupImpl", "state", "children", "moveClass", "hasCSSTransform", "callPendingCbs", "recordPosition", "movedChildren", "applyTranslation", "cssTransitionProps", "removeMode", "TransitionGroup", "oldPos", "newPos", "dx", "dy", "root", "clone", "container", "getModelAssigner", "onCompositionStart", "onCompositionEnd", "target", "assignKey", "vModelText", "lazy", "trim", "number", "castToNumber", "domValue", "elValue", "vModelCheckbox", "_", "modelValue", "elementValue", "getValue", "checked", "assign", "index", "found", "filtered", "cloned", "getCheckboxValue", "setChecked", "binding", "vModelRadio", "vModelSelect", "isSetModel", "selectedVal", "o", "setSelected", "_binding", "isMultiple", "l", "option", "optionValue", "vModelDynamic", "callModelHook", "prevVNode", "resolveDynamicModel", "tagName", "initVModelForSSR", "modelToUse", "systemModifiers", "modifierGuards", "modifiers", "withModifiers", "guard", "keyNames", "withKeys", "eventKey", "k", "rendererOptions", "renderer", "enabledHydration", "ensureRenderer", "ensureHydrationRenderer", "createApp", "app", "mount", "containerOrSelector", "normalizeContainer", "component", "proxy", "createSSRApp", "ssrDirectiveInitialized", "initDirectivesForSSR", "require_runtime_dom", "__commonJSMin", "exports", "module", "require_vue_cjs_prod", "__commonJSMin", "exports", "compilerDom", "runtimeDom", "shared", "_interopNamespaceDefault", "e", "n", "k", "runtimeDom__namespace", "compileCache", "compileToFunction", "template", "options", "key", "cached", "el", "opts", "tag", "code", "render", "require_vue", "__commonJSMin", "exports", "module", "import_vue", "TreeNode_default", "icons", "import_vue", "_hoisted_1", "_hoisted_2", "_hoisted_3", "_hoisted_4", "_hoisted_5", "render", "_ctx", "_cache", "$props", "$setup", "$data", "$options", "_component_TreeNode", "_resolveComponent", "_openBlock", "_createElementBlock", "_normalizeClass", "_createElementVNode", "$event", "_toDisplayString", "_withDirectives", "_Fragment", "_renderList", "n", "_createBlock", "_createCommentVNode", "_vShow", "TreeNode_default", "render", "NcBrowser_default", "TreeNode_default", "node", "files", "has_more", "start", "folder", "r", "file", "filename", "selected_file", "import_vue", "_hoisted_1", "_hoisted_2", "render", "_ctx", "_cache", "$props", "$setup", "$data", "$options", "_component_TreeNode", "_resolveComponent", "_openBlock", "_createElementBlock", "_createElementVNode", "_createVNode", "n", "NcBrowser_default", "render", "Browser", "options", "_a", "wrapper", "componentProps", "__objRest", "props", "app", "NcBrowser_default", "__spreadValues", "close_dialog", "nc_folder", "doctype", "docname", "dtdn", "pos", "nc_browser_bundle_default"]
}
